<!DOCTYPE html>
<html>
<head><meta name="generator" content="Hexo 3.9.0">
  <meta charset="utf-8">
  

  
  <title>不务正业的程序员</title>
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
  <meta name="description" content="iOS,iOS开发技术,Objective-C,Swift,Cocoa">
<meta property="og:type" content="website">
<meta property="og:title" content="不务正业的程序员">
<meta property="og:url" content="http://www.iosprogrammer.tech/page/2/index.html">
<meta property="og:site_name" content="不务正业的程序员">
<meta property="og:description" content="iOS,iOS开发技术,Objective-C,Swift,Cocoa">
<meta property="og:locale" content="zh-Hans">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="不务正业的程序员">
<meta name="twitter:description" content="iOS,iOS开发技术,Objective-C,Swift,Cocoa">
  
    <link rel="alternate" href="/atom.xml" title="不务正业的程序员" type="application/atom+xml">
  
  
    <link rel="icon" href="/favicon.png">
  
  
    <link href="//fonts.googleapis.com/css?family=Source+Code+Pro" rel="stylesheet" type="text/css">
  
  <link rel="stylesheet" href="/css/style.css">
</head>
</html>
<body>
  <div id="container">
    <div id="wrap">
      <header id="header">
  <div id="banner"></div>
  <div id="header-outer" class="outer">
    <div id="header-title" class="inner">
      <h1 id="logo-wrap">
        <a href="/" id="logo">不务正业的程序员</a>
      </h1>
      
        <h2 id="subtitle-wrap">
          <a href="/" id="subtitle">爱编程的大头（公众号同名）</a>
        </h2>
      
    </div>
    <div id="header-inner" class="inner">
      <nav id="main-nav">
        <a id="main-nav-toggle" class="nav-icon"></a>
        
          <a class="main-nav-link" href="/">Home</a>
        
          <a class="main-nav-link" href="/archives">Archives</a>
        
      </nav>
      <nav id="sub-nav">
        
          <a id="nav-rss-link" class="nav-icon" href="/atom.xml" title="RSS Feed"></a>
        
        <a id="nav-search-btn" class="nav-icon" title="Search"></a>
      </nav>
      <div id="search-form-wrap">
        <form action="//google.com/search" method="get" accept-charset="UTF-8" class="search-form"><input type="search" name="q" class="search-form-input" placeholder="Search"><button type="submit" class="search-form-submit">&#xF002;</button><input type="hidden" name="sitesearch" value="http://www.iosprogrammer.tech"></form>
      </div>
    </div>
  </div>
</header>
      <div class="outer">
        <section id="main">
  
    <article id="post-Growth-Hacker-FanBing" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/Growth-Hacker-FanBing/" class="article-date">
  <time datetime="2018-10-21T02:57:35.000Z" itemprop="datePublished">2018-10-21</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/读书/">读书</a>
  </div>

  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/Growth-Hacker-FanBing/">程序员读《增长黑客》</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <p><img src="http://image.iosprogrammer.hongbility.com/Books/%E3%80%8A%E5%A2%9E%E9%95%BF%E9%BB%91%E5%AE%A2%E3%80%8B%E5%B0%81%E9%9D%A2.jpg-200" alt="封面"></p>
<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>增长黑客，一群以数据驱动营销、以市场指导产品，通过<strong>技术手段</strong>贯彻增长目标的人。既然增长黑客把技术作为达成目标的工具，那作为一个以技术为生的程序员当然需要了解这一行业。</p>
<p>增长黑客最早在2010年由Qualaroo的创始人兼首席执行官肖恩·埃利斯提出，之后由安德鲁·陈在2012年4月发表的《Growth Hacker is the new VP Marketing》后引起业界广泛关注与交流，之后在国外尤其是硅谷的各家创业公司中开始设置类似职位并为各公司的发展提供了不可估量的作用。</p>
<p>但是在国内增长黑客的概念一直没有得到广泛的认识和发展，范冰的《增长黑客》一书正是作为一本启蒙书的形式被广泛认可。作为一名混迹互联网公司略有年头的技术人员，笔者有幸拜读此书并通过本文将书中内容总结出来作为“读后感”。希望为一些想要扩展视野的同行提供些许的帮助。</p>
<h1 id="内容简介"><a href="#内容简介" class="headerlink" title="内容简介"></a>内容简介</h1><p>根据书中章节和一些重点内容整理的思维导图：<br><img src="http://image.iosprogrammer.hongbility.com/Books/增长黑客.png-small" alt="思维导图"></p>
<p>《增长黑客》以互联网行业九死一生的环境为开端。“在国内，中小企业的平均寿命只有3.7年，小微企业还不到3年。至于创业门槛相对较低的互联网行业，能够幸存的比例甚至更低。”让读者深切体会到行业的残酷、活下去的艰难。并且直言众多互联网创业失败的原因在产品问世伊始就已经注定了。之后借助Hotmail仅仅通过在每封邮件的末尾加上一句“快来Hotmail申请你的免费邮箱”便在实现三周获取了30万用户的奇迹，来证明在互联网使用低成本驱动产品的方法是存在的，而发明这些方法的人就是<strong>增长黑客</strong>。</p>
<p>之后对增长黑客下了定义：增长黑客是一群以数据驱动营销、以市场指导产品，通过技术化手段贯彻增长目标的人。或许，《Growth Hacker is the new VP Marketing》一书中则定义了增长黑客们的工作内容：增长黑客们试图用更聪明的方式解答产品得以增长的奥秘，并使之成为助力产品增长的长效机制。他们通常采用的手段包括A/B测试、搜索引擎优化、电子邮件召回、病毒营销等，而页面加载速度、注册转化率、E-mail到达水平、病毒因子这些指标成为他们日常关注的对象。从中可以看出，增长黑客离不开对技术的使用，因此<strong>程序员可能是最接近和容易成为增长黑客的一群人</strong>。</p>
<p>紧接着提出了“AARRR”转化漏斗模型，即：Acquisition（获取用户）、Activiation（激发活跃）、Retention（提高留存）、Revenue（增加收入）、Referral（传播推荐）。后面的几章正是按照这个模型进行谋篇布局的。这个模型也贯穿了一个互联网产品的整个生命周期，并且在任何一个阶段都可能让一个产品折戟沉沙。</p>
<h2 id="创造正确的产品"><a href="#创造正确的产品" class="headerlink" title="创造正确的产品"></a>创造正确的产品</h2><p>任何营销、推广都是围绕着产品进行的，<strong>一款定位准确、可靠的产品是一切的开端和基石</strong>。</p>
<p>任何一款互联网产品被创造出来都只有一个目的那就是满足用户需求，PMF（产品与市场契合状态）就是用来描述产品对需求的满足程度的。最小化可行产品（MVP）是验证产品设想的不二之选。</p>
<p>最小化可行产品除了包含整个产品闭环的核心功能外，还需要为用户提供反馈渠道、方便查看的官方公告模块。其中核心功能比较难把握，在这里说一下我的理解，所谓核心功能应该是刚好可以满足产品闭环的基础功能，比如淘宝的核心功能应该就是浏览商品、下单，至于评价、物流，甚至购物车、搜索都不是核心功能；微信的核心功能就是加好友、文字聊天。通过对核心功能的梳理可以看出，真正的核心功能也正是一个产品的核心价值，它们也回答了一个产品是什么、是做什么的。</p>
<p>MVP提炼的好可以节省很多前期投入、更快的验证想法，但是在这个过程中也一定不能放松对产品质量的要求，可以不花哨一定要耐用。至于反馈渠道和官方公告就是为了让用户能够便捷的和产品沟通，提升用户的参与感，也能帮助产品更快更好的找到PMF。</p>
<p>“咕咚小区”在产品还没有满足PMF的前提下就花费大笔资金铺广告最后惨淡收场的例子恰好从反面证明了PMF的重要性。</p>
<p>用户调研的结果不可尽信。用户调研贯穿于产品的任何一个节点，形式是多种多样的，对产品的影响也是至关重要的。但是由于用户质量的参差不齐、目的不一，就造成用研的结果可能并不能真正反映用户在未来的做法。不要看用户说了什么，要看他们做了什么。</p>
<h2 id="获取用户"><a href="#获取用户" class="headerlink" title="获取用户"></a>获取用户</h2><p>获取用户，<strong>让潜在用户首次接触到产品</strong>。</p>
<p>首先获取的范围是潜在用户。应该根据产品的定位来寻找潜在用户，一款定位是年轻女性的产品，男性和大龄女性就不应该是潜在用户，不通物流的地区的用户就不是淘宝的潜在用户。抖音的潜在用户可以是所有的互联网用户，但是在产品早期应该把范围缩小到最容易传播、网络条件较好、网费较便宜的一批用户。</p>
<p>潜在的种子用户使用产品的过程称为产品的“冷启动”，它是在产品尚不具备完善的生态体系并<strong>能够提供足够多可消费内容</strong>的情况下，从零开始第一批用户和制造内容的过程。这个过程的前提是需要产品的提供方准备足够多的可供种子用户消费的内容，这些内容为种子用户将来要提供的内容的一个基调，种子用户提供的内容又会奠定产品在随后发展过程中的“逼格”，因此产品方既要提供足够多的内容供消费又要保证内容的质量。</p>
<p>给种子用户设置一定的门槛可能会有意想不到的效果。知乎早期的邀请码和小米的饥饿营销都为用户的入驻和体验设置了更高的门槛，但是却使产品获得了快速的传播，种子用户也为产品提供了一批优质的内容和良好的口碑。</p>
<p>在获取种子用户的过程中，需要警惕“产品蝗虫的出现”，这批用户是指那些产品目标以外的围观群体，他们可能是单纯好奇的观光客、寻找项目的投资人或是来做竞品调研的产品经理。由于产品前期的用户体量较小，“蝗虫”又有很强的嗅觉，就可能导致产品中出现大量的垃圾内容而影响正常用户的使用。社交产品最可能成为重灾区，早期的微信和子弹短信都曾被黄、赌的蝗虫充斥。</p>
<p>书中例举了很多获取用户的方法：利用社交网络、内容营销、搜索引擎和应用商店优化、饥饿营销、地推、海外扩张。其中有一些方案可能是被人嗤之以鼻的，比如无良小编的耸动标题、刷榜，但是这些方法却都是行之有效的。</p>
<h2 id="激发活跃"><a href="#激发活跃" class="headerlink" title="激发活跃"></a>激发活跃</h2><p>潜在用户接触产品后，获取用户的职责也就结束了，这时候用户对平台的忠诚度还很低，只有让用户参与到平台中来，他们才会拥护平台，平台才能出现生机。在MVP中留下反馈建议的入口也是为了让用户参与到平台的建设中来，往往能够为平台提意见的用户就是对平台最忠诚的。</p>
<p>LinkedIn通过优化新用户注册后邀请用户的数量、给好友发邮件的文案和导入邮箱通讯录的方式来一步步的激发了用户活跃，之后又加入了“声誉”系统把不活跃的用户调动起来，才建立了遍布全球的职场平台。</p>
<p>A/B测试是一种可以从多个备选方案选出较优的一种的解决方法，它常用于减少页面障碍、提升转化率、确定改版方案、新功能的小范围测试。</p>
<p>在产品中增加游戏化的元素是一种激发活跃的有效手段。现在产品中随处可见的签到、徽章、积分等元素正是游戏化的例证。这些方案不仅促进了用户的活跃度，而且用户也喜欢分享这些游戏化的“里程碑”，从而又能让产品利用社交化的渠道来获取用户。</p>
<p>此外，除了工具类的产品外，用户之间都会产生交互，这对于一个用户量不够大的产品是一个硬伤，很多产品也都倒在了这里。自动化脚本，或许是一种解决方案，它可以利用提前准备好的程序来和真实的用户沟通。游戏里面的“机器人”、微博等平台的“僵尸粉”都是活生生的例子，但是对脚本的使用也要把握好，不然会让用户产生反感。</p>
<h2 id="提高留存"><a href="#提高留存" class="headerlink" title="提高留存"></a>提高留存</h2><p>一鸟在手，胜过双鸟在林。在商业社会中5%的客户留存率增长意味着公司利润30%的增长，把产品卖给老客户的概率是卖给新客户的3倍。</p>
<p>造成用户留存率低的原因包括：</p>
<ol>
<li>存在程序漏洞、性能瓶颈。影响正常使用流程的程序漏洞是最容易引发客户流失的原因。淘宝为了满足海量用户的访问需求耗时几年建设了阿里云，12306至今没有完美解决宕机的问题等等。其中，连接超时、卡顿、黑屏、网络卡顿、交互性能差、CPU使用率高、内存泄漏、耗电过多等问题，都会让用户产生反感。</li>
<li>用户被频繁骚扰。微博在一段时间内对用户频繁推送轰炸，引起一片骂声，现在大多数推送内容都是关注的内容。即刻的出现也是为了解决信息过量的问题。但是，推送和关注量挂钩也对用户的关注行为产生了负面影响，为了避免过多的推送用户不得不谨小慎微的发起关注。经调查，女性用户对推送的容忍度要高于男性。</li>
<li>话题产品的热度减退。复仇者联盟的上映带火了一批以此为主题的游戏，但是随着话题产品的热度减退，类似产品的热度也会下降，用户又去追寻另一个热点了。</li>
<li>有更好的替代品。谷歌在国内最终被百度打败，eBay也因为水土不服败给淘宝，小咖秀、美拍等老牌短视频平台被抖音、快手两个后起之秀秒杀等例子先后上演。随着互联网用户增长的乏力，对已有用户的争夺战更加趋于白热化。</li>
<li>游戏通关、设备遗失、需求不再存在、产品生命周期终结等其他因素。</li>
</ol>
<p>留存率的衡量标准：次日留存率、7日留存率、30日留存率，分别反映了不同的含义。渠道留存，反映了在不同渠道的推广效果。</p>
<p>提高留存的方案：</p>
<ol>
<li>优化产品性能。由于网络和设备的性能千差万别，同一款产品在不同设备上的表现可能大相径庭，为了让产品能够在性能较差的设备上表现出较好的体验就需要团队不断优化。</li>
<li>有损服务。随着用户量的增加，产品所提供的服务容量越来越捉襟见肘，团队的预算也不是无限的，这就要求产品的生产者不得不舍弃一些特性。</li>
<li>引导新用户快速上手。对刚接触产品的新用户来说，获取产品内容的路径应该是尽量短的，注册、登录的流程应尽量简洁，尤其是首页的布局应该尽量清晰、突出主要功能。社区型产品适当引导新用户关注一些高质量的内容避免空白的瀑布流。</li>
<li>召回老用户。最有效的方式当属短信、邮件的唤回，内容包括 提供奖励、告知进展、个性化推荐、用户社交互动展示。探探会给老用户发送一条”近期被N个美女喜欢的短息”；招聘类网站会发送正有N个Boss查看JD的短信或邮件。</li>
</ol>
<h2 id="增加收入"><a href="#增加收入" class="headerlink" title="增加收入"></a>增加收入</h2><p>我们每天所需的食物和饮料，不是出自屠户、酿酒师或面包师的恩惠，而是出于他们自利的打算。我们不要求助于他们的爱他心，只要求助于他们的自爱心。我们不要向他们说我们必需，只说他们有利。这句出自《国富论》的经典语句，和《影响力》中的论点不谋而合。完美的诠释了“天下熙熙皆为利来，天下攘攘皆为利往”。</p>
<p>在完全竞争市场，长期产品的市场出清价格等于该产品的边际成本。互联网产品的边际成本极低甚至可以趋近于零。正因为如此，很多产品都采用免费策略来吸引用户。</p>
<p>免费产品的赚钱方式包括：增值付费、交叉补贴、广告、公司上市或被收购。</p>
<p>免费模式固然容易被用户接受，但是也这个因为用户的体验成本太低造成了对产品的低忠诚度和低迁移成本。当免费模式获取到过多的用户时，就造成了更多的维护和营销成本，但是纵然有很多的变现模式，想让用户掏第一分钱确是最难的。</p>
<p>找不到好的变现模式最终可能会拖垮一个产品。陌陌、抖音、豆瓣这些“国民级”的产品都还在变现的道路上艰难摸索，既要维持用户的脆弱心理又要获取盈利的两难局面很难平衡。</p>
<p>对于一些小而美的产品来说，用户量并不是最主要的，养活自己才是第一要务，因此它们选择了付费模式。在App Store的付费下载中有一些活的很滋润的付费产品。付费产品的门槛高也促进了用户对平台的忠诚度更高，产品拿了用户的钱也有更强的动力为用户提供更好的服务。</p>
<h2 id="病毒传播"><a href="#病毒传播" class="headerlink" title="病毒传播"></a>病毒传播</h2><p>病毒传播的两大核心指标是K因子和病毒循环周期。K因子=感染率*转化率，感染率是指某个用户向其他人传播产品的程度，转化率是指被感染人转化成新用户的比例。病毒循环周期是指从用户发出邀请，到新用户完成转化所花费的时间。</p>
<p>病毒传播中的用户心理把握</p>
<ol>
<li>人们总是比较愿意答应自己认识和喜欢的人提出的请求，还乐意主动传播自己喜爱的事物。这一点促使一些产品花重金请明星大咖做广告，或引导用户把内容分享到社交群。</li>
<li>逐利。趣头条的读新闻奖现金就是很好的利用了这一点。</li>
<li>互惠。拼多多。</li>
<li>求助。微信小游戏的分享泛滥。</li>
<li>炫耀。Keep健身打卡分享、英语流利说完成关卡分享、王者荣耀高光时刻分享。</li>
<li>稀缺。小米的饥饿营销。</li>
<li>害怕失去或错过。双十一、618。</li>
</ol>
<h1 id="个人感悟"><a href="#个人感悟" class="headerlink" title="个人感悟"></a>个人感悟</h1><ol>
<li>书中多次提高了Hotmail等邮件公司的创业，这些公司最终发展都不错，但是在中国却很少听说独立的邮件公司，或许是因为邮件的沟通方式在美国和中国的地位截然不同，国内互联网起步较晚，跨过了以邮件为主要沟通方式的阶段而直接买入了IM的形式</li>
<li>看到产品的人中有很少的一部分会成为用户，又会有更少的一部分会留下来，产品最终的收入来自更少的一部分用户。</li>
<li>从书中描述来看，Facebook为第三方平台提供的信息要比微信等国内平台所提供的丰富的多，这也促成了很多国外的产品借助社交平台发展壮大。从这点来看国内的大平台自信不足。</li>
<li>流量越来越便宜促进了直播、短视频行业的兴起。</li>
<li>作为程序员应该尽力优化产品的性能。据亚马逊的统计数据表明，网站的打开时间每多延迟100毫秒，就意味着多造成100万美元的营收损失，这都是真金白银啊。</li>
<li>书中多次提到了A/B测试和灰度发布，使用这些手段可以有效的避免对大面积用户的影响。作为一名程序员不应该因为这些工作看上去是无用功而产生排斥心理。证明不可行和证明可行同样重要。</li>
</ol>
<h1 id="附"><a href="#附" class="headerlink" title="附"></a>附</h1><p><a href="http://image.iosprogrammer.hongbility.com/Books/增长黑客.png" target="_blank" rel="noopener">思维导图大图</a></p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://www.iosprogrammer.tech/Growth-Hacker-FanBing/" data-id="ckcezpvjk000hkcs6l14vm81r" class="article-share-link">Share</a>
      
      
    </footer>
  </div>
  
</article>


  
    <article id="post-iOS-Memory-Management" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/iOS-Memory-Management/" class="article-date">
  <time datetime="2018-10-03T04:42:21.000Z" itemprop="datePublished">2018-10-03</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/iOS/">iOS</a>
  </div>

  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/iOS-Memory-Management/">iOS内存管理</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <p>本文内容是对<a href="https://developer.apple.com/library/archive/documentation/Cocoa/Conceptual/MemoryMgmt/Articles/MemoryMgmt.html#//apple_ref/doc/uid/10000011-SW1" target="_blank" rel="noopener">Advanced Memory Management Programming Guide</a>中重点内容的总结</p>
<h2 id="内存管理策略"><a href="#内存管理策略" class="headerlink" title="内存管理策略"></a>内存管理策略</h2><h3 id="基本内存管理规则"><a href="#基本内存管理规则" class="headerlink" title="基本内存管理规则"></a>基本内存管理规则</h3><p>内存管理模型基于对象所有权的。任何对象可能有一个或多个所有者。对象只要有超过一个所有者就会继续存在；如果一个对象没有所有者了，运行时系统就会把它销毁。为了让开发者清楚自己什么时候拥有/不拥有对象，Cocoa设置了一些规则：</p>
<ul>
<li>你拥有你创建的对象 - You own any object you create<blockquote>
<p>使用以”alloc”, “new”, “copy”, “mutableCopy”开头的方法创建对象</p>
</blockquote>
</li>
<li>你可以使用retain来获取对象的所有权<blockquote>
<p>可以在两种情况下使用<code>retain</code>：（1）在存储器方法的实现或者<code>init</code>方法中，获取要作为属性值存储的对象的所有权；（2）避免某些操作的副作用造成对象不可用</p>
</blockquote>
</li>
<li>当你不再需要的时候，一定要放弃对象所有权<blockquote>
<p>给对象发送<code>release</code>/<code>autorelease</code>消息来放弃所有权。因此，在Cocoa术语中，把放弃所有权称为”releasing”一个对象</p>
</blockquote>
</li>
<li>一定不能放弃你没有所有权的对象</li>
</ul>
<h2 id="内存管理实战"><a href="#内存管理实战" class="headerlink" title="内存管理实战"></a>内存管理实战</h2><h3 id="使用存储器方法来使内存管理更容易"><a href="#使用存储器方法来使内存管理更容易" class="headerlink" title="使用存储器方法来使内存管理更容易"></a>使用存储器方法来使内存管理更容易</h3><p>如果你的类有一个对象属性，你必须确保被设置的对象在使用过程中不会被释放。因此在它被设置的时候，你必须声明对它的所有权。并且你必须确保之后放弃对当前持有值的所有权。虽然这样做有时候是冗长乏味的，但是如果你坚持这种方法，就可以显著减少内存管理问题。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">@interface Counter : NSObject</span><br><span class="line">@property (nonatomic, retain) NSNumber *count;</span><br><span class="line">@end;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>这个<code>property</code>声明了一对存取器方法。通常，我们应当让编译器合成这些方法；但是，看一下它们是怎么实现的会很有意义。</p>
</blockquote>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">- (<span class="built_in">NSNumber</span> *)count &#123;</span><br><span class="line">    <span class="keyword">return</span> _count;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>“get”存取器只是返回了合成的实例变量并不需要<code>retain</code>或者<code>release</code></p>
</blockquote>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">- (<span class="keyword">void</span>)setCount:(<span class="built_in">NSNumber</span> *)newCount &#123;</span><br><span class="line">    [newCount <span class="keyword">retain</span>];</span><br><span class="line">    [_count release];</span><br><span class="line">    <span class="comment">// Make the new assignment.</span></span><br><span class="line">    _count = newCount;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>“set”存取器需要先<code>retain</code>新值，之后<code>release</code>旧值，最后进行赋值操作。为了避免前后是同一个对象的情况下出现意外的问题，必须要在<code>realse</code>之前调用<code>retain</code>。</p>
</blockquote>
<h3 id="不要在初始化和dealloc方法中使用存取器方法"><a href="#不要在初始化和dealloc方法中使用存取器方法" class="headerlink" title="不要在初始化和dealloc方法中使用存取器方法"></a>不要在初始化和dealloc方法中使用存取器方法</h3><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">- init &#123;</span><br><span class="line">    <span class="keyword">self</span> = [<span class="keyword">super</span> init];</span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">self</span>) &#123;</span><br><span class="line">        _count = [[<span class="built_in">NSNumber</span> alloc] initWithInteger:<span class="number">0</span>];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">self</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- initWithCount:(<span class="built_in">NSNumber</span> *)startingCount &#123;</span><br><span class="line">    <span class="keyword">self</span> = [<span class="keyword">super</span> init];</span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">self</span>) &#123;</span><br><span class="line">        _count = [startingCount <span class="keyword">copy</span>];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">self</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (<span class="keyword">void</span>)dealloc &#123;</span><br><span class="line">    [_count release];</span><br><span class="line">    [<span class="keyword">super</span> dealloc];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="使用弱引用来避免循环引用"><a href="#使用弱引用来避免循环引用" class="headerlink" title="使用弱引用来避免循环引用"></a>使用弱引用来避免循环引用</h3><p>只有当对象的所有强引用都释放后对象才能被释放，如果两个对象互相强引用了彼此，那么它们都不会被释放，这样就造成了<strong>循环引用</strong><br><img src="https://developer.apple.com/library/archive/documentation/Cocoa/Conceptual/MemoryMgmt/Art/retaincycles_2x.png" alt="循环引用"><br>弱引用可以解决循环引用的问题。弱引用是<em>non-owning</em>的关系。为了保持对象至少有一个引用而不被释放，不能把所有引用都设置成弱引用。因此，Cocoa建立了一个惯例，“parent”对象对“children”对象持有强引用，而children对象弱引用parent对象。如上图表示的一样。</p>
<p>当向弱引用的对象发送消息时一定要消息。如果向已经释放的兑现发送消息时会引起崩溃。这里特别注意的是：通知中心。当向NotificationCenter注册观察者时，通知中心会持有观察者的弱引用，如果观察者释放时没有主动从通知中心移除自己，通知中心会在之后向被释放掉的观察者发送消息，这时候会引起崩溃。（文档中还提到了delegate，但是在ARC下我们使用weak来修饰，就不会引起问题了。）</p>
<h3 id="避免正在使用的对象被释放"><a href="#避免正在使用的对象被释放" class="headerlink" title="避免正在使用的对象被释放"></a>避免正在使用的对象被释放</h3><p>下面两种情况是需要特别注意的：</p>
<ol>
<li><p>当一个对象从集合中移除的时候：</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">heisenObject = [array objectAtIndex:n];</span><br><span class="line">[array removeObjectAtIndex:n];</span><br><span class="line"><span class="comment">// heisenObject could now be invalid.</span></span><br></pre></td></tr></table></figure>
<blockquote>
<p>对象从集合中移除的时候，会收到<code>release</code>消息（而不是<code>autorelease</code>）。如果集合是对象的唯一持有者，这个对象会被立即释放。</p>
</blockquote>
</li>
<li><p>“parent object”释放</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">id</span> parent = &lt;<span class="meta">#create a parent object#&gt;;</span></span><br><span class="line"><span class="comment">// ...</span></span><br><span class="line">heisenObject = [parent child] ;</span><br><span class="line">[parent release]; <span class="comment">// Or, for example: self.parent = nil;</span></span><br><span class="line"><span class="comment">// heisenObject could now be invalid.</span></span><br></pre></td></tr></table></figure>
<blockquote>
<p>一个对象是由另一个对象生成的，之后直接或者间接的释放了父对象。如果这个释放导致了父对象的销毁，并且父对象是子对象的唯一持有者，那么子对象也会同时被销毁。</p>
</blockquote>
</li>
</ol>
<p>要想避免这些情况，我们可以<code>retain heisenObject</code>。比如：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">heisenObject = [[array objectAtIndex:n] retain];</span><br><span class="line">[array removeObjectAtIndex:n];</span><br><span class="line">// Use heisenObject...</span><br><span class="line">[heisenObject release];</span><br></pre></td></tr></table></figure></p>
<h3 id="不要使用dealloc管理稀缺资源"><a href="#不要使用dealloc管理稀缺资源" class="headerlink" title="不要使用dealloc管理稀缺资源"></a>不要使用dealloc管理稀缺资源</h3><p>不要在<code>dealloc</code>方法中管理文件描述符、网络连接、缓存或者缓冲区等稀有资源。特别是，类中的<code>dealloc</code>方法不是你认为会调用的时候就会调用。<code>dealloc</code>的调用可能会由于bug或者应用“tear-down”造成延迟或者不调用。</p>
<p>相反地，如果你有一个类的实例来管理稀缺资源，你应该把你的应用设计成当资源不在需要的时候调用“clean up”方法来清理资源，之后释放实例，<code>dealloc</code>会紧接着调用，这样的话，即使<code>dealloc</code>没有调用也不会引起其他问题。</p>
<p>如果在<code>dealloc</code>中管理稀缺资源可能会引起几个问题：</p>
<ol>
<li>对象图拆卸的顺序依赖性<br> 对象图的拆卸链是没有固定顺序的。</li>
<li>不回收稀缺资源<br> 内存泄露是应该被解决的bug，但是他们不会立即致命。如果稀缺资源没有按照预先设计的正常释放，可能会引起更严重的问题。比如，如果应用程序的文件描述符耗尽了，用户可能将无法保存数据。</li>
<li>在错误的线程上执行清理逻辑<br> 如果一个对象在意外时间自动释放，它将在它碰巧所在的任何线程的自动释放池块中被释放。对于只能从一个线程触及的资源，这中情况是非常严重的问题。</li>
</ol>
<h3 id="集合拥有它们包含的对象"><a href="#集合拥有它们包含的对象" class="headerlink" title="集合拥有它们包含的对象"></a>集合拥有它们包含的对象</h3><p>当把一个对象放到集合中（例如array，dictionary，set），集合会持有这个对象。当对象从集合中移除或者集合本身被释放的时候，集合会放弃所有权。因此，如果你想要创建一个“numbers”的数组时，可以这样做：<br><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">NSMutableArray</span> *array = &lt;<span class="meta">#Get a mutable array#&gt;;</span></span><br><span class="line"><span class="built_in">NSUInteger</span> i;</span><br><span class="line"><span class="comment">// ...</span></span><br><span class="line"><span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++) &#123;</span><br><span class="line">    <span class="built_in">NSNumber</span> *convenienceNumber = [<span class="built_in">NSNumber</span> numberWithInteger:i];</span><br><span class="line">    [array addObject:convenienceNumber];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>这样做，你没有调用<code>alloc</code>，因此不需要调用<code>release</code>。这里也不需要“retain”这些新的numbers，因为数组会这样做。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">NSMutableArray *array = &lt;#Get a mutable array#&gt;;</span><br><span class="line">NSUInteger i;</span><br><span class="line">// ...</span><br><span class="line">for (i = 0; i &lt; 10; i++) &#123;</span><br><span class="line">    NSNumber *allocedNumber = [[NSNumber alloc] initWithInteger:i];</span><br><span class="line">    [array addObject:allocedNumber];</span><br><span class="line">    [allocedNumber release];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>这种方式需要在<code>for</code>循环内<code>[allocedNumber release]</code>来匹配<code>alloc</code>，否则的话<code>allocedNumber</code>对象的引用计数就无法匹配了。</p>
<h3 id="所有权策略是使用引用计数来实现的"><a href="#所有权策略是使用引用计数来实现的" class="headerlink" title="所有权策略是使用引用计数来实现的"></a>所有权策略是使用引用计数来实现的</h3><ul>
<li>创建对象的时候，引用计数为1</li>
<li>向对象发送<code>retain</code>消息时，引用计数+1</li>
<li>向对象发送<code>release</code>消息时，引用计数-1。向对象发送<code>autorelease</code>消息时，对象的引用计数会在autorelease pool block的结尾处-1</li>
<li>引用计数减到0时，对象被销毁</li>
</ul>
<blockquote>
<p>不要使用<code>retainCount</code>来确定对象的引用计数，它是不准确的。应该使用引用计数规则结合代码来判断对象的引用计数。</p>
</blockquote>
<h2 id="使用Autorelease-Pool-Blocks"><a href="#使用Autorelease-Pool-Blocks" class="headerlink" title="使用Autorelease Pool Blocks"></a>使用Autorelease Pool Blocks</h2><p>自动释放池提供了一个可以用来<strong>废弃所有权而且又可以避免对象被立即销毁</strong>的机制。通常情况下，我们不需要创建自动释放吃，但是有些情况下必须使用或者如果使用了会提供一些益处。</p>
<h3 id="关于自动释放池"><a href="#关于自动释放池" class="headerlink" title="关于自动释放池"></a>关于自动释放池</h3><p>自动释放池是使用<code>@autoreleasepool</code>标记的<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">@autoreleasepool &#123;</span><br><span class="line">    // Code that creates autorelease objects.</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>在自动释放池的结尾，所有收到<code>autorelease</code>消息的对象会被发送<code>release</code>消息。</p>
<p>和其他的block类似，自动释放池也能够嵌套<br><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">@autoreleasepool</span> &#123;</span><br><span class="line">    <span class="comment">// . . .</span></span><br><span class="line">    <span class="keyword">@autoreleasepool</span> &#123;</span><br><span class="line">        <span class="comment">// . . .</span></span><br><span class="line">    &#125;</span><br><span class="line">    . . .</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>嵌套的自动释放池遵循就近原则。</p>
<p>Cocoa总是认为所有的代码会在自动释放池的范围内执行，否则的话自动释放的对象就无法被释放了，这样会导致内存泄露。如果有这种情况，Cocoa会打印出适当的错误信息。AppKit和UIKit框架中的事件循环迭代（例如鼠标点击或者用户触摸）都是在自动释放池内的。因此通常情况下，你不需要创建自动释放池。但是，下面的三种情况下，需要自己创建自动释放池：</p>
<ul>
<li>编写非UI framework程序时，例如命令行工具</li>
<li>在需要创建很多临时对象的循环中。在循环中使用自动释放池可以减少内存峰值</li>
<li>创建第二线程</li>
</ul>
<h3 id="使用自动释放池来降低内存峰值"><a href="#使用自动释放池来降低内存峰值" class="headerlink" title="使用自动释放池来降低内存峰值"></a>使用自动释放池来降低内存峰值</h3><p>有些代码需要创建一些自动释放的临时对象。这些对象直到自动释放池结尾处一直都在内存中。有时候这样做不会造成过多的内存提高；有时候这些对象过大就会造成过多的内存提升，而不得不尽快的释放这些临时对象。对于后一种情况，我们可以创建自己的自动释放池，在自动释放池的结尾这些占用内存的对象都会被销毁来节省内存。<br><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">NSArray</span> *urls = &lt;<span class="meta"># An array of file URLs #&gt;;</span></span><br><span class="line"><span class="keyword">for</span> (<span class="built_in">NSURL</span> *url <span class="keyword">in</span> urls) &#123;</span><br><span class="line"> </span><br><span class="line">    <span class="keyword">@autoreleasepool</span> &#123;</span><br><span class="line">        <span class="built_in">NSError</span> *error;</span><br><span class="line">        <span class="built_in">NSString</span> *fileContents = [<span class="built_in">NSString</span> stringWithContentsOfURL:url</span><br><span class="line">                                         encoding:<span class="built_in">NSUTF8StringEncoding</span> error:&amp;error];</span><br><span class="line">        <span class="comment">/* Process the string, creating and autoreleasing more objects. */</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p><code>for</code>循环每次都处理一个文件。在自动释放池中<code>fileContents</code>对象是“autoreleased”，当到达自动释放池的结尾会自动释放。每次都会自动回收内存，就避免了内存占用过多的问题。</p>
<p>切记，自动释放的对象只要超出最近的自动释放池范围后就会被释放。也就是说，自动释放的对象被释放后就无法继续使用了，不要向这些对象发送消息，也不要把它们作为返回值。例如下面的这种情况：<br><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">– (<span class="keyword">id</span>)findMatchingObject:(<span class="keyword">id</span>)anObject &#123;</span><br><span class="line"> </span><br><span class="line">    <span class="keyword">id</span> match;</span><br><span class="line">    <span class="keyword">while</span> (match == <span class="literal">nil</span>) &#123;</span><br><span class="line">        <span class="keyword">@autoreleasepool</span> &#123;</span><br><span class="line"> </span><br><span class="line">            <span class="comment">/* Do a search that creates a lot of temporary objects. */</span></span><br><span class="line">            match = [<span class="keyword">self</span> expensiveSearchForObject:anObject];</span><br><span class="line"> </span><br><span class="line">            <span class="keyword">if</span> (match != <span class="literal">nil</span>) &#123;</span><br><span class="line">                [match <span class="keyword">retain</span>]; <span class="comment">/* Keep match around. */</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    <span class="keyword">return</span> [match autorelease];   <span class="comment">/* Let match go and return it. */</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>向自动释放池内的<code>match</code>对象发送<code>retain</code>消息来延长它的生命期，这样我们就可以把自动释放池内的对象作为返回值了，同时使用<code>autorelease</code>标记返回值是为了匹配<code>retain</code>的引用计数。</p>
<h3 id="自动释放池和线程"><a href="#自动释放池和线程" class="headerlink" title="自动释放池和线程"></a>自动释放池和线程</h3><p>每一个Cocoa的应用程序都有自己的自动释放池栈。如果你正在编写只包含Foundation框架的程序，或者自己创建了一个线程，你需要自己创建自动释放池。</p>
<p>如果应用或线程是长久保存的并且潜在的生成了很多自动释放的对象，这时应该定期的清空并且创建自动释放池（就像 Application Kit 在主线程中做的那样）；否则，对象的积累会增加内存的占用。如果，独立的线程并没有使用 Cocoa 的调用，你没有必要去创建一个自动释放池。</p>
<blockquote>
<p>如果使用了 POSIX 线程 APIS 而不是 NSThread 对象来创建线程，你不能使用 Cocoa，包括 NSautoreleasePool，除非 Cocoa 是在多线程模式下，Cocoa 进入了多线程模式只有在首次创建 NSThread 对象的时候，为了在第二个 POSIX 线程中使用 Cocoa ，你的应用必须首先至少创建了一个独立的 NSThread 对象，这个对象可以立即退出。你可以通过 NSThread 类方法 isMultiTheraded 来测试 Cocoa 是否在多线程模式下。</p>
</blockquote>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://www.iosprogrammer.tech/iOS-Memory-Management/" data-id="ckcezpvjv000tkcs6pinx2xaa" class="article-share-link">Share</a>
      
      
    </footer>
  </div>
  
</article>


  
    <article id="post-Objective-C-Message-Forward" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/Objective-C-Message-Forward/" class="article-date">
  <time datetime="2018-09-19T14:08:34.000Z" itemprop="datePublished">2018-09-19</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/iOS/">iOS</a>►<a class="article-category-link" href="/categories/iOS/Apple开发文档/">Apple开发文档</a>
  </div>

  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/Objective-C-Message-Forward/">Objective-C 消息转发</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <h4 id="一些概念"><a href="#一些概念" class="headerlink" title="一些概念"></a>一些概念</h4><p><strong>静态绑定</strong>：在编译期就能决定运行时所应调用的函数。代表语言：C、C++等<br><strong>动态绑定</strong>：所要调用的函数直到运行期才能确定。代表语言：OC、swift等<br><strong>消息传递</strong>：对象正常解读消息，传递过去<br><strong>消息转发</strong>：对象无法解读消息，之后进行消息转发</p>
<h4 id="消息处理流程"><a href="#消息处理流程" class="headerlink" title="消息处理流程"></a>消息处理流程</h4><ol>
<li>OC中调用方法<code>[a method]</code>后都是在执行<code>id objc_msgSend(id receiver, SEL op, ...)</code><blockquote>
<p><code>id objc_msgSend(id self, SEL op, ...)</code>是一个参数个数可变的函数，第一参数代表接受者，第二个参数代表选择子（OC函数名），之后的参数就是消息中传入的参数。</p>
</blockquote>
</li>
<li>当消息发送给对象时，消息函数跟随对象的isa指针找到类结构，并尝试在cache中搜索类中是否有对应的<code>SEL</code>，如果找到在cache中找到了则直接调用，这种情况下消息发送的耗时和函数调用相差无几</li>
<li>若cache中搜索失败，则到该类对应的<code>dispatch table</code>中搜寻方法，如果能找到这个跟选择子名称相同的方法，就跳转到其实现代码，往下执行。</li>
<li>该类的<code>dispatch table</code>中没有找到则继续沿着类层级向上寻找直到NSObject，找到后则进行方法调用并缓存。</li>
<li>如果最终还是找不到，那就进入消息转发的流程去进行处理。</li>
</ol>
<h4 id="消息转发流程"><a href="#消息转发流程" class="headerlink" title="消息转发流程"></a>消息转发流程</h4><p><img src="https://upload-images.jianshu.io/upload_images/424855-83a396fca4f6c206.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="msg_forward.png"></p>
<ol>
<li>调用resolveInstanceMethod：征询接受者（所属的类）是否可以添加方法以处理未知的选择子？(此过程称为动态方法解析）若有，转发结束。若没有，走第二步。</li>
<li>调用forwardingTargetForSelector：询问接受者是否有其他对象能处理此消息。若有，转发结束，一切如常。若没有，走第三步。</li>
<li>调用forwardInvocation：运行期系统将消息封装到NSInvocation对象中，再给接受者一次机会。</li>
<li>以上三步还不行，就抛出异常：unrecognized selector sent to instance xxxx</li>
</ol>
<h4 id="消息转发实例"><a href="#消息转发实例" class="headerlink" title="消息转发实例"></a>消息转发实例</h4><ol>
<li><p>在ViewController的头文件中声明一个方法，但是不要在ViewController.m中实现</p>
 <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">ViewController.h</span><br><span class="line"></span><br><span class="line">#import &lt;UIKit/UIKit.h&gt;</span><br><span class="line"></span><br><span class="line">@interface ViewController : UIViewController</span><br><span class="line"></span><br><span class="line">- (void)testForwardMethod;</span><br><span class="line"></span><br><span class="line">@end</span><br></pre></td></tr></table></figure>
</li>
<li><p>在AppDelegate中调用ViewController的<code>testForwardMethod</code>方法</p>
 <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">AppDelegate.m</span><br><span class="line"></span><br><span class="line">[[[ViewController alloc] init] testForwardMethod];</span><br></pre></td></tr></table></figure>
</li>
<li><p>这时候编译没有问题，但是运行会出现<code>-[ViewController testForwardMethod]: unrecognized selector sent to instance 0x10581bfe0</code></p>
</li>
<li><p>在ViewController.m中增加消息转发的方法</p>
 <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">ViewController.m</span><br><span class="line"></span><br><span class="line">- (id)forwardingTargetForSelector:(SEL)aSelector</span><br><span class="line">&#123;</span><br><span class="line">    NSLog(@&quot;ViewController forwardingTargetForSelector&quot;);</span><br><span class="line">    return [[TestView alloc] init];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// 如果有方法的实现，所有消息转发的过程都不会进行</span><br><span class="line">//- (void)testForwardMethod</span><br><span class="line">//&#123;</span><br><span class="line">//    NSLog(@&quot;ViewController testForwardMethod&quot;);</span><br><span class="line">//&#125;</span><br><span class="line"></span><br><span class="line">TestView.m</span><br><span class="line"></span><br><span class="line">- (void)testForwardMethod</span><br><span class="line">&#123;</span><br><span class="line">    NSLog(@&quot;TestView testForwardMethod&quot;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<ul>
<li>(id)forwardingTargetForSelector:(SEL)aSelector; 把aSelector转发给其他类对象。</li>
</ul>
</blockquote>
</li>
<li><p>在ViewController.m中增加两个消息转发的方法</p>
 <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">ViewController.m</span><br><span class="line">  </span><br><span class="line">- (NSMethodSignature *)methodSignatureForSelector:(SEL)aSelector</span><br><span class="line">&#123;</span><br><span class="line">    NSLog(@&quot;ViewController methodSignatureForSelector&quot;);</span><br><span class="line">    if (aSelector == @selector(testForwardMethod))</span><br><span class="line">    &#123;</span><br><span class="line">        NSLog(@&quot;ViewController methodSignatureForSelector equal&quot;);</span><br><span class="line">        return [NSMethodSignature signatureWithObjCTypes:&quot;v@:&quot;];</span><br><span class="line">    &#125;</span><br><span class="line">    return [super methodSignatureForSelector:aSelector];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">-  (void)forwardInvocation:(NSInvocation *)anInvocation</span><br><span class="line">&#123;</span><br><span class="line">    NSLog(@&quot;ViewController forwardInvocation:&quot;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<ol>
<li><code>- (NSMethodSignature *)methodSignatureForSelector:(SEL)aSelector</code>返回一NSMethodSignature对象，该对象包含给定选择器标识的方法的描述。在方法转发过程中如果需要使<code>NSInvocation</code>则就需要使用这个方法<br>2.<code>signatureWithObjCTypes:</code>是用C字符串来创建<code>NSMethodSignature</code>对象，详细的描述以看<a href="https://blog.csdn.net/bigtiger1648/article/details/51084957" target="_blank" rel="noopener">这篇文章</a></li>
</ol>
</blockquote>
</li>
</ol>
<h4 id="避开动态绑定"><a href="#避开动态绑定" class="headerlink" title="避开动态绑定"></a>避开动态绑定</h4><p>要想不使用OC的动态绑定，唯一的方案是获取到方法地址直接调用。 <strong>这种方案仅适用于 对一个方法重复多次调用，并且对性能敏感 的情况 </strong></p>
<ol>
<li>通过<code>NSObject</code>的<code>methodForSelector</code>获取到方法实现的地址</li>
<li><p>使用指针直接调用方法<br>下面是以<code>setFilled:</code>方法为例</p>
 <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">void (*setter)(id, SEL, BOOL);</span><br><span class="line">int i;</span><br><span class="line"></span><br><span class="line">setter = (void (*)(id, SEL, BOOL))[target</span><br><span class="line">    methodForSelector:@selector(setFilled:)];</span><br><span class="line">for ( i = 0 ; i &lt; 1000 ; i++ )</span><br><span class="line">    setter(targetList[i], @selector(setFilled:), YES);</span><br></pre></td></tr></table></figure>
<blockquote>
<p><code>methodForSelector</code>不是Objective-C的特性，而是由Cocoa runtime system提供</p>
</blockquote>
</li>
</ol>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://www.iosprogrammer.tech/Objective-C-Message-Forward/" data-id="ckcezpvjm000kkcs682t9u127" class="article-share-link">Share</a>
      
      
    </footer>
  </div>
  
</article>


  
    <article id="post-learn-react-native-with-me-call-native" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/learn-react-native-with-me-call-native/" class="article-date">
  <time datetime="2018-09-12T08:18:46.000Z" itemprop="datePublished">2018-09-12</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/react-native/">react-native</a>
  </div>

  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/learn-react-native-with-me-call-native/">跟我一起学习React Native之调用原生模块</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <h4 id="写在前面"><a href="#写在前面" class="headerlink" title="写在前面"></a>写在前面</h4><p>这篇文章是“<a href="http://www.iosprogrammer.tech/categories/react-native/">跟我一起学react-native</a>”系列文章的第四篇。这系列文章会随着这个新闻项目的进行更新。想要跟我一起学习React Native的朋友可以关注我的微信公众号<strong>iOS进阶指南</strong>，或者<a href="https://tech.us18.list-manage.com/subscribe?u=340bfbe6219cff7b854f892c2&amp;id=ec1d8e7ba3" target="_blank" rel="noopener">订阅</a>我的<a href="http://www.iosprogrammer.tech">个人博客</a>。</p>
<h4 id="效果图"><a href="#效果图" class="headerlink" title="效果图"></a>效果图</h4><p><img src="https://upload-images.jianshu.io/upload_images/424855-d0105c3529fc4c43.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/180" alt="Share_WebView.png"></p>
<h4 id="加载WebView"><a href="#加载WebView" class="headerlink" title="加载WebView"></a>加载WebView</h4><p>通过<a href="https://facebook.github.io/react-native/docs/webview" target="_blank" rel="noopener">官方文档</a>可以查看WebView组件的详情。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&lt;WebView</span><br><span class="line">  source=&#123;&#123; uri: &apos;https://www.baidu.com/ &#125;&#125;</span><br><span class="line">  injectedJavaScript=&apos;window.postMessage(document.title)&apos;</span><br><span class="line">  onMessage=&#123;this.handleMessage&#125;</span><br><span class="line">/&gt;</span><br></pre></td></tr></table></figure></p>
<blockquote>
<p><code>source</code>: 要加载的资源；<br><code>injectedJavaScript</code>: 当资源加载完成后要执行的JS<strong>字符串</strong>；<br><code>window.postMessage()</code>会发出一个带有’data’参数的消息；<br><code>onMessage</code>来处理postMessage发出的消息，这里是把页面的title作为navigationBar的title。</p>
</blockquote>
<h4 id="调用iOS原生模块"><a href="#调用iOS原生模块" class="headerlink" title="调用iOS原生模块"></a>调用iOS原生模块</h4><p>建议先阅读<a href="https://facebook.github.io/react-native/docs/native-modules-ios" target="_blank" rel="noopener">官方文档</a>。这里以调用原生的友盟分享为例。（集成友盟分享和项目中info.plist中的相关设置不是这里的主要内容，有需要的可以百度一下。）</p>
<ol>
<li>项目中新建UShare类作为和RN的桥接类。<img src="https://upload-images.jianshu.io/upload_images/424855-a73f85b5f47019ac.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="UShare_Class.png"></li>
<li>UShare.m<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line">#import &quot;UShare.h&quot;</span><br><span class="line">#import &lt;UMSocialCore/UMSocialCore.h&gt;</span><br><span class="line">#import &lt;React/RCTBridgeModule.h&gt;</span><br><span class="line"></span><br><span class="line">@interface UShare () &lt;RCTBridgeModule&gt;</span><br><span class="line"></span><br><span class="line">@end</span><br><span class="line"></span><br><span class="line">@implementation UShare</span><br><span class="line">// 把UShare模块名暴露给JS</span><br><span class="line">RCT_EXPORT_MODULE();</span><br><span class="line"></span><br><span class="line">// platform: 0 QQ 1 QQ空间 2 微信 3 朋友圈 4 微博</span><br><span class="line">RCT_EXPORT_METHOD(shareToPlatform:(int)platform content:(NSString *)content)</span><br><span class="line">&#123;</span><br><span class="line">  UMSocialPlatformType type = UMSocialPlatformType_UnKnown;</span><br><span class="line">  switch (platform)</span><br><span class="line">  &#123;</span><br><span class="line">    case 0:</span><br><span class="line">      type = UMSocialPlatformType_QQ;</span><br><span class="line">      break;</span><br><span class="line">    case 1:</span><br><span class="line">      type = UMSocialPlatformType_Qzone;</span><br><span class="line">      break;</span><br><span class="line">    case 2:</span><br><span class="line">      type = UMSocialPlatformType_WechatSession;</span><br><span class="line">      break;</span><br><span class="line">    case 3:</span><br><span class="line">      type = UMSocialPlatformType_WechatTimeLine;</span><br><span class="line">      break;</span><br><span class="line">    case 4:</span><br><span class="line">      type = UMSocialPlatformType_Sina;</span><br><span class="line">      break;</span><br><span class="line">  &#125;</span><br><span class="line">// 分享一个纯文本内容作为示例</span><br><span class="line">  UMSocialMessageObject *msgObj = [UMSocialMessageObject messageObject];</span><br><span class="line">  msgObj.text = content;</span><br><span class="line">  [[UMSocialManager defaultManager] shareToPlatform:type messageObject:msgObj currentViewController:[[UIApplication sharedApplication] keyWindow].rootViewController completion:^(id result, NSError *error) &#123;</span><br><span class="line">    </span><br><span class="line">  &#125;];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">@end</span><br></pre></td></tr></table></figure>
</li>
</ol>
<blockquote>
<ol>
<li>桥接类必须遵守<code>RCTBridgeModule</code>协议</li>
<li>在类的.m文件中添加<code>RCT_EXPORT_MODULE()</code>，这个宏是用来指定暴露给JS的模块名，如果宏中没有参数则使用OC类名，如果OC类名以RCT开头，JS的模块名会去掉前缀。</li>
<li><code>RCT_EXPORT_METHOD</code>：把OC方法暴露给JS模块的宏。注意：OC方法暴露给JS后，JS的方法名是OC方法名中第一个冒号前面的部分，在这里就是<code>shareToPlatform</code>，而不是<code>shareToPlatform: content :</code>，并且暴露给JS的方法都被认为返回<code>void</code>，如果要返回内容需要使用回调。</li>
<li>JS中调用<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">import &#123; NativeModules &#125; from &apos;react-native&apos;</span><br><span class="line"></span><br><span class="line">var share = NativeModules.UShare</span><br><span class="line">share.shareToPlatform(platform, &quot;分享测试&quot;)</span><br></pre></td></tr></table></figure>
</li>
</ol>
</blockquote>
<p><strong>如果这篇文章能为你提供些许的帮助，我将不胜荣幸。如果你能慷慨的点个赞或者关注我，我将万分感激。</strong></p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://www.iosprogrammer.tech/learn-react-native-with-me-call-native/" data-id="ckcezpvjy000ykcs6m476ilx5" class="article-share-link">Share</a>
      
      
    </footer>
  </div>
  
</article>


  
    <article id="post-learn-react-native-with-me-mine-and-settings" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/learn-react-native-with-me-mine-and-settings/" class="article-date">
  <time datetime="2018-06-20T07:16:21.000Z" itemprop="datePublished">2018-06-20</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/react-native/">react-native</a>
  </div>

  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/learn-react-native-with-me-mine-and-settings/">跟我一起学习React Native之我的和设置</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <h4 id="写在前面"><a href="#写在前面" class="headerlink" title="写在前面"></a>写在前面</h4><p>这篇文章是“<a href="http://www.iosprogrammer.tech/categories/react-native/">跟我一起学react-native</a>”系列文章的第三篇。这系列文章会随着这个新闻项目的进行更新。想要跟我一起学习React Native的朋友可以关注我的微信公众号<strong>iOS进阶指南</strong>，或者订阅我的<a href="http://www.iosprogrammer.tech">个人博客</a>。</p>
<h4 id="效果图"><a href="#效果图" class="headerlink" title="效果图"></a>效果图</h4><p><img src="https://upload-images.jianshu.io/upload_images/424855-f451b6cc1f588e6e.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="我的和设置 效果图"></p>
<h4 id="“我的”界面"><a href="#“我的”界面" class="headerlink" title="“我的”界面"></a>“我的”界面</h4><ol>
<li>使用sectionList实现类似iOS中group类型的tableView<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">render() &#123;</span><br><span class="line">  return (</span><br><span class="line">    &lt;SectionList style=&#123;&#123; backgroundColor: &apos;#eeeeee&apos; &#125;&#125;</span><br><span class="line">      renderItem=&#123;this._renderItem&#125;</span><br><span class="line">        renderSectionHeader=&#123;(&#123; section: &#123; title &#125; &#125;) =&gt; (</span><br><span class="line">          &lt;View style=&#123;styles.sectionHeader&#125; /&gt;</span><br><span class="line">        )&#125;</span><br><span class="line">        ItemSeparatorComponent=&#123;() =&gt;</span><br><span class="line">          &lt;View style=&#123;&#123; height: 0.5, backgroundColor: &apos;#999999&apos; &#125;&#125; /&gt;</span><br><span class="line">        &#125;</span><br><span class="line">        sections=&#123;[</span><br><span class="line">          &#123; data: [&#123; id: 0 &#125;] &#125;,</span><br><span class="line">          &#123; data: [&#123; id: 10, name: &apos;关注的新闻&apos;, photo: require(&apos;../../img/news.png&apos;) &#125;] &#125;,</span><br><span class="line">          &#123;</span><br><span class="line">            data: [&#123; id: 20, name: &apos;反馈和建议&apos;, photo: require(&apos;../../img/feedback.png&apos;) &#125;,</span><br><span class="line">            &#123; id: 21, name: &apos;设置&apos;, photo: require(&apos;../../img/setting.png&apos;) &#125;]</span><br><span class="line">          &#125;,</span><br><span class="line">        ]&#125;</span><br><span class="line">        keyExtractor=&#123;(item) =&gt; item.id&#125;</span><br><span class="line">    /&gt;</span><br><span class="line">  )</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
</ol>
<p>renderItem：渲染每一行；renderSectionHeader：渲染组头视图；  ItemSeparatorComponent：每一行之间的分割线，类似iOS中的separator；sections：数据源。id用来区分不同的行。</p>
<ol>
<li>渲染一行<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line">_renderItem(info) &#123;</span><br><span class="line">  if (info.item.id == 0) &#123;</span><br><span class="line">    return (</span><br><span class="line">      &lt;TouchableHighlight onPress=&#123;() =&gt; self.onPress(info.item)&#125;&gt;</span><br><span class="line">        &lt;View style=&#123;styles.personInfo&#125;&gt;</span><br><span class="line">          &lt;Image</span><br><span class="line">            style=&#123;styles.avatar&#125;</span><br><span class="line">              source=&#123;&#123; uri: &apos;http://image.iosprogrammer.hongbility.com/react-native/problem-1.png&apos; &#125;&#125;</span><br><span class="line">                resizeMode=&apos;cover&apos;</span><br><span class="line">          /&gt;</span><br><span class="line">          &lt;View style=&#123;styles.nickname&#125;&gt;</span><br><span class="line">            &lt;View style=&#123;&#123; flex: 1, justifyContent: &apos;center&apos; &#125;&#125;&gt;</span><br><span class="line">              &lt;Text&gt;登录/注册&lt;/Text&gt;</span><br><span class="line">            &lt;/View&gt;</span><br><span class="line">            &lt;View style=&#123;&#123; flex: 1, justifyContent: &apos;center&apos; &#125;&#125;&gt;</span><br><span class="line">              &lt;Text style=&#123;&#123; color: &apos;#999999&apos; &#125;&#125;&gt;查看个人主页&lt;/Text&gt;</span><br><span class="line">            &lt;/View&gt;</span><br><span class="line">          &lt;/View&gt;</span><br><span class="line">          &lt;Image</span><br><span class="line">            style=&#123;styles.rightArrow&#125;</span><br><span class="line">            source=&#123;require(&apos;../../img/right_arrow.png&apos;)&#125;</span><br><span class="line">          /&gt;</span><br><span class="line">        &lt;/View&gt;</span><br><span class="line">      &lt;/TouchableHighlight&gt;</span><br><span class="line">    )</span><br><span class="line">  &#125; else &#123;</span><br><span class="line">    return (</span><br><span class="line">      &lt;View style=&#123;styles.cell&#125;&gt;</span><br><span class="line">        &lt;SimpleCell</span><br><span class="line">          title=&#123;info.item.name&#125;</span><br><span class="line">          photo=&#123;info.item.photo&#125;</span><br><span class="line">          onPress=&#123;() =&gt; self.onPress(info.item)&#125;</span><br><span class="line">        /&gt;</span><br><span class="line">      &lt;/View&gt;</span><br><span class="line">    )</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
</ol>
<p>从效果图可以看出，第一组第一行的内容和其他行不相同，因此分开来处理。<br><br>TouchableHighlight：这个组件用来接收用户的点击事件。<strong><em>只能有一个子节点。否则会报错</em></strong><br><strong>注意：</strong>onPress={() =&gt; self.onPress(info.item)} 这里用的是<strong>self</strong>而不是this。self的来源是：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">constructor(props) &#123;</span><br><span class="line">  super(props)</span><br><span class="line">  self = this</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>不用this的原因是这里的this表示的不是当前的MeScreen对象，所以如果用this就无法调用到onPress事件。</p>
<h4 id="“SimpleCell”组件"><a href="#“SimpleCell”组件" class="headerlink" title="“SimpleCell”组件"></a>“SimpleCell”组件</h4>  <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">export default class SimpleCell extends React.Component &#123;</span><br><span class="line">  render() &#123;</span><br><span class="line">    let logo = this.props.photo ? &lt;Image style=&#123;styles.logo&#125; source=&#123;this.props.photo&#125;/&gt; : null</span><br><span class="line">    let detail = this.props.detail ? &lt;View style=&#123;styles.detail&#125;&gt; </span><br><span class="line">    &lt;Text style=&#123;&#123;color: &apos;#999999&apos;&#125;&#125;&gt;&#123;this.props.detail&#125;&lt;/Text&gt; &lt;/View&gt; : null</span><br><span class="line">    return (</span><br><span class="line">      &lt;TouchableHighlight underlayColor=&apos;#999&apos; onPress=&#123;this.props.onPress&#125;&gt;</span><br><span class="line">        &lt;View style=&#123;styles.container&#125;&gt;</span><br><span class="line">          &#123;logo&#125;</span><br><span class="line">          &lt;View style=&#123;styles.titleView&#125;&gt;</span><br><span class="line">            &lt;Text&gt;&#123;this.props.title&#125;&lt;/Text&gt;</span><br><span class="line">          &lt;/View&gt;</span><br><span class="line">          &#123;detail&#125;</span><br><span class="line">          &lt;Image style=&#123;styles.rightArrow&#125;</span><br><span class="line">            source=&#123;require(&apos;../../img/right_arrow.png&apos;)&#125;</span><br><span class="line">          /&gt;</span><br><span class="line">        &lt;/View&gt;</span><br><span class="line">      &lt;/TouchableHighlight&gt;</span><br><span class="line">    )</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>“我的”中的cell前面有icon，“设置”里面没有，因此这里根据条件判断是否显示。</p>
<p>如遇到问题可以参考<a href="http://www.iosprogrammer.tech/learn-react-native-with-me-questions">遇到的问题和解决方案</a></p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://www.iosprogrammer.tech/learn-react-native-with-me-mine-and-settings/" data-id="ckcezpvjz000zkcs6bzy6suf8" class="article-share-link">Share</a>
      
      
    </footer>
  </div>
  
</article>


  


  <nav id="page-nav">
    
    <a class="extend prev" rel="prev" href="/">&laquo; Prev</a><a class="page-number" href="/">1</a><span class="page-number current">2</span><a class="page-number" href="/page/3/">3</a><a class="page-number" href="/page/4/">4</a><span class="space">&hellip;</span><a class="page-number" href="/page/6/">6</a><a class="extend next" rel="next" href="/page/3/">Next &raquo;</a>
  </nav>

</section>
        
          <aside id="sidebar">
  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Categories</h3>
    <div class="widget">
      <ul class="category-list"><li class="category-list-item"><a class="category-list-link" href="/categories/iOS/">iOS</a><ul class="category-list-child"><li class="category-list-item"><a class="category-list-link" href="/categories/iOS/Apple开发文档/">Apple开发文档</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/iOS/日期Date和时间Time/">日期Date和时间Time</a></li></ul></li><li class="category-list-item"><a class="category-list-link" href="/categories/react-native/">react-native</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/其他/">其他</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/直播/">直播</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/读书/">读书</a><ul class="category-list-child"><li class="category-list-item"><a class="category-list-link" href="/categories/读书/《Effective-Objective-C-2-0》/">《Effective Objective-C 2.0》</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/读书/数据结构与算法分析/">数据结构与算法分析</a></li></ul></li></ul>
    </div>
  </div>


  
    

  
    
  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Archives</h3>
    <div class="widget">
      <ul class="archive-list"><li class="archive-list-item"><a class="archive-list-link" href="/archives/2019/01/">January 2019</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2018/12/">December 2018</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2018/11/">November 2018</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2018/10/">October 2018</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2018/09/">September 2018</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2018/06/">June 2018</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2018/05/">May 2018</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2018/04/">April 2018</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2018/03/">March 2018</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2018/02/">February 2018</a></li></ul>
    </div>
  </div>


  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Recent Posts</h3>
    <div class="widget">
      <ul>
        
          <li>
            <a href="/DSAA-1-1/">引论</a>
          </li>
        
          <li>
            <a href="/Read-Effective-Objective-C-2-0-2/">读《Effective Objective-C 2.0》（二）</a>
          </li>
        
          <li>
            <a href="/Read-Effective-Objective-C-2-0-1/">读《Effective Objective-C 2.0》（一）</a>
          </li>
        
          <li>
            <a href="/Programming-With-ObjC/">OC编程基础</a>
          </li>
        
          <li>
            <a href="/KVC-KVO/">KVC/KVO 总结</a>
          </li>
        
      </ul>
    </div>
  </div>

  
</aside>
        
      </div>
      <footer id="footer">
  
  <div class="outer">
    <div id="footer-info" class="inner">
      &copy; 2020 施治昂<br>
      Powered by <a href="http://hexo.io/" target="_blank">Hexo</a>
    </div>
  </div>
</footer>
    </div>
    <nav id="mobile-nav">
  
    <a href="/" class="mobile-nav-link">Home</a>
  
    <a href="/archives" class="mobile-nav-link">Archives</a>
  
</nav>
    

<script src="//ajax.googleapis.com/ajax/libs/jquery/2.0.3/jquery.min.js"></script>


  <link rel="stylesheet" href="/fancybox/jquery.fancybox.css">
  <script src="/fancybox/jquery.fancybox.pack.js"></script>


<script src="/js/script.js"></script>



  </div>
</body>
</html>
<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>3个快速提高Hexo博客访问量的方法</title>
      <link href="hexo-blog-logo-gzh-recommend/"/>
      <url>hexo-blog-logo-gzh-recommend/</url>
      
        <content type="html"><![CDATA[<h3 id="Hexo-Nexo主题博客设置自定义icon图标"><a href="#Hexo-Nexo主题博客设置自定义icon图标" class="headerlink" title="Hexo Nexo主题博客设置自定义icon图标"></a>Hexo Nexo主题博客设置自定义icon图标</h3><p>到<a href="https://www.easyicon.net/">这个网站</a>下载一个icon，要分别下载16<em>16和32</em>32两个尺寸的图片，当然也可以自己做PNG的图片。</p><p>用刚下载的两个图片替换掉<code>themes/next/source/images</code>中对应的图片。这样自定义的图标就弄好了。</p><p>如果刷新页面后还没有改变请清除缓存，实在不行就用一个重来没有访问过博客的浏览器试试。</p><h3 id="Hexo博客Next主题添加公众号二维码来引流"><a href="#Hexo博客Next主题添加公众号二维码来引流" class="headerlink" title="Hexo博客Next主题添加公众号二维码来引流"></a>Hexo博客Next主题添加公众号二维码来引流</h3><p>之前的<a href="https://www.iosprogrammer.tech/Hexo%E5%9C%A8%E6%96%87%E7%AB%A0%E6%9C%AB%E5%B0%BE%E6%B7%BB%E5%8A%A0%E8%87%AA%E5%AE%9A%E4%B9%89%E5%86%85%E5%AE%B9/">一篇文章</a>用了自己修改next布局文件的方法来给博客每篇文章末尾添加图片，现在Next主题已经支持通过在<code>_config.yml</code>文件中添加配置来达到这个效果了。</p><p>把在<a href="http://mp.weixin.qq.com/">微信公众平台</a>下载的二维码放到<code>source/uploads</code>目录下，如果没有uploads目录就创建一个。</p><p>添加下面的内容到Next主题的<code>_config.yml</code>配置文件中，其中的description内容可以修改</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"># Wechat Subscriber</span><br><span class="line">wechat_subscriber:</span><br><span class="line">  enabled: true</span><br><span class="line">  qcode: &#x2F;uploads&#x2F;wechat-qcode.jpg</span><br><span class="line">  description: 欢迎您扫一扫上面的微信公众号，订阅我的博客！</span><br></pre></td></tr></table></figure><p>最终的效果可以到这篇文章的末尾看到。</p><h3 id="Hexo博客增加自动推荐相关热门文章功能"><a href="#Hexo博客增加自动推荐相关热门文章功能" class="headerlink" title="Hexo博客增加自动推荐相关热门文章功能"></a>Hexo博客增加自动推荐相关热门文章功能</h3><p>这个功能是根据每篇文章的tag来进行推荐的，而且可以推荐别人的文章或者把你博客的文章推荐到别人的博客中。</p><ol><li><code>npm install hexo-recommended-posts --save</code> 安装插件</li><li><code>hexo recommend</code> 来获取推荐列表</li><li>查看<code>source/_data/recommended_posts.json</code> 如果文章对应的数组中有内容就说明成功了。</li><li>通过添加下面的配置到Next主题的<code>_config.yml</code>文件中可以进行一些自定义的设置<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">recommended_posts:</span><br><span class="line">  server: https:&#x2F;&#x2F;api.truelaurel.com #后端推荐服务器地址</span><br><span class="line">  timeoutInMillis: 10000 #服务时长，超过此时长，则使用离线推荐模式</span><br><span class="line">  internalLinks: 3 #内部文章数量</span><br><span class="line">  externalLinks: 1 #外部文章数量</span><br><span class="line">  fixedNumber: false</span><br><span class="line">  autoDisplay: true #自动在文章底部显示推荐文章</span><br><span class="line">  excludePattern: []</span><br><span class="line">  titleHtml: &lt;h1&gt;推荐文章&lt;span style&#x3D;&quot;font-size:0.45em; color:gray&quot;&gt;（由&lt;a href&#x3D;&quot;https:&#x2F;&#x2F;github.com&#x2F;huiwang&#x2F;hexo-recommended-posts&quot;&gt;hexo文章推荐插件&lt;&#x2F;a&gt;驱动）&lt;&#x2F;span&gt;&lt;&#x2F;h1&gt; #自定义标题</span><br></pre></td></tr></table></figure>这个插件的源码在<a href="https://github.com/huiwang/hexo-recommended-posts">这里</a></li></ol><p>同样，如果想看最终的效果可以到这篇文章的末尾。</p><p>文中更详细的说明可以到<a href="http://theme-next.iissnan.com/">Nexo主题官网</a>查看。</p><p>要修改博客的字体或者设置代码高亮的样式也都可以到<a href="http://theme-next.iissnan.com/theme-settings.html">Next主题的官网</a>查看。</p><div><h1>推荐文章<span style="font-size:0.45em; color:gray"></span></h1><ul><li><a href="http://www.iosprogrammer.tech/insert-math-formula-to-hexo/">向hexo博客中插入数学公式</a></li><li><a href="http://www.iosprogrammer.tech/Hexo%E5%9C%A8%E6%96%87%E7%AB%A0%E6%9C%AB%E5%B0%BE%E6%B7%BB%E5%8A%A0%E8%87%AA%E5%AE%9A%E4%B9%89%E5%86%85%E5%AE%B9/">Hexo在文章末尾添加自定义内容</a></li><li><a href="http://www.iosprogrammer.tech/Deploy-Hexo-Aliyun/">部署Hexo到自己的阿里云服务器</a></li></ul></div>]]></content>
      
      
      
        <tags>
            
            <tag> Hexo博客 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>最佳实践：iOS开发在xib/storyboard中自定义view</title>
      <link href="how-to-make-view-get-intrinsic-content-size/"/>
      <url>how-to-make-view-get-intrinsic-content-size/</url>
      
        <content type="html"><![CDATA[<h3 id="从xib加载自定义view视图"><a href="#从xib加载自定义view视图" class="headerlink" title="从xib加载自定义view视图"></a>从xib加载自定义view视图</h3><p>新建项目:</p><img src="../images/xib-view/xib-1.png" style="height:300px"/><p>添加view和xib到项目中：</p><img src="../images/xib-view/xib-4.png" style="height:300px" alt="点击查看大图"/><img src="../images/xib-view/xib-2.png" style="height:300px"/><img src="../images/xib-view/xib-3.png" style="height:300px"/><p>设置xib的大小为freedom，并设置xib的大小为 200x100</p><img src="../images/xib-view/xib-6.png" style="height:300px"/><img src="../images/xib-view/xib-7.png" style="height:300px"/><p><strong>设置xib的 Fils’s Owner 为CustomView，不要设置view的class</strong></p><img src="../images/xib-view/xib-5.png"/><h3 id="xib文件中添加view并设置约束"><a href="#xib文件中添加view并设置约束" class="headerlink" title="xib文件中添加view并设置约束"></a>xib文件中添加view并设置约束</h3><img src="../images/xib-view/xib-8.png" style="height:300px"/><p>设置约束后的xib是这样：</p><img src="../images/xib-view/xib-15.png" style="height:300px"/><h3 id="xib和-m建立链接"><a href="#xib和-m建立链接" class="headerlink" title=".xib和.m建立链接"></a>.xib和.m建立链接</h3><img src="../images/xib-view/xib-13.png"/><h3 id="重写initWithCoder-方法把xib中的view添加进来"><a href="#重写initWithCoder-方法把xib中的view添加进来" class="headerlink" title="重写initWithCoder:方法把xib中的view添加进来"></a>重写<code>initWithCoder:</code>方法把xib中的view添加进来</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">- (instancetype)initWithCoder:(NSCoder *)coder</span><br><span class="line">&#123;</span><br><span class="line">    self &#x3D; [super initWithCoder:coder];</span><br><span class="line">    if (self) &#123;</span><br><span class="line">        &#x2F;&#x2F; 加载xib，注意owner: self</span><br><span class="line">        [[NSBundle mainBundle] loadNibNamed:NSStringFromClass([self class]) owner:self options:nil];</span><br><span class="line">        self.contentView.frame &#x3D; self.bounds;</span><br><span class="line">        [self addSubview:self.contentView];</span><br><span class="line">    &#125;</span><br><span class="line">    return self;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="在Main-storyboard中添加CustomView，并设置约束"><a href="#在Main-storyboard中添加CustomView，并设置约束" class="headerlink" title="在Main.storyboard中添加CustomView，并设置约束"></a>在Main.storyboard中添加CustomView，并设置约束</h3><img src="../images/xib-view/xib-9.png"/><img src="../images/xib-view/xib-10.png"  style="height:300px"/><p>这时候会报错，因为view的约束不足。</p><img src="../images/xib-view/xib-11.png"  style="height:300px"/><h3 id="让UIView像UILabel一样拥有IntrinsicContentSize"><a href="#让UIView像UILabel一样拥有IntrinsicContentSize" class="headerlink" title="让UIView像UILabel一样拥有IntrinsicContentSize"></a>让UIView像UILabel一样拥有IntrinsicContentSize</h3><p>在UIKit中有一些视图具有intrinsicContentSize，比如UILabel、UIButotn、UIImageView等。这类视图可以根据自身的内容确定大小，在设置约束时只需要确定位置（x/y）就可以了。</p><p>但是UIView本身是不具备这个特性的，不过我们可以通过在xib或者storyboard中<strong>设置intrinsicSize来告诉编译器当前的视图是可以确定自身大小的</strong>。</p><img src="../images/xib-view/xib-12.png"  style="height:300px"/><p>这样设置以后约束不足的警告就没有了。</p><img src="../images/xib-view/xib-16.png"  style="height:300px"/><p>最终，view controller中customView的展示就是.xib中的样子了。</p><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>通过这篇文章我们可以学到：</p><ul><li>xib自定义view的方法</li><li>让UIView像UILabel一样拥有IntrinsicContentSize的方法</li><li>xib嵌套使用的方法</li></ul><p><strong>想了解更多内容关注公众号【iOS开发栈】</strong></p><hr><ul><li><a href="http://www.iosprogrammer.tech/WebSocket-And-SocketRocket-Source-Analysis/">WebSocket简介和SocketRocket源码分析</a></li><li><a href="http://www.iosprogrammer.tech/UIStackView-Advanced-Knowledge/">UIStackView的正确使用姿势（最新最全、配视频教程）</a></li><li><a href="http://www.iosprogrammer.tech/Using-Instruments-To-Oprimize-CPU-Performance/">使用Instruments工具测试CPU与常见对CPU占用过高的操作</a></li></ul><hr><div><h1>推荐文章<span style="font-size:0.45em; color:gray"></span></h1><ul><li><a href="http://www.iosprogrammer.tech/What-is-Content-Hugging-Priorities-Content-Compression-Resistance-Priorities/">什么是Content Hugging Priorities/Content Compression Resistance Priorities</a></li><li><a href="http://www.iosprogrammer.tech/UIStackView-Advanced-Knowledge/">UIStackView的正确使用姿势（最新最全、配视频教程）</a></li><li><a href="http://www.iosprogrammer.tech/xib-color-different-with-hard-code/">iOS开发xib和代码设置颜色不同的解决方法及其原理（深度好文）</a></li></ul></div>]]></content>
      
      
      
        <tags>
            
            <tag> iOS </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>向hexo博客中插入数学公式</title>
      <link href="insert-math-formula-to-hexo/"/>
      <url>insert-math-formula-to-hexo/</url>
      
        <content type="html"><![CDATA[<blockquote><p>原生hexo并不支持数学公式，需要安装插件<a href="https://www.mathjax.org/">mathJax</a>。<a href="https://www.mathjax.org/">mathJax</a>是一款运行于浏览器中的开源数学符号渲染引擎，使用 mathJax 可以方便的在浏览器中嵌入数学公式。mathJax 使用网络字体产生高质量的排版，因此可适应各种分辨率，它的显示是基于文本的而非图片，因此显示效果更好。这些公式可以被搜索引擎使用，因此公式里的符号一样可以被搜索引擎检索到。</p></blockquote><h2 id="安装与配置"><a href="#安装与配置" class="headerlink" title="安装与配置"></a>安装与配置</h2><ol><li><code>$ npm install hexo-math --save</code><br>在站点配置文件 _config.yml 中添加：<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">math:</span><br><span class="line">  engine: &#39;mathjax&#39; # or &#39;katex&#39;</span><br><span class="line">  mathjax:</span><br><span class="line">    # src: custom_mathjax_source</span><br><span class="line">    config:</span><br><span class="line">      # MathJax config</span><br></pre></td></tr></table></figure>在 next 主题配置文件中 themes/next-theme/_config.yml 中将 mathJax 设为 true:<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"># MathJax Support</span><br><span class="line">mathjax:</span><br><span class="line">  enable: true</span><br><span class="line">  per_page: false</span><br><span class="line">  cdn: &#x2F;&#x2F;cdn.mathjax.org&#x2F;mathjax&#x2F;latest&#x2F;MathJax.js?config&#x3D;TeX-AMS-MM</span><br></pre></td></tr></table></figure><h2 id="使用"><a href="#使用" class="headerlink" title="使用"></a>使用</h2>公式插入格式<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$数学公式$ 行内 不独占一行</span><br><span class="line">$$数学公式$$ 行间 独占一行</span><br></pre></td></tr></table></figure>例如<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$f(x)&#x3D;ax+b$</span><br></pre></td></tr></table></figure>显示效果为：f(x)=ax+b<br>如果是行间则使用：<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$$f(x)&#x3D;ax+b$$</span><br></pre></td></tr></table></figure>显示效果为：<br>$$f(x)=ax+b$$</li></ol><h3 id="语法格式"><a href="#语法格式" class="headerlink" title="语法格式"></a>语法格式</h3><h4 id="上标与下标"><a href="#上标与下标" class="headerlink" title="上标与下标"></a>上标与下标</h4><p>使用 ^ 表示上标，使用 _ 表示下标，如果上下标的内容多于一个字符，可以使用大括号括起来：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$$f(x) &#x3D; a_1x^n + a_2x^&#123;n-1&#125; + a_3x^&#123;n-2&#125;$$</span><br></pre></td></tr></table></figure><p>显示效果为：<br>$$f(x) = a_1x^n + a_2x^{n-1} + a_3x^{n-2}$$<br>如果左右两边都有上下标可以使用 \sideset 语法：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$$\sideset&#123;^n_k&#125;&#123;^x_y&#125;a$$</span><br></pre></td></tr></table></figure><p>显示效果为：<br>$$\sideset{^n_k}{^x_y}a$$</p><h4 id="括号"><a href="#括号" class="headerlink" title="括号"></a>括号</h4><p>在 markdown 语法中，, $, {, }, _都是有特殊含义的，所以需要加\转义。小括号与方括号可以使用原始的() [] 大括号需要转义\也可以使用\lbrace和 \rbrace</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">\&#123;x*y\&#125;</span><br><span class="line">\lbrace x*y \rbrace</span><br></pre></td></tr></table></figure><p>显示效果为：{x*y}<br>原始符号不会随着公式大小自动缩放，需要使用 \left 和 \right 来实现自动缩放：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$$\left \lbrace \sum_&#123;i&#x3D;0&#125;^n i^3 &#x3D; \frac&#123;(n^2+n)(n+6)&#125;&#123;9&#125; \right \rbrace$$</span><br></pre></td></tr></table></figure><p>效果：$$\left \lbrace \sum_{i=0}^n i^3 = \frac{(n^2+n)(n+6)}{9} \right \rbrace$$<br>不使用\left 和 \right的效果：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$$ \lbrace \sum_&#123;i&#x3D;0&#125;^n i^3 &#x3D; \frac&#123;(n^2+n)(n+6)&#125;&#123;9&#125;  \rbrace$$</span><br></pre></td></tr></table></figure><p>$$ \lbrace \sum_{i=0}^n i^3 = \frac{(n^2+n)(n+6)}{9}  \rbrace$$</p><h4 id="分数与开方"><a href="#分数与开方" class="headerlink" title="分数与开方"></a>分数与开方</h4><p>可以使用\frac 或者 \over 实现分数的显示：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$\frac xy$</span><br><span class="line">$ x+3 \over y+5 $</span><br></pre></td></tr></table></figure><p>分别显示为：$\frac xy$和$ x+3 \over y+5 $<br>开方使用\sqrt:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ \sqrt&#123;x^5&#125; $</span><br><span class="line">$ \sqrt[3]&#123;\frac xy&#125; $</span><br></pre></td></tr></table></figure><p>分别显示为：$ \sqrt{x^5} $和$ \sqrt[3]{\frac xy} $</p><h4 id="求和与积分"><a href="#求和与积分" class="headerlink" title="求和与积分"></a>求和与积分</h4><p>求和使用\sum,可加上下标，积分使用\int可加上下限，双重积分用\iint:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$ \sum_&#123;i&#x3D;0&#125;^n $</span><br><span class="line">$ \int_1^\infty $</span><br><span class="line">$ \iint_1^\infty $</span><br></pre></td></tr></table></figure><p>分别显示为：$ \sum_{i=0}^n $和$ \int_1^\infty $以及$ \iint_1^\infty $</p><h4 id="极限"><a href="#极限" class="headerlink" title="极限"></a>极限</h4><p>极限使用\lim:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ \lim_&#123;x \to 0&#125; $</span><br></pre></td></tr></table></figure><p>显示为：$ \lim_{x \to 0} $</p><h4 id="表格和矩阵"><a href="#表格和矩阵" class="headerlink" title="表格和矩阵"></a>表格和矩阵</h4><p>表格样式lcr表示居中，|加入一条竖线，\hline表示行间横线，列之间用&amp;分隔，行之间用\分隔</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">$$\begin&#123;array&#125;&#123;c|lcr&#125;</span><br><span class="line">n &amp; \text&#123;Left&#125; &amp; \text&#123;Center&#125; &amp; \text&#123;Right&#125; \\\\</span><br><span class="line">\hline</span><br><span class="line">1 &amp; 1.97 &amp; 5 &amp; 12 \\\\</span><br><span class="line">2 &amp; -11 &amp; 19 &amp; -80 \\\\</span><br><span class="line">3 &amp; 70 &amp; 209 &amp; 1+i \\\\</span><br><span class="line">\end&#123;array&#125;$$</span><br></pre></td></tr></table></figure><p>显示效果为：<br>$$\begin{array}{c|lcr}<br>n &amp; \text{Left} &amp; \text{Center} &amp; \text{Right} \\<br>\hline<br>1 &amp; 1.97 &amp; 5 &amp; 12 \\<br>2 &amp; -11 &amp; 19 &amp; -80 \\<br>3 &amp; 70 &amp; 209 &amp; 1+i \\<br>\end{array}$$<br>表格的插入也可以使用以下方式：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">名称|说明</span><br><span class="line">---|---|---</span><br><span class="line">temperature|  室内温度</span><br><span class="line">set temperature|  设定温度</span><br><span class="line">height|  室内高度</span><br></pre></td></tr></table></figure><p>显示效果为：<br>名称|说明<br>—|—|—<br>temperature|  室内温度<br>set temperature|  设定温度<br>height|  室内高度<br>矩阵显示和表格很相似</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">$$\left[</span><br><span class="line">\begin&#123;matrix&#125;</span><br><span class="line">V_A \\\\</span><br><span class="line">V_B \\\\</span><br><span class="line">V_C \\\\</span><br><span class="line">\end&#123;matrix&#125;</span><br><span class="line">\right] &#x3D;</span><br><span class="line">\left[</span><br><span class="line">\begin&#123;matrix&#125;</span><br><span class="line">1 &amp; 0 &amp; L \\\\</span><br><span class="line">-cosψ &amp; sinψ &amp; L \\\\</span><br><span class="line">-cosψ &amp; -sinψ &amp; L</span><br><span class="line">\end&#123;matrix&#125;</span><br><span class="line">\right]</span><br><span class="line">\left[</span><br><span class="line">\begin&#123;matrix&#125;</span><br><span class="line">V_x \\\\</span><br><span class="line">V_y \\\\</span><br><span class="line">W \\\\</span><br><span class="line">\end&#123;matrix&#125;</span><br><span class="line">\right] $$</span><br></pre></td></tr></table></figure><p>显示效果为：<br>$$\left[<br>\begin{matrix}<br>V_A \\<br>V_B \\<br>V_C \\<br>\end{matrix}<br>\right] =<br>\left[<br>\begin{matrix}<br>1 &amp; 0 &amp; L \\<br>-cosψ &amp; sinψ &amp; L \\<br>-cosψ &amp; -sinψ &amp; L<br>\end{matrix}<br>\right]<br>\left[<br>\begin{matrix}<br>V_x \\<br>V_y \\<br>W \\<br>\end{matrix}<br>\right] $$</p><div><h1>推荐文章<span style="font-size:0.45em; color:gray"></span></h1><ul><li><a href="http://www.iosprogrammer.tech/hexo-blog-logo-gzh-recommend/">3个快速提高Hexo博客访问量的方法</a></li><li><a href="http://www.iosprogrammer.tech/Hexo%E5%9C%A8%E6%96%87%E7%AB%A0%E6%9C%AB%E5%B0%BE%E6%B7%BB%E5%8A%A0%E8%87%AA%E5%AE%9A%E4%B9%89%E5%86%85%E5%AE%B9/">Hexo在文章末尾添加自定义内容</a></li><li><a href="http://www.iosprogrammer.tech/Deploy-Hexo-Aliyun/">部署Hexo到自己的阿里云服务器</a></li></ul></div>]]></content>
      
      
      
        <tags>
            
            <tag> Hexo博客 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>一图搞懂Cmake、GCC、Make、Ninja是什么以及他们的关系</title>
      <link href="relation-cmake-gcc-ninja/"/>
      <url>relation-cmake-gcc-ninja/</url>
      
        <content type="html"><![CDATA[<p><img src="../images/cmake-make-ninja-gcc.png"></p><h3 id="命令与规则"><a href="#命令与规则" class="headerlink" title="命令与规则"></a>命令与规则</h3><blockquote><p>图中粉色的内容cmake、make、ninja、gcc都是命令也就是可执行程序<br>黑色内容本质上是文本文件，只不过是根据一定规则编写的<br>文件对应的命令可以解析这些规则并执行相应的命令</p></blockquote><p>比如，cmake程序对应的是CMakeLists.txt文件，CMakeLists.txt的编写是遵循一定的语法规则的，类似于Java、C语言等，但是它更简单，更类似于一种脚本语言。</p><p>当执行cmake程序（或者叫做调用cmake命令）时，cmake会去读取CMakeLists.txt的内容并按照约定的语法规则进行解析，然后cmake会根据CMakeLists.txt中的指示去做一些动作，比如操作文件、调用系统命令等等。</p><p>这就好比厨师做菜，厨师根据菜谱的指示拿着鸡鱼肉蛋和厨具做菜，厨师就相当于cmake程序，而菜谱就是CMakeLists.txt.</p><h3 id="为什么会有这样的设计"><a href="#为什么会有这样的设计" class="headerlink" title="为什么会有这样的设计"></a>为什么会有这样的设计</h3><p>最初要编译C语言需要使用一个<a href="https://zh.wikipedia.org/wiki/GCC">扩增自由Pastel语言编写的编译器</a>，后来为了使C语言具有可移植性并增强编译器的性能和编译速度，<strong>GCC营运而生</strong>。从1987年开始GCC获得了不断的增强，到现在可以编译非常多的语言，并且支持市面上几乎所有的CPU架构。</p><p>随着项目的增加和复杂度的提高以及对编译速度的需求，单独使用GCC逐渐不能满足了。这时候需要一个工具来解放程序员执行GCC命令的工作，**<a href="https://zh.wikipedia.org/zh-hans/Make">make和MakeFile应运而生</a>**。通过按照一定规则编写的makefile文件可以很好的应对大型项目，而且经过一次编写之后就可以通过一条<code>make</code>指令重复使用，简直就是码农的福音。</p><p>但是，经过若干年的发展，make和makefile逐渐变的臃肿，越来越无法满足用户对速度的要求。为了提高项目的编译速度，**<a href="https://ninja-build.org/">ninja出现了</a>**，起初它只是用来编译Google Chrome浏览器，后来由于它卓越的性能被用到了其他项目中。相信有一天ninja也会和make一样被时代抛弃。。。</p><p>make和ninja虽然解决了每次编译都要重新执行GCC的痛苦，可是它们也需要编写自己的文件，而且由于不同计算机指令集的命令不同，makefile和build.ninja文件也要区分CPU架构，这就造成一个跨平台的应用程序进行平台移植的时候要分别编写适用于对应平台的文件。</p><p>为了能够自动生成对应平台文件，**<a href="https://cmake.org/">cmake出现了</a>**。cmake是一个与平台无关的工具，cmake执行通过按照一定规则编写的CMakeLists.txt后，会生成对应平台的makefile或者build.ninja，之后再使用make或者ninja就可以生成对应平台的二进制可执行文件了。</p><p>至此，我们对编译工具家族有了一个自下而上的了解，这也是代码编译过程中用到的工具链。虽然现在开发大多使用IDE，很少接触到这些知识，不过作为了解还是很有意义的。</p><p>也许未来有一天，cmake也会和gcc一样成为背后英雄不为人所知，谁知道呢。。。</p><p><strong>想了解更多内容关注公众号【iOS开发栈】</strong></p><div><h1>推荐文章<span style="font-size:0.45em; color:gray"></span></h1><ul><li><a href="http://www.iosprogrammer.tech/Read-Effective-Objective-C-2-0-2/">读《Effective Objective-C 2.0》（二）</a></li><li><a href="http://www.iosprogrammer.tech/Read-Effective-Objective-C-2-0-1/">读《Effective Objective-C 2.0》（一）</a></li><li><a href="http://www.iosprogrammer.tech/Growth-Hacker-FanBing/">程序员读《增长黑客》</a></li></ul></div>]]></content>
      
      
      
        <tags>
            
            <tag> 其他 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>什么是Content Hugging Priorities/Content Compression Resistance Priorities</title>
      <link href="What-is-Content-Hugging-Priorities-Content-Compression-Resistance-Priorities/"/>
      <url>What-is-Content-Hugging-Priorities-Content-Compression-Resistance-Priorities/</url>
      
        <content type="html"><![CDATA[<p>这两个优先级属性都是用在iOS开发时Auto Layout布局中的。</p><h3 id="Content-Hugging-Priorities"><a href="#Content-Hugging-Priorities" class="headerlink" title="Content Hugging Priorities"></a>Content Hugging Priorities</h3><p><strong>Content Hugging Priorities：在Auto Layout中，当子视图不足以填充满空间时，优先满足此属性值较大的子视图的内容展示，而拉伸属性值较低的子视图。</strong></p><p>假设有这样一种情况，两个水平排列的UILabel中分别显示“斜杠程序员”和“<a href="http://www.iosprogrammer.tech“,给它们加上5个约束,其中2、3、5是水平约束,假设这3个水平约束的值都是10/">www.iosprogrammer.tech“，给它们加上5个约束，其中2、3、5是水平约束，假设这3个水平约束的值都是10</a>.</p><p>现在两个UILabel里面文字内容所占大小加上3个水平约束的值仍然小于（&lt;）父视图的宽度。此时会发现storyboard中有报错，但是我们仍然可以正常运行项目并看到展示结果。<br><img src="../images/hugging-prority-1.png"><br><img src="../images/hugging-prority-2.png"><br><img src="../images/hugging-prority-3.png"></p><p>我们可以看到“<a href="http://www.iosprogrammer.tech“所在label所占的空间变大了.此时设置这个label的content/">www.iosprogrammer.tech“所在label所占的空间变大了。此时设置这个label的Content</a> Hugging Priorities为750。</p><p><img src="../images/hugging-prority-4.png"><br><img src="../images/hugging-prority-5.png"></p><p>“<a href="http://www.iosprogrammer.tech“所在label刚好满足展示内容,而“斜杠程序员”所在label所占空间变大了./">www.iosprogrammer.tech“所在label刚好满足展示内容，而“斜杠程序员”所在label所占空间变大了。</a></p><p>这也就是Content Hugging Priorities的作用，控制当内容不足以填充满空间时，优先满足此属性值较大的子view的内容展示，而拉伸属性值较低的子view。</p><h3 id="Content-Compression-Resistance-Priorities"><a href="#Content-Compression-Resistance-Priorities" class="headerlink" title="Content Compression Resistance Priorities"></a>Content Compression Resistance Priorities</h3><p><strong>Content Compression Resistance Priorities：在Auto Layout中，当子视图所需的内容超出父视图的空间时，优先展示此值较大的子视图，而省略压缩此值较小的子视图。</strong></p><p>假设有这样一种情况，两个水平排列的UILabel中分别显示“斜杠程序员专注于提高编程能力”和“斜杠程序员的官方网站是<a href="http://www.iosprogrammer.tech“,给它们加上5个约束,其中2、3、5是水平约束,假设这3个水平约束的值都是10/">www.iosprogrammer.tech“，给它们加上5个约束，其中2、3、5是水平约束，假设这3个水平约束的值都是10</a>.</p><p>现在两个UILabel里面文字内容所占大小超过了父视图的宽度。此时会发现storyboard中有报错，但是我们仍然可以正常运行项目并看到展示结果。<br><img src="../images/hugging-prority-6.png"><br><img src="../images/hugging-prority-7.png"><br><img src="../images/hugging-prority-8.png"></p><p>第一个Label被压缩了，里面的文字被省略了；第二个label正常展示了出来。此时我们把第一个label的Content Compression Resistance Priorities设置到大于第二个label。</p><p><img src="../images/hugging-prority-9.png"><br><img src="../images/hugging-prority-10.png"></p><p>可以看到第二个label被压缩了，第一个label正常展示了出来。</p><p><strong>Content Compression Resistance Priorities：在Auto Layout中，当子视图所需的内容超出父视图的空间时，优先展示此值较大的子视图，而省略压缩此值较小的子视图。</strong></p><p><a href="https://medium.com/@dineshk1389/content-hugging-and-compression-resistance-in-ios-35a0e8f19118">参考文章</a></p><div><h1>推荐文章<span style="font-size:0.45em; color:gray"></span></h1><ul><li><a href="http://www.iosprogrammer.tech/how-to-make-view-get-intrinsic-content-size/">最佳实践：iOS开发在xib/storyboard中自定义view</a></li><li><a href="http://www.iosprogrammer.tech/UIStackView-Advanced-Knowledge/">UIStackView的正确使用姿势（最新最全、配视频教程）</a></li><li><a href="http://www.iosprogrammer.tech/xib-color-different-with-hard-code/">iOS开发xib和代码设置颜色不同的解决方法及其原理（深度好文）</a></li></ul></div>]]></content>
      
      
      
        <tags>
            
            <tag> iOS </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>UIStackView的正确使用姿势（最新最全、配视频教程）</title>
      <link href="UIStackView-Advanced-Knowledge/"/>
      <url>UIStackView-Advanced-Knowledge/</url>
      
        <content type="html"><![CDATA[<p>UIStackView在iOS9之后开始使用，继承自UIView，用来管理在它内部的views，<text style="color:#1E90FF">但是并不会被渲染出来</text>，经过我在工作中的使用总结，它确实可以很大程度提高界面开发效率，每一个iOS开发者都应该熟练掌握UIStackView的使用。</p><p>本文将分为基础和进阶两部分来讲解UIStackView，因此如果已经一定程度的使用过UIStackView，那么可以直接跳转到进阶部分。</p><h3 id="UIStackView基础入门知识"><a href="#UIStackView基础入门知识" class="headerlink" title="UIStackView基础入门知识"></a>UIStackView基础入门知识</h3><p>UIStackview的主要作用是管理<code>arrangedSubviews</code>数组中的view的布局，管理数组的有三个方法<br>    - addArrangedSubview:<br>    - removeArrangedSubview:<br>    - insertArrangedSubview:atIndex:</p><p>UIStackView中arrangedSubview的布局主要是使用<code>UILayoutConstraintAxis</code> <code>UIStackViewDistribution</code> <code>UIStackViewAlignment</code> <code>spacing</code> 几个属性。</p><ol><li><p><code>UILayoutConstraintAxis</code> - 确定arrangedSubviews的排列方向，分为Horizontal和Vertical</p></li><li><p><code>UIStackViewDistribution</code> - arrangedSubviews<strong>在排列方向</strong>的布局方式</p><ol><li>UIStackViewDistributionFill 把UIStackView的空间填充满，对于有intrinsic content size的UIView（UILabel、UIButton、UIImageView、UIControl）需要通过设置Size Inspector中的<a href="https://www.iosprogrammer.tech/What-is-Content-Hugging-Priorities-Content-Compression-Resistance-Priorities/">Content Hugging Property</a>来决定优先满足哪个view的contrinsicSize，如果property相同则会默认选择第一个。</li><li>UIStackViewDistributionFillEqually arrangedSubviews平分UIStackView 排列方向上除了spacing的空间</li><li>UIStackViewDistributionFillProportionally 按比例分配每个arrangedSubview所占大小，按照每个arrangedSubview的intrinsic content size的比例</li><li>UIStackViewDistributionEqualSpacing 当arrangedSubviews不能填满时，空白区域会平均分配，而不会自动拉伸Hugging Property较低的view；如果arrangedSubviews放不开时，会优先保证<a href="https://www.iosprogrammer.tech/What-is-Content-Hugging-Priorities-Content-Compression-Resistance-Priorities/">compression resistance priority</a>较高的view内容能够完全展示，priority相同时会默认保证第一个view。</li><li>UIStackViewDistributionEqualCentering view中心之间的spacing相等。当spacing值过大，无法满足所有view都能正常展示，会优先保证compression resistance priority较高的view内容能够完全展示，priority相同时会默认保证第一个view。</li></ol></li><li><p>UIStackViewAlignment - arrangedSubviews<strong>垂直于排列方向</strong>的布局方式</p><ol><li>UIStackViewAlignmentFill 完全填充</li><li>UIStackViewAlignmentLeading/UIStackViewAlignmentTop 靠上/右</li><li>UIStackViewAlignmentTrailing/UIStackViewAlignmentBottom 靠下/左</li><li>UIStackViewAlignmentFirstBaseline/UIStackViewAlignmentLastBaseline 文字基线 下/上</li></ol></li><li><p>spacing - arrangedSubview的间距。对于<code>UIStackViewDistributionFillxxx</code>就是准确的距离，对于UIStackViewDistributionEqualSpacing、UIStackViewDistributionEqualCentering 是最小距离，<strong>使用负数view会覆盖</strong></p></li></ol><p>掌握了上面的基础知识后基本就可以上手使用UIStackView了。</p><h3 id="UIStackView进阶知识"><a href="#UIStackView进阶知识" class="headerlink" title="UIStackView进阶知识"></a>UIStackView进阶知识</h3><p>Q1. 在UIStackView中可以对子view使用约束吗？<br>A1. UIStackView是基于约束来确定里面arrangedSubview的布局的，手动给某一个arrangedSubview指定约束时，会优先满足指定的约束，不过因为系统也会根据我们设置的属性添加约束，所以要当心会出现约束冲突。</p><p>Q2. UIStackView.arrangedViews 和 UIStackView.subViews的关系？<br>A2. arragedViews是subViews的子集 </p><ol><li>UIStackView addSubview 并不会添加到arrangedSubviews中；</li><li>当向arrangedSubviews中添加view时会自动添加到subviews中 </li><li>把一个只在subview而不在arrangedview中的view移除时也不会影响到arrangedview </li><li>一个view既在subviews中又在arrangedviews中时，当把它从subviews中移除，也会自动从arragedviews中移除，反之则不然</li></ol><p>Q3. UIStackView设置了背景色为什么显示不出来？<br>A3. UIStackView虽然是UIView的子类，但是它并不会被渲染，所以设置背景色并没有什么显示，但是设置圆角是有作用的。</p><p>Q4. UIStackView怎么设置某一个子view和后面view的距离？<br>A4. 在iOS11之后UIStackView新加了方法可以设置<code>setCustomSpacing:afterView</code></p><iframe src="//player.bilibili.com/player.html?bvid=BV1wz4y1674t&page=1" scrolling="no" border="0" frameborder="no" framespacing="0" allowfullscreen="true" width="100%" height="300px"> </iframe><div><h1>推荐文章<span style="font-size:0.45em; color:gray"></span></h1><ul><li><a href="http://www.iosprogrammer.tech/how-to-make-view-get-intrinsic-content-size/">最佳实践：iOS开发在xib/storyboard中自定义view</a></li><li><a href="http://www.iosprogrammer.tech/What-is-Content-Hugging-Priorities-Content-Compression-Resistance-Priorities/">什么是Content Hugging Priorities/Content Compression Resistance Priorities</a></li><li><a href="http://www.iosprogrammer.tech/xib-color-different-with-hard-code/">iOS开发xib和代码设置颜色不同的解决方法及其原理（深度好文）</a></li></ul></div>]]></content>
      
      
      
        <tags>
            
            <tag> iOS </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>iOS开发xib和代码设置颜色不同的解决方法及其原理（深度好文）</title>
      <link href="xib-color-different-with-hard-code/"/>
      <url>xib-color-different-with-hard-code/</url>
      
        <content type="html"><![CDATA[<p>本文主要包括两部分，其一是解决xib设置颜色有偏差的问题，其二是聊一下颜色的一些基础知识。</p><h2 id="xib和代码设置颜色有偏差的原因"><a href="#xib和代码设置颜色有偏差的原因" class="headerlink" title="xib和代码设置颜色有偏差的原因"></a>xib和代码设置颜色有偏差的原因</h2><p>在开发iOS app的过程中我们都是按照设计同学给出的标注来做的，而UI同学在作图时使用到的工具就会有“<strong>颜色配置文件（Color Profile）</strong>”。（下面有颜色配置文件的说明）<br><img src="../images/ps-color-profile.png" alt="PS中的颜色配置文件"><br>从上图可以看出，ps默认的颜色配置文件是sRGB，因此设计给我们的图都是以sRGB为准的。<br>但是在Xcode的ib相关文件中设置颜色时，默认的颜色配置文件是Generic RGB的。<br><img src="../images/xcode-xib-colors.png" alt="Xcode-colors"><br>因此，如果我们直接按照sRGB标的色值在Generic RGB的配置下进行设置就会出现色差了。<br>通过下面的GIF可以更直观的看到这种差异<br><img src="../images/record.gif"><br>而代码设置颜色时默认是采用的和photoshop一样的sRGB，也是和xib的Generic RGB不相同的，所以代码设置的颜色和UI同学提供的是一样的，而xib中是和他们两个不一样的。</p><h2 id="xib设置颜色和代码有差异的问题解决方案"><a href="#xib设置颜色和代码有差异的问题解决方案" class="headerlink" title="xib设置颜色和代码有差异的问题解决方案"></a>xib设置颜色和代码有差异的问题解决方案</h2><p>解决方案有两种，一种是把sRGB的色值转化成Generic RGB之后再进行设置，另一种是把配置改成sRGB的再进行设置。<br>这里用到的不同颜色配置之间进行转换的工具可以用mac自带的ColorSync Utility</p><center class="half" style="display:flex;margin-left:10%">    <img src="../images/colorsyncutilityicon.png" width="200"/><img src="../images/colorsyncinterface.png" width="300"/></center>## xib和代码设置的颜色有差异的原理分析上面说到了xib默认的颜色配置和ps、代码都是不同的，说到颜色配置（Color Profile）就不得不说颜色模型（Color Model）和颜色空间（Color Space）。众所周知，计算机、摄像机、打印机等数字设备中只能认识0和1（不然它们也不会叫数字设备了🐶），因此为了把自然界中的五颜六色在数字设备中展示出来，**颜色转换成数字的算法（公式）—— 颜色模型** 就出现了。现在被广泛使用的颜色模型有RGB、CMYK、CIELAB等，其中RGB主要用在摄像机、显示器等领域，CMYK主要用在打印机领域，具体内容可以查看[这篇文章](https://www.dpbestflow.org/color/color-space-and-color-profiles)。有了算法，就要有**颜色模型具体的算法实现——颜色空间**。之所以叫空间是因为每一个具体的颜色空间都有一个范围![](../image/../images/v2-374053ce809551b3eeef09046f48b074_1440w.jpg)正如上图所示，颜色空间都是有不同的范围的，而不同范围的颜色空间进行转换的时候就会有损失，也就会造成[色差](https://zhuanlan.zhihu.com/p/72530732)。![](../images/v2-53ebd97b57e169f8b395766d580a1ea9_1440w.jpg)颜色模型可以理解为一个概念、理论，颜色空间是对颜色模型的一次具象描述，但是它还不能被计算机所理解。**颜色配置正是能够直接被数字设备拿来用的具体文件**。在Mac电脑的ColorSync Utility应用中可以看到下面这些颜色配置![](../images/colorsyncprofiles.png)<p>至此，我们把xib和代码设置颜色有偏差的现象彻底解决了，总结一句话就是：</p><blockquote><p>不同的颜色配置之间转换时会造成色差，而代码和xib进行颜色设置时使用了不同的颜色配置文件，才最终导致了同样的色值的最终表现不同。</p></blockquote><div><h1>推荐文章<span style="font-size:0.45em; color:gray"></span></h1><ul><li><a href="http://www.iosprogrammer.tech/how-to-make-view-get-intrinsic-content-size/">最佳实践：iOS开发在xib/storyboard中自定义view</a></li><li><a href="http://www.iosprogrammer.tech/What-is-Content-Hugging-Priorities-Content-Compression-Resistance-Priorities/">什么是Content Hugging Priorities/Content Compression Resistance Priorities</a></li><li><a href="http://www.iosprogrammer.tech/UIStackView-Advanced-Knowledge/">UIStackView的正确使用姿势（最新最全、配视频教程）</a></li></ul></div>]]></content>
      
      
      
        <tags>
            
            <tag> iOS </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Android FFmpeg Cannot find a valid font for the family Sans</title>
      <link href="Android-FFmpeg-Cannot-find-a-valid-font-for-the-family-Sans/"/>
      <url>Android-FFmpeg-Cannot-find-a-valid-font-for-the-family-Sans/</url>
      
        <content type="html"><![CDATA[<p>在Android中使用FFmpeg添加文字水印时出现下面的错误提示：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">[Parsed_drawtext_0 @ 0x70fc22fe00] Cannot find a valid font for the family Sans</span><br><span class="line">[AVFilterGraph @ 0x71031fc980] Error initializing filter &#39;drawtext&#39;</span><br></pre></td></tr></table></figure><p>查看了很多文章，里面都是说要指定fontfill，这个是没有问题的，但是其他文章的例子都是windows上面使用ffmpeg的（FFmpeg相关的文章确实不多，也说明了音视频相关的技术依然并不普及，是非常有门槛的）。<br>最后通过我自己的理解+猜测，再参考其他文章的思路，终于找到了Android上面的解决方案。主要是下面几点：</p><ol><li>使用文字水印时需要指定一个自定义的字体文件</li><li>字体文件需要一个绝对路径</li><li>Android中不能使用项目中app/ 下的路径</li><li>要把自定义字体文件放在res/fonts目录下（在AS 4.1.1中要新建文件夹），然后在程序执行时保存到内部存储目录-/data/user</li></ol><p>下面是具体的步骤：</p><ol><li>我使用的字体是Arial.ttf  可以<a href="http://www.xiazaiziti.com/238949.html">百度</a>自行下载</li><li>新建res/fonts目录，并把字体文件复制进去，注意：字体文件名要改成全小写 也就是arial.ttf，不然Android Studio会编译报错<code>&#39;A&#39; is not a valid file-based resource name character: File-based resource names must contain only lowercase a-z, 0-9, or underscore</code></li><li>在程序运行时把arial.ttf写入到内部存储中<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line">protected void onCreate(Bundle savedInstanceState) &#123;</span><br><span class="line">...</span><br><span class="line">doSaveTTF();</span><br><span class="line">...</span><br><span class="line">&#125;</span><br><span class="line">private void doSaveTTF() &#123;</span><br><span class="line">        File filesDir &#x3D; MainActivity.this.getFilesDir();</span><br><span class="line">        File puhuitiMiniPath &#x3D; new File(filesDir, &quot;arial.ttf&quot;);</span><br><span class="line">        &#x2F;&#x2F;判断该文件存不存在</span><br><span class="line">        if (!puhuitiMiniPath.exists()) &#123;</span><br><span class="line">            &#x2F;&#x2F;如果不存在，开始写入文件</span><br><span class="line">            copyFilesFromRaw(R.font.arial, &quot;arial.ttf&quot;, MainActivity.this.getFilesDir().getAbsolutePath());</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">void copyFilesFromRaw(int id, String fileName, String storagePath)&#123;</span><br><span class="line">        InputStream inputStream &#x3D; MainActivity.this.getResources().openRawResource(id);</span><br><span class="line">        storagePath &#x3D; storagePath + File.separator + fileName;</span><br><span class="line"></span><br><span class="line">        File file &#x3D; new File(storagePath);</span><br><span class="line">        try &#123;</span><br><span class="line">            if (!file.exists()) &#123;</span><br><span class="line">                &#x2F;&#x2F; 1.建立通道对象</span><br><span class="line">                FileOutputStream fos &#x3D; new FileOutputStream(file);</span><br><span class="line">                &#x2F;&#x2F; 2.定义存储空间</span><br><span class="line">                byte[] buffer &#x3D; new byte[inputStream.available()];</span><br><span class="line">                &#x2F;&#x2F; 3.开始读文件</span><br><span class="line">                int lenght &#x3D; 0;</span><br><span class="line">                while ((lenght &#x3D; inputStream.read(buffer)) !&#x3D; -1) &#123;&#x2F;&#x2F; 循环从输入流读取buffer字节</span><br><span class="line">                    &#x2F;&#x2F; 将Buffer中的数据写到outputStream对象中</span><br><span class="line">                    fos.write(buffer, 0, lenght);</span><br><span class="line">                &#125;</span><br><span class="line">                fos.flush();&#x2F;&#x2F; 刷新缓冲区</span><br><span class="line">                &#x2F;&#x2F; 4.关闭流</span><br><span class="line">                fos.close();</span><br><span class="line">                inputStream.close();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; catch (Exception e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>之后在FFmpeg加文字水印的命令中使用自定义字体的绝对路径就可以成功了<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">String drawtext &#x3D; &quot;Ffmpeg -I xxx.mp4 drawtext&#x3D;text&#x3D;&#39;AAAAAA&#39;:fontfile&#x3D;&#39;&#x2F;data&#x2F;user&#x2F;0&#x2F;com.sza.shorvideoassistant&#x2F;files&#x2F;arial.ttf&#39;:fontcolor&#x3D;#ffffff:fontsize&#x3D;33 -y xxx.mp4;</span><br></pre></td></tr></table></figure>我做的demo的最终效果<br><img src="../images/text-water-mark.webp" alt="最终效果"></li></ol><div><h1>推荐文章<span style="font-size:0.45em; color:gray"></span></h1><ul><li><a href="http://www.iosprogrammer.tech/iOS-Pull-Live-Stream/">iOS直播APP的开发——拉流</a></li></ul></div>]]></content>
      
      
      
        <tags>
            
            <tag> 音视频 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Hexo在文章末尾添加自定义内容</title>
      <link href="Hexo%E5%9C%A8%E6%96%87%E7%AB%A0%E6%9C%AB%E5%B0%BE%E6%B7%BB%E5%8A%A0%E8%87%AA%E5%AE%9A%E4%B9%89%E5%86%85%E5%AE%B9/"/>
      <url>Hexo%E5%9C%A8%E6%96%87%E7%AB%A0%E6%9C%AB%E5%B0%BE%E6%B7%BB%E5%8A%A0%E8%87%AA%E5%AE%9A%E4%B9%89%E5%86%85%E5%AE%B9/</url>
      
        <content type="html"><![CDATA[<p>现在我的博客有些流量了，所以想尝试把博客的流量引流到微信公众号（爱编程的大头）。</p><p>很多文章都是说怎么修改Hexo博客的页脚、Hexo博客怎么修改页头，没有找到一篇文章是讲怎么在文章内部加入固定内容的，所以我写下了这篇文章，希望对你有帮助。</p><p>一种方法是在每一篇文章都手动加入一段内容，这就需要把老文章重新编辑一遍，而且今后在些文章的时候都要复制这段内容。</p><p>很显然手动的方式不符合程序员“偷懒”的品质，所以我就尝试$\color{CornflowerBlue}{修改Next主题的layout文件}$。</p><p><strong>具体效果可以看我所有文章的结尾处。</strong></p><p>首先编辑<code>themes/next/layout/_macro/post.swig</code>，在第330行下面添加你要显示的内容<br><img src="../images/post-gzh.jpg" alt="post.swig"></p><p>然后在<code>themes/next/source/css/_common/components/post/post-buttom.styl</code>中对div添加你要的样式<br><img src="../images/post-gzh-style.png"></p><p>这样每一篇文章都会在文章的末尾添加固定的内容了，新建的文章也会有。</p><div><h1>推荐文章<span style="font-size:0.45em; color:gray"></span></h1><ul><li><a href="http://www.iosprogrammer.tech/hexo-blog-logo-gzh-recommend/">3个快速提高Hexo博客访问量的方法</a></li><li><a href="http://www.iosprogrammer.tech/insert-math-formula-to-hexo/">向hexo博客中插入数学公式</a></li><li><a href="http://www.iosprogrammer.tech/Deploy-Hexo-Aliyun/">部署Hexo到自己的阿里云服务器</a></li></ul></div>]]></content>
      
      
      
        <tags>
            
            <tag> Hexo博客 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>部署Hexo到自己的阿里云服务器</title>
      <link href="Deploy-Hexo-Aliyun/"/>
      <url>Deploy-Hexo-Aliyun/</url>
      
        <content type="html"><![CDATA[<p>xxx.github.io在国内访问速度不行，为了增强用户体验，把博客搬到自己的服务器。<br>操作环境：</p><ul><li>本地：Mac</li><li>服务器：阿里云CentOS</li></ul><p>主要步骤：</p><ol><li><p>服务器安装Nginx和Git（具体方法自行百度）</p></li><li><p>服务器创建用户git并设置密码。</p> <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">useradd git</span><br><span class="line">passwd git &#x2F;&#x2F; 设置密码</span><br><span class="line">su git</span><br></pre></td></tr></table></figure></li><li><p>服务器端创建Git空仓库。</p> <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">mkdir ~&#x2F;hexo.git</span><br><span class="line">cd ~&#x2F;hexo.git&#x2F;</span><br><span class="line">git init --bare</span><br></pre></td></tr></table></figure><p> git空仓库可以跟踪git提交信息，但是并不保存源文件。<br> 如果不使用空仓库，客户端是不能提交代码到服务器的。</p></li><li><p>在根目录下创建源码存放目录，并使用Git钩子指定源码存放目录。<br> 如果只是要使用git进行版本控制，这一步是不需要的。<br> 为了能够让网站被访问才需要存放源码。<br> 上一步创建的空仓库中包含一个Hooks文件夹，这个里面存放的是在Git各个阶段会自动触发的脚本。<br> 我们这里需要让Git仓库收到新的提交后自动把代码转移到源码目录。</p> <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">mkdir ~&#x2F;blog</span><br><span class="line">vim ~&#x2F;hexo.git&#x2F;hooks&#x2F;post-receive</span><br><span class="line"></span><br><span class="line">#!&#x2F;bin&#x2F;sh</span><br><span class="line">git --work-tree&#x3D;&#x2F;~&#x2F;hexo --git-dir&#x3D;&#x2F;~&#x2F;hexo.git checkout -f</span><br></pre></td></tr></table></figure></li><li><p>编辑Nginx配置文件</p> <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">server &#123;</span><br><span class="line">    listen       80;</span><br><span class="line">    server_name  【你的域名】;</span><br><span class="line">    root   &#x2F;home&#x2F;git&#x2F;blog;</span><br><span class="line">    index  index.html index.htm;</span><br><span class="line">&#125; </span><br></pre></td></tr></table></figure><p> 重启nginx </p> <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">sudo nginx -t # 检查您想配置文件</span><br><span class="line">sudo nginx -s reload # 重启</span><br></pre></td></tr></table></figure><p> 如果要收录到百度等网站，只能使用80端口。否则你可以指定其他端口。</p></li><li><p>增加hexo目录下_config.yml的deploy内容</p> <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">deploy:</span><br><span class="line">- type: git # 提交到自己服务器</span><br><span class="line">  repo: git@39.100.115.70:&#x2F;home&#x2F;git&#x2F;hexo.git</span><br><span class="line">- type: git # 提交到github.io</span><br><span class="line">  repo: git@github.com:shizhiang&#x2F;shizhiang.github.io.git</span><br><span class="line">- type: baidu_url_submitter</span><br></pre></td></tr></table></figure></li><li><p>部署博客内容</p> <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">hexo clean</span><br><span class="line">hexo g</span><br><span class="line">hexo d</span><br></pre></td></tr></table></figure><p> 这时候你需要输入自己服务器的root用户密码，如果想省略可以在<code>/root/.ssh/authorized_keys</code>加入自己电脑的<code>  ~/.ssh/id_rsa.pub</code></p></li><li><p>遇到的问题</p><ol><li><code>hexo g</code>生成的.html文件都是空的，解决方法是把node的版本将到稳定版。我的是从14降到了12</li><li>怎么让博客在国内和国外访问都很快？<br> 云解析分别解析。<img src="http://image.zanderwb.com/Hexo/%E6%88%AA%E5%B1%8F2020-07-12%20%E4%B8%8A%E5%8D%8811.37.04.png" alt="域名解析"></li></ol></li></ol><div><h1>推荐文章<span style="font-size:0.45em; color:gray"></span></h1><ul><li><a href="http://www.iosprogrammer.tech/hexo-blog-logo-gzh-recommend/">3个快速提高Hexo博客访问量的方法</a></li><li><a href="http://www.iosprogrammer.tech/insert-math-formula-to-hexo/">向hexo博客中插入数学公式</a></li><li><a href="http://www.iosprogrammer.tech/Hexo%E5%9C%A8%E6%96%87%E7%AB%A0%E6%9C%AB%E5%B0%BE%E6%B7%BB%E5%8A%A0%E8%87%AA%E5%AE%9A%E4%B9%89%E5%86%85%E5%AE%B9/">Hexo在文章末尾添加自定义内容</a></li></ul></div>]]></content>
      
      
      
        <tags>
            
            <tag> Hexo博客 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>读《Effective Objective-C 2.0》（二）</title>
      <link href="Read-Effective-Objective-C-2-0-2/"/>
      <url>Read-Effective-Objective-C-2-0-2/</url>
      
        <content type="html"><![CDATA[<h3 id="第13条：用“方法调配技术”调试“黑盒方法”"><a href="#第13条：用“方法调配技术”调试“黑盒方法”" class="headerlink" title="第13条：用“方法调配技术”调试“黑盒方法”"></a>第13条：用“方法调配技术”调试“黑盒方法”</h3><ol><li>在运行期，可以向类中新增或替换选择子所对应的方法实现。</li><li>获取方法实现：<code>Method class_getInstanceMethod(Class aClass, SEL aSelector)</code></li><li>交换方法实现：<code>void method_exchangeImplementation(Method m1, Method m2)</code></li><li>一般来说，只有调试程序的时候才需要在运行期修改方法实现，这种做法不宜滥用。</li></ol><h3 id="第14条：理解“类对象”的用意"><a href="#第14条：理解“类对象”的用意" class="headerlink" title="第14条：理解“类对象”的用意"></a>第14条：理解“类对象”的用意</h3><ol><li>“在运行期检视对象类型”这一操作也叫做“类型信息查询”（内省），这个强大而有用的特性内置于Foundation框架的NSObject协议里，凡是由公共根类（NSObject或NSProxy）继承而来的对象都要遵守此协议。</li><li>每个Objective-C对象实例都是指向某块内存数据的指针。</li><li><code>id</code>类型的定义 <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">typedef struct objc_object &#123;</span><br><span class="line">    Class isa;</span><br><span class="line">&#125; *id;</span><br></pre></td></tr></table></figure> 由此可知，每个对象结构体的首个成员是Class类的变量。该变量定义了对象所属的类，通常称为“is a“指针。</li><li>Class对象的定义 <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">typedef struct objc_class *Class;</span><br><span class="line">struct objc_class &#123;</span><br><span class="line">    Class isa;</span><br><span class="line">    Class super_class;</span><br><span class="line">    const char *name;</span><br><span class="line">    long version;</span><br><span class="line">    long instance_size;</span><br><span class="line">    long info;</span><br><span class="line">    struct objc_ivar_list *ivars;</span><br><span class="line">    struct objc_method_list **methodLists;</span><br><span class="line">    struct objc_cache *cache;</span><br><span class="line">    struct objc_protocol_list *protocols;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure> 此结构存放类的“元数据”（metadata），例如类的实例实现了几个方法，具备多少个实例变量信息。此结构体的首个变量也是isa指针，这说明Class本身也是Objective-C对象。super_class变量定义了本类的超类。除此之外还有变量列表ivars，方法列表methodLists，协议列表protocols等。类对象所属的类型（也就是isa指针所指的类型）是另外一个类，叫做“元类”（metaclass），用来表述类对象本身所具备的元数据。“类方法”就定义在此处，因为这些方法可以理解成<strong>类对象的实例方法</strong>。**每个类仅有一个“类对象”，而每个“类对象”仅有一个与之相关的“元类”。<br> <img src="https://upload-images.jianshu.io/upload_images/1853063-c1521fc9f842523d.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/614/format/webp"><br> super_class指针确立了继承关系，而isa指针描述了实例所属的类。</li><li><code>isMemberOfClass:</code>能够判断出对象是否为某个特定类的实例，而<code>isKindOfClass:</code>则能够判断出对象是否为某类或其派生类的实例。</li><li>类对象是单例，在应用程序的范围内，每个类的Class仅有一个实例。因此可以用 == 来精确判断对象是否为某类实例<code>if ([object class] == [SomeClass class])</code></li></ol><h3 id="第15条：用前缀避免命名空间冲突"><a href="#第15条：用前缀避免命名空间冲突" class="headerlink" title="第15条：用前缀避免命名空间冲突"></a>第15条：用前缀避免命名空间冲突</h3><ol><li>Objective-C没有其他语言那种内置的命名空间机制。</li><li>命名冲突可能导致无法链接，或者令“动态加载器”（dynamic loader）遭遇“重名符号错误”（duplicate symbol error），令应用程序崩溃。</li><li>为所有名称都加上适当前缀来避免命名冲突。即便加了前缀，也难保不出现明明冲突，但是其几率要小很多。</li><li>Apple宣称其保留使用<strong>所有“两字母前缀”</strong>的权利，所以你自己选用的前缀应该是<strong>三字母</strong>的。</li><li>如果要为既有类新增“分类”，那么一定要给“分类”及“分类”中的方法加上前缀。</li><li>在编译好的目标文件中，类的实现文件中所用的纯C函数及全局变量是要算作“顶级符号”的。所以我们应该给这种C函数的名字加上前缀。</li><li>若自己所开发的程序库中用到了第三方库，则应为其中的名称加上前缀。</li></ol><h3 id="第16条：提供“全能初始化方法”"><a href="#第16条：提供“全能初始化方法”" class="headerlink" title="第16条：提供“全能初始化方法”"></a>第16条：提供“全能初始化方法”</h3><ol><li>可为对象提供必要信息以便其能完成工作的初始化方法叫做“全能初始化方法”（designated initializer)。</li><li>其他方法都要调用全能初始化方法。只有在全能初始化方法中，才会存储内部数据。</li><li>如果子类的全能初始化方法与超类方法的名称不同，那么总应覆写超类的全能初始化方法。</li><li>每个子类的全能初始化方法都应该调用其超类的对应方法，应该先调用超类的相关方法，然后再执行与本类有关的任务。</li></ol><h3 id="第17条：实现description方法"><a href="#第17条：实现description方法" class="headerlink" title="第17条：实现description方法"></a>第17条：实现description方法</h3><ol><li> <code>debugDescription</code>方法是开发者在调试器中以控制台命令打印对象时才调用的。</li></ol><h3 id="第18条：尽量使用不可变对象"><a href="#第18条：尽量使用不可变对象" class="headerlink" title="第18条：尽量使用不可变对象"></a>第18条：尽量使用不可变对象</h3><ol><li>尽量把对外公布出来的属性设置为只读，而且只在确有必要时才将属性对外公布</li><li>使用KVC可以绕过类所提供的API，来设置只读属性的值</li><li>用类型查询功能查出属性所对应的实例变量在内存中的布局中的偏移量，以此来人为设置这个实例变量的值。</li><li>不要把可变的collection作为属性公开，而应提供相关方法，以此修改对象中的可变collection。</li></ol><h3 id="第19条：使用清晰而协调的命名方式"><a href="#第19条：使用清晰而协调的命名方式" class="headerlink" title="第19条：使用清晰而协调的命名方式"></a>第19条：使用清晰而协调的命名方式</h3><ol><li>不要吝于使用长方法名。然而方法名也不能长的太过分了。</li><li>应该为类与协议的名称加上前缀，以避免命名空间的冲突，而且应该像给方法起名时那样把词句组织好，使其从左至右读起来较为通顺。</li><li>命名方式应该协调一致。如果要从其他框架中继承子类，那么务必遵循其命名惯例。比如要从<code>UIView</code>类中继承自定义的子类，那么类名末尾的词必须是View。</li><li>若要创建自定义的委托协议，则其名称中应该包含委托方的名称，后面再跟上Delegate一词。</li></ol><h3 id="第20条：为私有方法名加前缀"><a href="#第20条：为私有方法名加前缀" class="headerlink" title="第20条：为私有方法名加前缀"></a>第20条：为私有方法名加前缀</h3><ol><li>给私有方法加前缀，这样可以很容易的将其同公共方法区分开。</li><li>不要单用一个下划线做私有方法的前缀，因为这种方法是预留给苹果公司用的。</li></ol><h3 id="第21条：理解Objective-C错误模型"><a href="#第21条：理解Objective-C错误模型" class="headerlink" title="第21条：理解Objective-C错误模型"></a>第21条：理解Objective-C错误模型</h3><ol><li>只在极其罕见的情况下抛出异常，异常抛出以后，无须考虑恢复问题，而且应用程序此时也应该退出。</li><li>不那么严重的错误出现时，令方法返回nil/0，或者使用<code>NSError</code>，以表明有错误发生。</li><li><code>NSError</code>的第一种常见用法是通过委托协议来传递此错误。<code>- (void)connection:(NSURLConnection *)connection didFailWithError:(NSError *)error</code></li><li><code>NSError</code>的另一种常见用法是：经由方法的“输出参数”返回给调用者。<code>- (BOOL)doSometion:(NSError **)error</code>。</li><li>使用ARC时，编译器会把方法签名中的<code>NSError **</code>转换成<code>NSError *__autoreleasing*</code>，也就是说，指针所指的对象会在方法执行完毕后自动释放。 <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">- (BOOL)doSomething:(NSError **)error &#123;</span><br><span class="line">    &#x2F;&#x2F; Do something that may cause an error</span><br><span class="line">    if ( &#x2F;* there was an error *&#x2F;) &#123;</span><br><span class="line">        if (error) &#123;</span><br><span class="line">            &#x2F;&#x2F; Pass the &#39;error&#39; through the out-parameter</span><br><span class="line">            *error &#x3D; [NSError errorWithDomain:domain code:code userInfo:userInfo];</span><br><span class="line">        &#125;</span><br><span class="line">        return NO; &#x2F;&#x2F; Indicate failure</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">        return YES; &#x2F;&#x2F; Indicate success</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="第22条：理解NSCopying协议"><a href="#第22条：理解NSCopying协议" class="headerlink" title="第22条：理解NSCopying协议"></a>第22条：理解NSCopying协议</h3></li><li>NSCopying协议：<code>- (id)copyWithZone:(NSZone *)zone</code></li><li>以前开发程序时，会据此把内存分成不同的“区”，而对象会创建在某个区里面。现在不用了，每个程序只有一个区：“默认区”。所以说，尽管必须实现这个方法，但是你不必担心其中的zone参数。</li><li>NSMutableCopying协议：<code>- (id)mutableCopyWithZone:(NSZone *)zone</code></li><li>对于不可变的<code>NSArray</code>与可变的<code>NSMutableArray</code>来说，下列关系总是成立的： <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">- [NSMutableArray copy] &#x3D;&gt; NSArray</span><br><span class="line">- [NSArray mutableCopy] &#x3D;&gt; NSMutableArray</span><br></pre></td></tr></table></figure></li><li>深拷贝：在拷贝对象自身时，将其底层数据也一并复制过去。</li><li>Foundation框架中的所有collection类默认情况下都执行浅拷贝，即只拷贝容器对象自身，而不复制其中的数据。</li></ol><div><h1>推荐文章<span style="font-size:0.45em; color:gray"></span></h1><ul><li><a href="http://www.iosprogrammer.tech/relation-cmake-gcc-ninja/">一图搞懂Cmake、GCC、Make、Ninja是什么以及他们的关系</a></li><li><a href="http://www.iosprogrammer.tech/Read-Effective-Objective-C-2-0-1/">读《Effective Objective-C 2.0》（一）</a></li><li><a href="http://www.iosprogrammer.tech/Growth-Hacker-FanBing/">程序员读《增长黑客》</a></li></ul></div>]]></content>
      
      
      
        <tags>
            
            <tag> 其他 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>读《Effective Objective-C 2.0》（一）</title>
      <link href="Read-Effective-Objective-C-2-0-1/"/>
      <url>Read-Effective-Objective-C-2-0-1/</url>
      
        <content type="html"><![CDATA[<h3 id="第1条：了解Objective-C语言的起源"><a href="#第1条：了解Objective-C语言的起源" class="headerlink" title="第1条：了解Objective-C语言的起源"></a>第1条：了解Objective-C语言的起源</h3><ol><li>OC使用“消息结构”而非“函数调用”</li><li>使用消息结构的语言，其运行时所应执行的代码由运行环境来决定；而使用函数调用的语言，则由编译器决定。</li><li>对象所占内存总是分配在“堆空间”中，而绝不会分配在“栈”上。</li><li>分配在堆中的内存必须直接管理（由程序员管理），而分配在栈上的用于保存变量的内存则会在其栈针弹出时自动清理。</li></ol><h3 id="第2条：-在类的头文件中尽量少引入其他头文件"><a href="#第2条：-在类的头文件中尽量少引入其他头文件" class="headerlink" title="第2条： 在类的头文件中尽量少引入其他头文件"></a>第2条： 在类的头文件中尽量少引入其他头文件</h3><ol><li>将引入头文件的时机尽量延后，只在确有需要时才引入，这样就可以减少类的使用者所需引入的头文件数量。</li><li>如果要声明你写的类遵从某个协议，那么该协议必须有完整定义，且不能使用向前声明。</li><li>最好是把协议单独放在一个头文件中。</li><li>委托协议不用单独写一个头文件。</li></ol><h3 id="第3条：多用字面量语法，少用与之等价的方法"><a href="#第3条：多用字面量语法，少用与之等价的方法" class="headerlink" title="第3条：多用字面量语法，少用与之等价的方法"></a>第3条：多用字面量语法，少用与之等价的方法</h3><ol><li>用字面量语法创建数组时要注意，若数组元素对象中有nil，则会抛出异常。</li><li>用字面量语法创建字典时，如果有值为nil，则会抛出异常。</li></ol><h3 id="第4条：多用类型常量，少用-define预处理指令"><a href="#第4条：多用类型常量，少用-define预处理指令" class="headerlink" title="第4条：多用类型常量，少用#define预处理指令"></a>第4条：多用类型常量，少用<code>#define</code>预处理指令</h3><ol><li>若常量局限于某个“实现文件”之内，则在前面加字母<code>k</code>；若常量在类之外可见，则通常以类名为前缀。</li><li><code>const</code>表示变量不可变；<code>static</code>表示该变量仅在定义此变量的编译单元中可见。</li><li>如果一个变量既声明为<code>static</code>，又声明为<code>const</code>，那么编译器根本不会创建符号，而是会像<code>#define</code>预处理指令一样，把所有遇到的变量都替换为常值。</li></ol><h3 id="第5条：用枚举表示状态、选项、状态码"><a href="#第5条：用枚举表示状态、选项、状态码" class="headerlink" title="第5条：用枚举表示状态、选项、状态码"></a>第5条：用枚举表示状态、选项、状态码</h3><ol><li>凡是需要以按位或操作来组合的枚举都应该使用NS_OPTIONS定义。若是枚举不需要互相组合，则应使用NS_ENUM来定义。</li></ol><h3 id="第6条：理解“属性”这一概念"><a href="#第6条：理解“属性”这一概念" class="headerlink" title="第6条：理解“属性”这一概念"></a>第6条：理解“属性”这一概念</h3><ol><li>如果代码使用了编译期计算出来的偏移量，那么在修改类定义之后必须重新编译，否则就会出错。</li><li>OC把实例变量当作一种存储偏移量所用的“特殊变量”，交由“类对象”保管。偏移量会在运行期查找，如果类的定义变了，那么存储的偏移量也就变了。这就是<strong>应用程序二进制接口（ABI）</strong>。</li><li>使用点语法和直接调用存取方法之间没有丝毫差别。</li><li><code>weak</code>在属性所指的对象遭到摧毁时，属性值也会清空。<code>unsafe_unretained</code>当目标对象遭到摧毁时，属性值不会自动清空。</li><li><code>automic</code>特质的获取方法会通过锁定机制来确保其原子操作的原子性。如果两个线程读写同一属性，那么不论何时，总能看到有效的属性值。</li><li>iOS开发中，所有属性都声明为<code>nonatomic</code>的原因是，在iOS中使用同步锁的开销较大，这回带来性能问题。一般情况下并不要求属性必须是“原子的”，因为这并不能保证“线程安全”。例如，一个线程在连续多次读取某属性值的过程中有别的线程在同时改写该值，那么即便将属性声明为<code>atomic</code>，也还是会读到不通的属性值。</li></ol><h3 id="第7条：在对象内部尽量直接访问实例变量"><a href="#第7条：在对象内部尽量直接访问实例变量" class="headerlink" title="第7条：在对象内部尽量直接访问实例变量"></a>第7条：在对象内部尽量直接访问实例变量</h3><ol><li>建议：读取实例变量时采取直接访问的形式，而在设置实例变量的时候通过属性来做。</li><li>由于不经过OC的“方法派发”步骤，所以直接访问实例变量的速度当然比较快。这种情况下，编译器生成的代码会直接访问保存对象实例变量的那块内存。</li><li>直接访问实例变量时，不会调用其“设置方法”，这就饶过了为相关属性所定义的“内存管理语义”。</li><li>直接访问实例变量，不会触发”键值观察”通知。</li><li>在初始化方法中总是应该直接访问实例变量，因为子类可能“覆写”设置方法。</li><li>如果使用了“惰性初始化”技术，那么必须通过存取方法来访问属性。</li></ol><h3 id="第8条：理解“对象等同性“这一概念"><a href="#第8条：理解“对象等同性“这一概念" class="headerlink" title="第8条：理解“对象等同性“这一概念"></a>第8条：理解“对象等同性“这一概念</h3><ol><li><code>==</code>比较的是两个指针本身，而不是其所指的对象。</li><li>在OC中应该使用<code>isEqual:</code>来判断两个对象的等同性。</li><li>如果<code>isEqual:</code>方法判定两个对象相等，那么其<code>hash</code>方法也必须返回同一个值。反之，则不一定成立。</li><li>编写<code>hash</code>方法时，应该用当前的对象做做实验，以便在减少碰撞频度与降低运算复杂度之间取舍。</li><li><code>NSArray</code>等同性判定：先看两个数组所包含的对象个数是否相同，若相同，则在每个对应位置的两个对象上调用其“isEqual:”方法。如果对应位置上的对象均相等，那么这两个数组就相等，这叫做“深度等同性判定”。</li><li>如果把某对象放入set之后又修改其内容，那么后面的行为将很难预料。</li></ol><h3 id="第9条：以“类族模式”隐藏实现细节"><a href="#第9条：以“类族模式”隐藏实现细节" class="headerlink" title="第9条：以“类族模式”隐藏实现细节"></a>第9条：以“类族模式”隐藏实现细节</h3><ol><li>如果对象所属的类位于某个类族中，那么在查询其类信息时要注意。</li><li>使用<code>isKindOfClass:</code>来判断类族信息。</li><li><code>NSArray</code>本身只不过是包在其他隐藏对象外面的壳，它仅仅定义了所有数组都需具备的一些接口。</li></ol><h3 id="第10条：在既有类中使用关联对象存放自定义数据"><a href="#第10条：在既有类中使用关联对象存放自定义数据" class="headerlink" title="第10条：在既有类中使用关联对象存放自定义数据"></a>第10条：在既有类中使用关联对象存放自定义数据</h3><ol><li>关联对象和<code>NSDictionary</code>的区别：设置关联对象时用到的键是个“不透明的指针”（opaque pointer）。如果在两个键上调用“isEqual:”方法的返回值是YES，那么NSDictionary就认为二者相等；然而在设置关联对象值时，若想令两个键匹配到同一个值，则二者必须是完全相同的指针才行。鉴于此，在设置关联对象值时，通常使用静态全局变量做键。</li><li>只有在其他做法不可行时才应选用关联对象，因为这种做法通常会引入难于查找的bug。</li></ol><h3 id="第11条：理解objc-msgSend的作用"><a href="#第11条：理解objc-msgSend的作用" class="headerlink" title="第11条：理解objc_msgSend的作用"></a>第11条：理解objc_msgSend的作用</h3><ol><li>在底层，所有方法都是普通的C语言函数，然而对象收到消息之后，究竟该调用哪个方法则完全于运行期决定，甚至可以在程序运行时改变，这些特性使得OC成为一门真正的动态语言。</li><li><code>void objc_msgSend(id self, SEL cmd, ...)</code>是一个参数可变的函数。第一个参数代表接受者，第二个参数代表选择子。</li><li><code>objc_msgSend</code>函数会根据接受者与选择子的类型来调用适当的方法。为了实现此操作，该方法需要在接受者所属的类中搜索其“方法列表”，如果能找到与选择子名称相符的方法，就跳至其实现代码。若是找不到，那就沿着继承体系继续向上查找，等找到合适的方法之后再跳转。如果最终还是找不到相符的方法，那就执行“消息转发”操作。</li><li><code>objc_msgSend</code>会将匹配结果缓存在“快速映射表”里面，每个类都有这样一块缓存，若是稍后还向该类发送与选择子相同的消息，那么执行起来就很快了。</li><li>每个类都有一张表格，其中的指针都会指向这种函数，而选择子的名称则是查表时所用的“键”。<code>objc_msgSend</code>等函数正是通过这张表格来寻找应该执行的方法并跳转至其实现的。</li><li>如果某函数的最后一项操作是调用另外一个函数，那么就可以运用“尾调用优化”技术。编译器会生成跳转至另一函数所需的指令码，而且不会向调用堆栈中推入新的“栈针”。只有当某函数的最后一个操作仅仅是调用其他函数而不会将其返回值另作他用时，才能执行“尾调用优化”。</li></ol><h3 id="第12条：理解消息转发机制"><a href="#第12条：理解消息转发机制" class="headerlink" title="第12条：理解消息转发机制"></a>第12条：理解消息转发机制</h3><ol><li>消息转发的两个阶段：第一阶段先征询接收者，所属的类，看其是否能动态添加方法，以处理当前这个“未知选择子”，这叫做“动态方法解析”（dynamic method resolution）。第二阶段涉及“完整的消息转发机制”。</li><li>如果运行期系统已经把第一阶段执行完了，那么接收者自己就无法再以动态新增方法的手段来响应包含该选择子的消息了。此时，运行期系统会请求接收者以其他手段来处理与消息相关的方法调用。首先，请接收者看看有没有其他对象能处理这条消息。若有，则运行期系统会把消息转发给那个对象，于是消息转发过程结束，一切如常。若没有“备援的接收者”，则启动完整的消息转发机制，运行期系统会把与消息有关的全部细节都封装到<code>NSInvocation</code>对象中，再给接收者最后一次机会，令其设法解决当前还未处理的这条消息。<h4 id="动态解析"><a href="#动态解析" class="headerlink" title="动态解析"></a>动态解析</h4></li><li>动态方法解析：<code>+ (BOOL)resolveInstanceMethod:(SEL)selector</code>或<code>+ (BOOL)resolveClassMethod:(SEL)selector</code>。</li><li>该方法的参数就是那个未知的选择子，其返回值表示这个类是否能新增一个实例方法用以处理此选择子。</li><li><strong>使用这种方法的前提是：相关方法的实现代码已经写好。</strong><h4 id="备援接收者"><a href="#备援接收者" class="headerlink" title="备援接收者"></a>备援接收者</h4></li><li><code>- (id)forwardingTargetForSelector:(SEL)selector</code>。使用此方案可以模拟多重继承的某些特性。</li><li>我们无法操作经由这一步所转发的消息。若是想在发送给备援接收者之前修改消息内容，那就得通过完整的消息转发机制了。<h4 id="完整的消息转发"><a href="#完整的消息转发" class="headerlink" title="完整的消息转发"></a>完整的消息转发</h4></li><li><code>- (void)forwardInvocation:(NSInvocation *)invocation</code>。</li><li>在触发消息前，先以某种方式改变消息内容，比如追加另外一个参数，或者改变选择子。</li><li>消息转发流程图<br><img src="https://upload-images.jianshu.io/upload_images/424855-83a396fca4f6c206.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="msg_forward.png"></li><li>接收者在每一步中均有机会处理消息。步骤越往后，处理消息的代价就越大。最好能在第一步就处理完，这样的话，运行期系统就可以将此方法缓存起来。</li></ol><div><h1>推荐文章<span style="font-size:0.45em; color:gray"></span></h1><ul><li><a href="http://www.iosprogrammer.tech/relation-cmake-gcc-ninja/">一图搞懂Cmake、GCC、Make、Ninja是什么以及他们的关系</a></li><li><a href="http://www.iosprogrammer.tech/Read-Effective-Objective-C-2-0-2/">读《Effective Objective-C 2.0》（二）</a></li><li><a href="http://www.iosprogrammer.tech/Growth-Hacker-FanBing/">程序员读《增长黑客》</a></li></ul></div>]]></content>
      
      
      
        <tags>
            
            <tag> 其他 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>OC编程基础</title>
      <link href="Programming-With-ObjC/"/>
      <url>Programming-With-ObjC/</url>
      
        <content type="html"><![CDATA[<ul><li><code>+ (id)alloc</code>方法返回类型是<code>id</code>。这是Objective-C中的一个特殊的关键字，意味着“某种对象”。它是一个指向一个对象的指针（NSObject *），但它的特殊之处在于它不使用星号。</li><li><code>alloc</code>方法的另一个重要任务是通过把对象属性设置为0来清理为对象属性申请的内存。这避免了以前存储的包含垃圾内存的常见问题，但不足以完全初始化对象</li><li><code>- (id)init</code>方法也返回<code>id</code>。该方法被类用来确保它的属性在创建时具有合适的初始值。</li><li>创建对象时一定要把<code>alloc</code>嵌套在<code>init</code>中，就像<code>NSObject *newObject = [[NSObject alloc] init];</code>。因为<code>init</code>的返回对象可能和<code>alloc</code>返回的不相同</li><li><code>==</code>比较的是两个不同的指针是否指向相同的对象</li><li><code>isEqual:</code>是比较两个对象是否表示相同的数据</li><li>声明标量的时候指明一个初始值，<code>int number = 10;</code>，否则标量的初始值会包含之前栈内的垃圾内容</li><li>对象指针不需要设置初始值，因为会默认设置为nil。</li><li>nil是安全的，给nil发消息什么都不会发生。</li><li>实例变量的内存在对象首次创建时分配，并且当对象解除分配时释放。</li><li><code>@synthesize firstName;</code>的实例变量名称是<code>firstName</code>而不是<code>_firstName</code>。</li><li>你应该总是在initialization method中直接访问instance variable，因为在设置属性时，对象的其他部分可能还没有完全初始化。即时你确定没有提供自定义的访问器方法，并且你自己的类中没有任何副作用，但是你没办法保证将来的子类不会重写该方法。</li><li>当你要子类化一个带有多个<code>init</code>方法的类时，要么通过继承父类的指定初始化器来执行自己的初始化，要么加入自己的其他初始化器。无论哪种，你都应该在做自己的初始化前，调用父类的指定初始化器，来代替<code>[super init]</code>。</li><li>如果为一个readwrite的property实现了getter和setter，或者为readonly的property实现了getter，那么编译器就不会自动合成成员变量，如果需要成员变量，可以通过<code>@synthesize property = _property</code>来手动获取。</li><li>property默认是atomic。</li><li>atomic的属性要么同时自定义setter和getter，要么都由系统合成，如果只自定义一个会报编译器警告。</li><li><strong>Property atomicity is not synonymous with an object’s thread safety.</strong></li><li>__unsafe_unretained和weak类似都不会保持对象存活，但是__unsafe_unretained在目标对象释放后不会把它设置成nil。这就意味着被已释放对象占用的那块内存现在是一个悬挂指针，如果给这个悬挂指针发送消息会崩溃。</li><li>class extension中声明的一个readwrite的属性，会在这个类的所有对象中生成setter方法，虽然不能直接使用点语法或调用setxxx:，但是可以使用<code>performSelect...</code>或<code>objc_msgSend...</code>来调用。即使这个属性在类的public接口中是readonly的。</li><li>编译器不会自动合成采用的协议中声明的属性。</li><li>如果是跨api传递值，比如方法或函数中的参数，则最好是使用跨平台的类型（NSInteger/CGFloat…)；对于局部变量，例如循环中的计数器，则可以使用基本C类型（int/float…）</li><li>collection并不是以某种方式维护每个对象的单独副本，而是使用强引用来跟踪其内容。这意味着，<strong>只要colletion没有被销毁，它里面的任何对象都将保持活动状态</strong></li><li>使用<code>arrayWithObjects:</code>和<code>initWithObjects:</code>创建数组时，最后要带上<code>nil</code>。</li><li>使用字面量语法创建数组时，不能包含<code>nil</code>，可以使用<code>NSNull</code>来代替<code>nil</code>。</li><li><code>NSArray</code>是有序的collection，会包含重复元素；<code>NSSet</code>是无序的collection，不包含重复元素。</li><li>不要在for循环里修改collection</li><li>block会捕获上下文</li><li>在block捕获上下文之后再修改上下文的内容不会改变block捕获的值。如果被捕获的变量使用<code>__block</code>修饰，则会被修改。</li></ul><div><h1>推荐文章<span style="font-size:0.45em; color:gray"></span></h1><ul><li><a href="http://www.iosprogrammer.tech/how-to-make-view-get-intrinsic-content-size/">最佳实践：iOS开发在xib/storyboard中自定义view</a></li><li><a href="http://www.iosprogrammer.tech/What-is-Content-Hugging-Priorities-Content-Compression-Resistance-Priorities/">什么是Content Hugging Priorities/Content Compression Resistance Priorities</a></li><li><a href="http://www.iosprogrammer.tech/UIStackView-Advanced-Knowledge/">UIStackView的正确使用姿势（最新最全、配视频教程）</a></li></ul></div>]]></content>
      
      
      
        <tags>
            
            <tag> iOS </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>KVC/KVO 总结</title>
      <link href="KVC-KVO/"/>
      <url>KVC-KVO/</url>
      
        <content type="html"><![CDATA[<h1 id="KVC"><a href="#KVC" class="headerlink" title="KVC"></a>KVC</h1><h2 id="Key-Value-Coding基本原则"><a href="#Key-Value-Coding基本原则" class="headerlink" title="Key-Value Coding基本原则"></a>Key-Value Coding基本原则</h2><h3 id="访问对象属性"><a href="#访问对象属性" class="headerlink" title="访问对象属性"></a>访问对象属性</h3><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">@interface</span> <span class="title">BankAccount</span>: <span class="title">NSobject</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">@property</span> (<span class="keyword">nonatomic</span>) <span class="built_in">NSNumber</span> *currentBalance; <span class="comment">// An attribute</span></span><br><span class="line"><span class="keyword">@property</span> (<span class="keyword">nonatomic</span>) Person *owner; <span class="comment">// A to-one relation</span></span><br><span class="line"><span class="keyword">@property</span> (<span class="keyword">nonatomic</span>) <span class="built_in">NSArray</span> &lt;Transaction *&gt;*transactions; <span class="comment">// A to-many relation</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">@end</span></span><br></pre></td></tr></table></figure><p><code>currentBalance</code>/<code>owner</code>/<code>transactions</code>都是<code>BankAccount</code>的属性。<code>owner</code>属性是一个对象，和<code>BankAccount</code>构成一对一的关系，owner对象中的属性改变后并不会影响到owner本身。</p><p>为了保持封装，对象通常为其接口上的属性提供访问器方法（accessor methods）。在使用访问器方法时必须在编译之前将属性名称写入代码中。访问器方法的名称成为使用它的代码的静态部分。例如：<br><code>[myAccount setCurrentBalance:@(100.0)];</code><br>这样缺乏灵活性，KVC提供了使用字符串标识符访问对象属性的更通用的机制。</p><h4 id="使用key和key-path-标识对象的属性"><a href="#使用key和key-path-标识对象的属性" class="headerlink" title="使用key和key path 标识对象的属性"></a>使用key和key path 标识对象的属性</h4><p>key: 标识特定属性的字符串。通常表示属性的key是代码中显示的属性本身的名称。<br>key必须使用ASCII编码，可能不包含空格，并且通常是以小写字母开头（URL除外）。<br>上面的赋值过程使用KVC表示:<br><code>[myAccount setValue:@(100.0) forKey:@&quot;currentBalance&quot;];</code></p><p>key path: 用来指定要遍历的对象属性序列的一串使用“.”分隔的key。序列中的第一个键的属性是相对于接受者的，并且每个后续键是相对于前一个属性的值的。当需要使用一个方法来向下逐级获取对象层次结构时，key path特别有用。<br>例如，<code>owner.address.street</code>应用于银行账户实例的key path是指存储在银行账户所有者地址中的<code>street</code>字符串的值。</p><h4 id="使用key获取属性值"><a href="#使用key获取属性值" class="headerlink" title="使用key获取属性值"></a>使用key获取属性值</h4><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line">- (<span class="keyword">void</span>)getAttributeValuesUsingKeys &#123;</span><br><span class="line">    Account *myAccount = [[Account alloc] init];</span><br><span class="line">    myAccount.currBalance = @<span class="number">100</span>;</span><br><span class="line">    </span><br><span class="line">    Person *owner = [[Person alloc] init];</span><br><span class="line">    Address *address = [[Address alloc] init];</span><br><span class="line">    address.street = <span class="string">@&quot;第三大道&quot;</span>;</span><br><span class="line">    owner.address = address;</span><br><span class="line">    myAccount.owner = owner;</span><br><span class="line">    </span><br><span class="line">    Transaction *t1 = [[Transaction alloc] init];</span><br><span class="line">    Person *p1 = [[Person alloc] init];</span><br><span class="line">    p1.name = <span class="string">@&quot;p1&quot;</span>;</span><br><span class="line">    t1.payee = p1;</span><br><span class="line">    </span><br><span class="line">    Transaction *t2 = [[Transaction alloc] init];</span><br><span class="line">    Person *p2 = [[Person alloc] init];</span><br><span class="line">    p2.name = <span class="string">@&quot;p2&quot;</span>;</span><br><span class="line">    t2.payee = p2;</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">NSArray</span> *ts = @[t1, t2];</span><br><span class="line">    myAccount.transactions = ts;</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">NSNumber</span> *currBalance = [myAccount valueForKey:<span class="string">@&quot;currBalance&quot;</span>];</span><br><span class="line">    <span class="built_in">NSLog</span>(<span class="string">@&quot;currBalance = %@&quot;</span>, currBalance); <span class="comment">// currBalance = 100</span></span><br><span class="line">    </span><br><span class="line">    <span class="built_in">NSString</span> *street = [myAccount valueForKeyPath:<span class="string">@&quot;owner.address.street&quot;</span>];</span><br><span class="line">    <span class="built_in">NSLog</span>(<span class="string">@&quot;street = %@&quot;</span>, street); <span class="comment">// street = 第三大道</span></span><br><span class="line">    </span><br><span class="line">    <span class="built_in">NSDictionary</span> *values = [myAccount dictionaryWithValuesForKeys:@[<span class="string">@&quot;currBalance&quot;</span>, <span class="string">@&quot;owner&quot;</span>]];</span><br><span class="line">    <span class="built_in">NSLog</span>(<span class="string">@&quot;values = %@&quot;</span>, values); <span class="comment">// values = &#123;currBalance = 100; owner = &quot;&lt;Person: 0x60000179af40&gt;&quot;;&#125;</span></span><br><span class="line">    </span><br><span class="line">    <span class="built_in">NSArray</span> *payees = [myAccount valueForKeyPath:<span class="string">@&quot;transactions.payee.name&quot;</span>];</span><br><span class="line">    <span class="built_in">NSLog</span>(<span class="string">@&quot;payees = %@&quot;</span>, payees); <span class="comment">// payees = (p1, p2)</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">// Terminating app due to uncaught exception &#x27;NSUnknownKeyException&#x27;, reason: &#x27;[&lt;Account 0x600002685ee0&gt; valueForUndefinedKey:]&#x27;</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">//    [myAccount valueForKey:@&quot;owner.address.street&quot;];</span></span><br><span class="line">    <span class="comment">//    [myAccount valueForKey:@&quot;test&quot;];</span></span><br><span class="line">    <span class="comment">//    [myAccount dictionaryWithValuesForKeys:@[@&quot;currBalance&quot;, @&quot;transactions.payee.name&quot;]];</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="使用key设置属性值"><a href="#使用key设置属性值" class="headerlink" title="使用key设置属性值"></a>使用key设置属性值</h4><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">- (<span class="keyword">void</span>)settingAttributeValuesUsingKeys &#123;</span><br><span class="line">    Account *myAccount = [[Account alloc] init];</span><br><span class="line">    [myAccount setValue:@<span class="number">100.0</span> forKey:<span class="string">@&quot;currBalance&quot;</span>];</span><br><span class="line">    <span class="built_in">NSLog</span>(<span class="string">@&quot;currBalance = %@&quot;</span>, myAccount.currBalance); <span class="comment">// currBalance = 100</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">// operationTimes是非引用类型，这里进行了和NSNumber的自动转换</span></span><br><span class="line">    [myAccount setValue:@<span class="number">10</span> forKey:<span class="string">@&quot;operationTimes&quot;</span>];</span><br><span class="line">    <span class="built_in">NSLog</span>(<span class="string">@&quot;operationTimes = %ld&quot;</span>, myAccount.operationTimes); <span class="comment">// operationTimes = 10</span></span><br><span class="line">    </span><br><span class="line">    Person *owner = [[Person alloc] init];</span><br><span class="line">    Address *address = [[Address alloc] init];</span><br><span class="line">   </span><br><span class="line">    [myAccount setValue:address forKeyPath:<span class="string">@&quot;owner.address&quot;</span>]; <span class="comment">// 这时候owner还是null</span></span><br><span class="line">    <span class="built_in">NSLog</span>(<span class="string">@&quot;address = %@&quot;</span>, myAccount.owner.address); <span class="comment">// address = (null)</span></span><br><span class="line">    </span><br><span class="line">    [myAccount setValue:owner forKeyPath:<span class="string">@&quot;owner&quot;</span>];</span><br><span class="line">    [myAccount setValue:address forKeyPath:<span class="string">@&quot;owner.address&quot;</span>];</span><br><span class="line">    <span class="built_in">NSLog</span>(<span class="string">@&quot;address = %@&quot;</span>, myAccount.owner.address); <span class="comment">// address = &lt;Address: 0x600001a43550&gt;</span></span><br><span class="line">    </span><br><span class="line">    [myAccount setValuesForKeysWithDictionary:@&#123;<span class="string">@&quot;currBalance&quot;</span>: @<span class="number">200.0</span>, <span class="string">@&quot;owner&quot;</span>: owner&#125;];</span><br><span class="line">    <span class="built_in">NSLog</span>(<span class="string">@&quot;currBalance = %@, owner = %@&quot;</span>, myAccount.currBalance, myAccount.owner); <span class="comment">// currBalance = 200, owner = &lt;Person: 0x600001478ee0&gt;</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">// Terminating app due to uncaught exception &#x27;NSUnknownKeyException&#x27;, reason: &#x27;[&lt;Account 0x6000029c2490&gt; setValue:forUndefinedKey:]: xxx&#x27;</span></span><br><span class="line">    <span class="comment">//    [myAccount setValue:@&quot;value&quot; forUndefinedKey:@&quot;undefinedKey&quot;];</span></span><br><span class="line">    <span class="comment">//    [myAccount setValuesForKeysWithDictionary:@&#123;@&quot;currBalance&quot;: @200.0, @&quot;owner.address.street&quot;: @&quot;第一大道&quot;&#125;];</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="访问集合属性"><a href="#访问集合属性" class="headerlink" title="访问集合属性"></a>访问集合属性</h3><p>符合键值编码的对象以与公开其他属性相同的方式公开其多对多属性。您可以使用<code>valueForKey:</code>或<code>setValue:forKey:</code>来获取或设置集合属性。但是，当你想要操作这些集合内容的时候，使用协议定义的可变代理方法通常是最有效的。<br>该协议为集合对象访问定义了三种不同的代理方法，每种方法都有一个key和key path变量：</p><ul><li><code>mutableArrayValueForKey:</code>和<code>mutableArrayValueForKeyPath:</code> 返回一个行为类似<code>NSMutableArray</code>的代理对象</li><li> <code>mutableSetValueForKey:</code>和<code>mutableSetValueFOrKeyPath:</code> 返回一个行为类似<code>NSMutableSet</code>的代理对象</li><li><code>mutableOrderedSetValueForKey:</code>和<code>mutableOrderedSetValueForKeyPath:</code> 返回一个行为类似<code>NSMutableOrderedSet</code>的代理对象<br>当您对代理对象进行操作，向对象添加元素，从中删除元素或者替换其中的元素时，协议的默认实现会相应地修改基础属性。这比使用<code>valueForKey:</code>获取一个不可变的集合对象，再创建一个可修改的集合，然后把修改后的集合通过<code>setValue:forKey:</code>更有效。在许多情况下，它比直接使用可变属性也是更有效的。这些方法为持有集合对象的对象们提供了维护KVO特性的好处。<figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">- (<span class="keyword">void</span>)accessingCollectionProperties &#123;</span><br><span class="line">    Transaction *t1 = [[Transaction alloc] init];</span><br><span class="line">    Transaction *t2 = [[Transaction alloc] init];</span><br><span class="line">    Account *myAccount = [[Account alloc] init];</span><br><span class="line">    </span><br><span class="line">    [myAccount addObserver:<span class="keyword">self</span> forKeyPath:<span class="string">@&quot;transactions&quot;</span> options:<span class="built_in">NSKeyValueObservingOptionOld</span> | <span class="built_in">NSKeyValueObservingOptionNew</span> context:<span class="literal">nil</span>];</span><br><span class="line">    </span><br><span class="line">    </span><br><span class="line">    [myAccount setValue:@[t1, t2] forKey:<span class="string">@&quot;transactions&quot;</span>];</span><br><span class="line">    <span class="built_in">NSLog</span>(<span class="string">@&quot;1st transactions = %@&quot;</span>, myAccount.transactions); <span class="comment">// 1st transactions = (&quot;&lt;Transaction: 0x6000009d1400&gt;&quot;,&quot;&lt;Transaction: 0x6000009d1420&gt;&quot;)</span></span><br><span class="line">    <span class="built_in">NSMutableArray</span> &lt;Transaction *&gt;*transactions = [myAccount mutableArrayValueForKey:<span class="string">@&quot;transactions&quot;</span>];</span><br><span class="line">    </span><br><span class="line">    [transactions addObject:[[Transaction alloc] init]];</span><br><span class="line">    <span class="built_in">NSLog</span>(<span class="string">@&quot;2nd transactions = %@&quot;</span>, myAccount.transactions); <span class="comment">// 2nd transactions = (&quot;&lt;Transaction: 0x6000009d1400&gt;&quot;,&quot;&lt;Transaction: 0x6000009d1420&gt;&quot;,&quot;&lt;Transaction: 0x6000009cabf0&gt;&quot;)</span></span><br><span class="line">    </span><br><span class="line">    [transactions removeLastObject];</span><br><span class="line">    <span class="built_in">NSLog</span>(<span class="string">@&quot;3th transactions = %@&quot;</span>, myAccount.transactions); <span class="comment">// 3th transactions = (&quot;&lt;Transaction: 0x6000009d1400&gt;&quot;,&quot;&lt;Transaction: 0x6000009d1420&quot;)</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="使用集合操作符"><a href="#使用集合操作符" class="headerlink" title="使用集合操作符"></a>使用集合操作符</h4>当您向<code>valueForKeyPath:</code>消息发送符合键值编码的对象时，可以在key path中嵌入集合运算符。集合运算符是一个小的关键字列表之一，前面是一个@符号，它指定了getter应该执行的操作，以便在返回之前以某种方式操作数据。<code>NSObject</code>为<code>valueForKeyPath:</code>提供了默认实现。<br>当key path包含集合运算符时，运算符之前的部分称为左键路径，指示相对于消息接受者操作的集合，当你直接向一个集合（例如<code>NSArray</code>）发送消息时左键路径或许可以省略。操作符之后的部分称为右键路径，指定操作符应处理的集合中的属性，除了<code>@count</code>之外的所有操作符都需要一个右键路径。<br><img src="http://image.iosprogrammer.hongbility.com/KVC_KVOkeypath.jpg"><br>集合运算符表现出三种基本类型的行为：</li><li><strong>聚合运算符</strong>以某种方式合并集合的对象，并返回通常与右键路径中指定的属性的数据类型匹配的单个对象。<code>@count</code>是一个例外，它没有正确的关键路径并始终将返回一个<code>NSNumber</code>实例。包括：<code>@avg</code>/<code>@count</code>/<code>@max</code>/<code>@min</code>/<code>@sum</code>。</li><li><strong>数组运算符</strong>返回一个<code>NSArray</code>实例，该实例包含命名集合中保存的对象的某个子集。包含：<code>@distinctUnionOfObjects</code>/<code>@unionOfObjects</code>。</li><li><strong>嵌套运算符</strong>处理包含其他集合的集合，并根据操作符返回一个<code>NSArray</code>或<code>NSSet</code>实例，它以某种方式组合嵌套集合的对象。包含：<code>@distinctUnionOfArrays</code>/<code>@unionOfArrays</code>/<code>@distinctUnionOfSets</code>。</li></ul><h4 id="示例"><a href="#示例" class="headerlink" title="示例"></a>示例</h4><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br></pre></td><td class="code"><pre><span class="line">- (<span class="keyword">void</span>)usingCollectionOperators &#123;</span><br><span class="line">    Transaction *t1 = [Transaction transactionWithPayee:<span class="string">@&quot;Green Power&quot;</span> amount:@(<span class="number">120.00</span>) date:[<span class="built_in">NSDate</span> dateWithTimeIntervalSinceNow:<span class="number">100</span>]];</span><br><span class="line">    Transaction *t3 = [Transaction transactionWithPayee:<span class="string">@&quot;Green Power&quot;</span> amount:@(<span class="number">170.00</span>) date:[<span class="built_in">NSDate</span> dateWithTimeIntervalSinceNow:<span class="number">300</span>]];</span><br><span class="line">    Transaction *t5 = [Transaction transactionWithPayee:<span class="string">@&quot;Car Loan&quot;</span> amount:@(<span class="number">250.00</span>) date:[<span class="built_in">NSDate</span> dateWithTimeIntervalSinceNow:<span class="number">500</span>]];</span><br><span class="line">    Transaction *t6 = [Transaction transactionWithPayee:<span class="string">@&quot;Car Loan&quot;</span> amount:@(<span class="number">250.00</span>) date:[<span class="built_in">NSDate</span> dateWithTimeIntervalSinceNow:<span class="number">600</span>]];</span><br><span class="line">    Transaction *t13 = [Transaction transactionWithPayee:<span class="string">@&quot;Animal Hospital&quot;</span> amount:@(<span class="number">600.00</span>) date:[<span class="built_in">NSDate</span> dateWithTimeIntervalSinceNow:<span class="number">500</span>]];</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">NSArray</span> *transactions = @[t1, t3, t5, t6, t13];</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/* 聚合运算符</span></span><br><span class="line"><span class="comment">     * 聚合运算符可以处理数组或属性集，从而生成反映集合某些方面的单个值。</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="comment">// @avg 平均值</span></span><br><span class="line">    <span class="built_in">NSNumber</span> *transactionAverage = [transactions valueForKeyPath:<span class="string">@&quot;@avg.amount&quot;</span>];</span><br><span class="line">    <span class="built_in">NSLog</span>(<span class="string">@&quot;transactionAverage = %@&quot;</span>, transactionAverage); <span class="comment">// transactionAverage = 278</span></span><br><span class="line">    <span class="comment">// @count 个数</span></span><br><span class="line">    <span class="built_in">NSNumber</span> *numberOfTransactions = [transactions valueForKeyPath:<span class="string">@&quot;@count&quot;</span>];</span><br><span class="line">    <span class="built_in">NSLog</span>(<span class="string">@&quot;numberOfTransactions = %@&quot;</span>, numberOfTransactions); <span class="comment">// numberOfTransactions = 5</span></span><br><span class="line">    <span class="comment">// @max 最大值 使用compare:进行比较</span></span><br><span class="line">    <span class="built_in">NSDate</span> *latestDate = [transactions valueForKeyPath:<span class="string">@&quot;@max.date&quot;</span>];</span><br><span class="line">    <span class="built_in">NSLog</span>(<span class="string">@&quot;latestDate = %@&quot;</span>, latestDate); <span class="comment">// latestDate = Thu Nov  1 15:05:59 2018</span></span><br><span class="line">    <span class="comment">// @min 最小值 使用compare:进行比较</span></span><br><span class="line">    <span class="built_in">NSDate</span> *earliestDate = [transactions valueForKeyPath:<span class="string">@&quot;@min.date&quot;</span>];</span><br><span class="line">    <span class="built_in">NSLog</span>(<span class="string">@&quot;earliestDate = %@&quot;</span>, earliestDate);<span class="comment">// earliestDate = Thu Nov  1 14:57:39 2018</span></span><br><span class="line">    <span class="comment">// @sum 总和</span></span><br><span class="line">    <span class="built_in">NSNumber</span> *amountSum = [transactions valueForKeyPath:<span class="string">@&quot;@sum.amount&quot;</span>];</span><br><span class="line">    <span class="built_in">NSLog</span>(<span class="string">@&quot;amountSum = %@&quot;</span>, amountSum); <span class="comment">// amountSum = 1390</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">/* 数组运算符</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * 数组运算符导致valueForKeyPath:返回与右键路径指示的特定对象集相对应的对象数组。</span></span><br><span class="line"><span class="comment">     * 如果使用数组运算符时任何叶对象为nil，则valueForKeyPath：方法会引发异常。</span></span><br><span class="line"><span class="comment">     **/</span></span><br><span class="line">    <span class="comment">// @distinctUnionOfObjects 创建并返回一个数组，该数组包含与右键路径指定的属性对应的集合的不同对象。会删除重复对象。</span></span><br><span class="line">    <span class="built_in">NSArray</span> *distinctPayees = [transactions valueForKeyPath:<span class="string">@&quot;@distinctUnionOfObjects.payee&quot;</span>];</span><br><span class="line">    <span class="built_in">NSLog</span>(<span class="string">@&quot;distinctPayees = %@&quot;</span>, distinctPayees); <span class="comment">// distinctPayees = (&quot;Green Power&quot;, &quot;Animal Hospital&quot;, &quot;Car Loan&quot;)</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">// @unionOfObjects 创建并返回一个数组，该数组包含与右键路径指定的属性对应的集合的所有对象。不删除重复对象</span></span><br><span class="line">    <span class="built_in">NSArray</span> *payees = [transactions valueForKeyPath:<span class="string">@&quot;@unionOfObjects.payee&quot;</span>];</span><br><span class="line">    <span class="built_in">NSLog</span>(<span class="string">@&quot;payees = %@&quot;</span>, payees); <span class="comment">// payees = (&quot;Green Power&quot;, &quot;Green Power&quot;, &quot;Car Loan&quot;, &quot;Car Loan&quot;, &quot;Animal Hospital&quot;)</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">/** 嵌套运算符</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * 嵌套运算符对嵌套集合进行操作，集合中的每个条目都包含一个集合。</span></span><br><span class="line"><span class="comment">     * 如果使用数组运算符时任何叶对象为nil，则valueForKeyPath：方法会引发异常。</span></span><br><span class="line"><span class="comment">     **/</span></span><br><span class="line">    Transaction *moreT1 = [Transaction transactionWithPayee:<span class="string">@&quot;General Cable - Cottage&quot;</span> amount:@(<span class="number">120.00</span>) date:[<span class="built_in">NSDate</span> dateWithTimeIntervalSinceNow:<span class="number">10</span>]];</span><br><span class="line">    Transaction *moreT2 = [Transaction transactionWithPayee:<span class="string">@&quot;General Cable - Cottage&quot;</span> amount:@(<span class="number">1550.00</span>) date:[<span class="built_in">NSDate</span> dateWithTimeIntervalSinceNow:<span class="number">3</span>]];</span><br><span class="line">    Transaction *moreT7 = [Transaction transactionWithPayee:<span class="string">@&quot;Hobby Shop&quot;</span> amount:@(<span class="number">600.00</span>) date:[<span class="built_in">NSDate</span> dateWithTimeIntervalSinceNow:<span class="number">160</span>]];</span><br><span class="line">    <span class="built_in">NSArray</span> *moreTransactions = @[moreT1, moreT2, moreT7];</span><br><span class="line">    <span class="built_in">NSArray</span> *arrayOfArrays = @[transactions, moreTransactions];</span><br><span class="line">    <span class="comment">// @distinctUnionOfArrays  指定@distinctUnionOfArrays运算符时，valueForKeyPath:创建并返回一个数组，该数组包含与右键路径指定的属性对应的所有集合的组合的不同对象。</span></span><br><span class="line">    <span class="built_in">NSArray</span> *collectedDistinctPayees = [arrayOfArrays valueForKeyPath:<span class="string">@&quot;@distinctUnionOfArrays.payee&quot;</span>];</span><br><span class="line">    <span class="built_in">NSLog</span>(<span class="string">@&quot;collectedDistinctPayees = %@&quot;</span>, collectedDistinctPayees); <span class="comment">// collectedDistinctPayees = ( &quot;General Cable - Cottage&quot;, &quot;Animal Hospital&quot;, &quot;Hobby Shop&quot;, &quot;Green Power&quot;, &quot;Car Loan&quot;)</span></span><br><span class="line">    <span class="comment">// @unionOfArrays 与@distinctUnionOfArrays 不同的是不会删除相同的元素</span></span><br><span class="line">    <span class="built_in">NSArray</span> *collectedPayees = [arrayOfArrays valueForKeyPath:<span class="string">@&quot;@unionOfArrays.payee&quot;</span>];</span><br><span class="line">    <span class="built_in">NSLog</span>(<span class="string">@&quot;collectedPayees = %@&quot;</span>, collectedPayees); <span class="comment">// collectedPayees = (&quot;Green Power&quot;, &quot;Green Power&quot;, &quot;Car Loan&quot;, &quot;Car Loan&quot;, &quot;Animal Hospital&quot;, &quot;General Cable - Cottage&quot;, &quot;General Cable - Cottage&quot;, &quot;Hobby Shop&quot;)</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">// @distinctUnionOfSets 与@distinctUnionOfArrays作用相同，只是用于NSSet对象而不是NSArray</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="访问者搜索模式"><a href="#访问者搜索模式" class="headerlink" title="访问者搜索模式"></a>访问者搜索模式</h3><p>NSObject提供的NSkeyValueCoding协议的默认实现使用明确定义的规则集将基于键的访问器调用映射到对象的基础属性。这些协议方法使用“key”在其自己的对象实例中搜索访问器、实例变量以及遵循某个命名规则的相关方法。虽然您很少修改此默认搜索，但了解它的工作方式会有所帮助，既可以跟踪键值编码对象的行为，也可以使您自己的对象兼容KVC。</p><h4 id="Getter的搜索模式"><a href="#Getter的搜索模式" class="headerlink" title="Getter的搜索模式"></a>Getter的搜索模式</h4><p><code>valueForKey:</code>的默认实现是，给定<code>key</code>参数作为输入，通过下面的过程，在接收<code>valueForKey:</code>调用的类实例中操作。</p><ol><li>按顺序搜索访问器方法<code>get&lt;Key&gt;</code>/<code>&lt;key&gt;</code>/<code>is&lt;Key&gt;</code>/<code>_&lt;key&gt;</code>。如果找到，调用该方法并且带着方法的调用结果调转到第5步执行；否则，继续下一步。</li><li>如果没有找到简单的访问方法，搜索其名称匹配某些模式的方法的实例。其中匹配模式包含<code>countOf&lt;Key&gt;</code>，<code>objectIn&lt;Key&gt;AtIndex:</code>（对应于<code>NSArray</code>定义的基本方法），和<code>&lt;key&gt;AtIndexs:</code>（对应于<code>NSArray</code>的方法<code>objectsAtIndexs:</code>）<br>一旦找到第一个和其他两个中的至少一个，则创建一个响应所以<code>NSArray</code>方法并返回该方法的集合代理对象。否则，执行第3步。<br>代理对象随后将任何<code>NSArray</code>接收到的一些组合的消息。**实际上，与符合键值编码对象一起工作的代理对象允许底层属性的行为就像它是<code>NSArray</code>一样，即便它不是。</li><li>如果没有找到简单的访问器方法或数组访问方法组，则寻找三个方法<code>countOf&lt;Key&gt;</code>/<code>enumeratorOf&lt;Key&gt;</code>/<code>memberOf&lt;Key&gt;:</code>，对应<code>NSSet</code>类的基本方法。<br>如果三个方法全找到了，则创建一个集合代理对象来响应所有的NSSet方法并返回。否则，执行第4步。</li><li>如果上面的方法都没有找到，并且接受者的类方法<code>accessInstanceVariablesDirectly</code>返回<code>YES</code>（默认YES），则按序搜索以下实例变量：<code>_&lt;key&gt;</code>/<code>_is&lt;Key&gt;</code>/<code>&lt;key&gt;</code>/<code>is&lt;Key&gt;</code>。如果找到其中之一，直接获取实例变量的值并跳转到第5步；否则执行第6步。</li><li>如果检索到的属性值是对象指针，则只返回结果；如果值是受<code>NSNumber</code>支持的标量，则将其存储在<code>NSNumber</code>实例中并返回；如果结果是<code>NSNumber</code>不支持的标量，则转换成<code>NSValue</code>对象并返回</li><li>如果以上所有的尝试都失败了，则调用<code>valueForUndefinedKey:</code>，这个方法默认抛出异常，<code>NSObject</code>的子类可以重写来自定义行为。</li></ol><h4 id="Setter的搜索模式"><a href="#Setter的搜索模式" class="headerlink" title="Setter的搜索模式"></a>Setter的搜索模式</h4><p><code>setValue:forKey:</code>的默认实现是给定<code>key</code>和<code>value</code>作为参数输入，尝试把<code>value</code>设置给以<code>key</code>命名的属性。过程如下：</p><ol><li>按序搜索<code>set&lt;Key&gt;:</code>或<code>_set&lt;Key&gt;</code>，如果找到，则使用输入参数调用并结束。</li><li>如果没有找到简单的访问器方法，并且如果类方法<code>accessInstanceVariablesDirectly</code>返回<code>YES</code>（默认为YES），则按序搜索以下实例变量: <code>_&lt;key&gt;</code>/<code>_is&lt;Key&gt;</code>/<code>&lt;key&gt;</code>/<code>is&lt;Key&gt;</code>，如果找到了则直接进行赋值并结束。</li><li>以上方法皆失败则调用<code>setValue:forUndefinedKey:</code>，这个方法默认抛出异常，<code>NSObject</code>的子类可以自定义。</li></ol><h1 id="KVO"><a href="#KVO" class="headerlink" title="KVO"></a>KVO</h1><p>Key-value observing提供了一种机制，允许对象把自身属性的更改通知给其他属性。它对应用程序中model和controller层之间的通信特别有用。通常，控制器对象观察模型对象的属性，视图对象通过控制器观察模型对象的属性。另外，一个模型对象或许会观察另一个模型对象（通常用与确认从属值何时改变）或甚至自身（再次确认从属值何时改变）。<br>你可以观察属性，包括简单属性，一对一关系和多对多关系。多对多关系的观察者被告知所作出的改变的类型——以及改变中涉及哪些对象。</p><h2 id="注册KVO"><a href="#注册KVO" class="headerlink" title="注册KVO"></a>注册KVO</h2><ul><li>使用<code>addObserver:forKeyPath:options:content:</code>方法来给observer注册一个observed object</li><li>在observer内部实现<code>observerValueForKeyPath:ofObject:change:context:</code>来接收更改的通知消息。</li><li>当不再应该接收消息时，使用<code>removeObserver:forKeyPath:</code>方法来反注册观察者。起码也要在observer被移除前调用这个方法。</li></ul><h3 id="注册Observer"><a href="#注册Observer" class="headerlink" title="注册Observer"></a>注册Observer</h3><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">addObserver:forKeyPath:options:content:</span><br></pre></td></tr></table></figure><h4 id="options"><a href="#options" class="headerlink" title="options"></a>options</h4><p>options参数指定了一个按位<code>OR</code>的常量选项，会影响通知中提供的更改字典的内容和生成通知的方式。<br>你可以选择使用<code>NSKeyValueObservingOptionOld</code>选项，在被观察的属性修改前收到旧值；也可以使用<code>NSKeyValueObservingOptionNew</code>来获取修改后的新值。通过<code>NSKeyValueObservingOptionOld | NSKeyValueObservingOptionNew</code>获取两者。<br>使用<code>NSKeyValueObservingOptionInitial</code>选项，让被观察的属性在<code>addObserver:forKeyPath:options:context</code>方法返回前发送即时通知。你可以使用此附加的一次性通知来在观察者中建立属性的初始值。<br>通过包含<code>NSKeyValueObservingOptionPrior</code>来指示被观察对象在属性更改之前发送通知（除了在更改之后发送通知）。在更改之前发送的通知中的<code>change</code>字典始终包含<code>NSKeyValueChangeNotificationIsPriorKey</code>，其值是包含布尔值YES的NSNumber对象，但不包含<code>NSKeyValueChangeNewKey</code>的内容。如果指定此选项，则更改后发送的通知中的<code>change</code>字典的内容和未指定此选项时包含的内容相同。当观察者自己的键值观察兼容性要求它为自己的一个属性调用-willChangexxx方法之一时，可以使用此选项，并且该属性的值取决于被观察对象的属性的值。</p><h4 id="context"><a href="#context" class="headerlink" title="context"></a>context</h4><p><code>addObserver:forKeyPath:options:context:</code>消息中的上下文指针包含将在相应的更改通知中传递回观察者的任意数据。您可以使用NULL来完全指定并依赖于<code>key path</code>字符串来确定更改通知的来源，但是这种方法可能会导致其超类也因不同原因观察到相同密钥路径的对象出现问题。</p><p>一个更安全且具有扩展性的方法是使用<code>content</code>来确保你收到的通知就是发给你的而不是超类的。</p><p>类中唯一命名的静态（static）变量的地址是一个很好的content。在超类或子类中以类似的方式选择的上下文不太可能重叠。您可以为整个类选择同一个上下文，并根据通知消息中的key path字符串来确定更改的内容；或者，您可以为每个观察到的密钥路径创建不同的上下文，从而完全绕过字符串比较的需要，从而实现更有效的通知解析。</p><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">- (<span class="keyword">void</span>)registerAsObserver &#123;</span><br><span class="line">    BankAccount *myAccount = [[BankAccount alloc] init];</span><br><span class="line">    [myAccount addObserver:<span class="keyword">self</span> forKeyPath:<span class="string">@&quot;currBalance&quot;</span> options:<span class="built_in">NSKeyValueObservingOptionInitial</span> | <span class="built_in">NSKeyValueObservingOptionNew</span> | <span class="built_in">NSKeyValueObservingOptionOld</span> | <span class="built_in">NSKeyValueObservingOptionPrior</span> context:PersonAccountBalanceContext];</span><br><span class="line">    myAccount.currBalance = @<span class="number">100</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>注意，<strong>键值观察<code>addObserver:forKeyPath:options:context:</code>方法不对观察者、被观察的对象、上下文保持强引用。如需要，你应该对它们保持强引用。</strong></p><h3 id="接受改变的通知"><a href="#接受改变的通知" class="headerlink" title="接受改变的通知"></a>接受改变的通知</h3><p>当对象的被观察属性值改变的时候，观察者对象会收到<code>observeValueForKeyPath:ofObject:change:context:</code>消息。所有的观察者必须实现这个方法。</p><p>观察对象提供触发通知的key path，自身作为<code>object</code>，<code>change</code>字典包含改变的细节，并且<code>context</code>指针就是观察者被注册时提供的。</p><p><code>NSKeyValueChangeKindKey</code>提供改变类型的信息。<code>NSKeyValueChangeKindKey</code>表示观察对象的值已更改。如果观察的属性是一个对多的关系，<code>NSKeyValueChangeInsertion</code>/<code>NSKeyValueChangeRemoval</code>/<code>NSKeyValueChangeReplacement</code>分别表示集合的插入、删除、替换操作。<code>NSKeyValueChangeIndexesKey</code>表示集合中已更改内容的<code>NSIndexSet</code>。</p><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">- (<span class="keyword">void</span>)observeValueForKeyPath:(<span class="built_in">NSString</span> *)keyPath ofObject:(<span class="keyword">id</span>)object change:(<span class="built_in">NSDictionary</span>&lt;<span class="built_in">NSKeyValueChangeKey</span>,<span class="keyword">id</span>&gt; *)change context:(<span class="keyword">void</span> *)context &#123;</span><br><span class="line">    <span class="keyword">if</span> (context == PersonAccountBalanceContext) &#123;</span><br><span class="line">        <span class="built_in">NSLog</span>(<span class="string">@&quot;PersonAccountBalanceContext 对应的属性改变了&quot;</span>);</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (context == PersonAccountTransactionContext) &#123;</span><br><span class="line">        <span class="keyword">if</span> ([change[<span class="built_in">NSKeyValueChangeKindKey</span>] unsignedIntValue] == <span class="built_in">NSKeyValueChangeSetting</span>) &#123;</span><br><span class="line">            <span class="built_in">NSLog</span>(<span class="string">@&quot;集合内容赋值 索引为：%@&quot;</span>, change[<span class="built_in">NSKeyValueChangeIndexesKey</span>]);</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> ([change[<span class="built_in">NSKeyValueChangeKindKey</span>] unsignedIntValue] == <span class="built_in">NSKeyValueChangeInsertion</span>) &#123;</span><br><span class="line">            <span class="built_in">NSLog</span>(<span class="string">@&quot;集合内容插入 索引为：%@&quot;</span>, change[<span class="built_in">NSKeyValueChangeIndexesKey</span>]);</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> ([change[<span class="built_in">NSKeyValueChangeKindKey</span>] unsignedIntValue] == <span class="built_in">NSKeyValueChangeRemoval</span>) &#123;</span><br><span class="line">            <span class="built_in">NSLog</span>(<span class="string">@&quot;集合内容删除 索引为：%@&quot;</span>, change[<span class="built_in">NSKeyValueChangeIndexesKey</span>]);</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> ([change[<span class="built_in">NSKeyValueChangeKindKey</span>] unsignedIntValue] == <span class="built_in">NSKeyValueChangeReplacement</span>) &#123;</span><br><span class="line">            <span class="built_in">NSLog</span>(<span class="string">@&quot;集合内容替换 索引为：%@&quot;</span>, change[<span class="built_in">NSKeyValueChangeIndexesKey</span>]);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="移除观察者对象"><a href="#移除观察者对象" class="headerlink" title="移除观察者对象"></a>移除观察者对象</h3><p>通过想观察者发送<code>removeObserver:forKeyPath:context</code>消息来移除观察者对象。收到该消息后，观察者对象将不再接收任何<code>observerValueForKeyPath:ofObject:change:context</code>中指定key path/object的消息。</p><p>删除观察者时，注意：</p><ul><li><strong>移除和添加的方法要保持对称</strong>，否则会引发异常。如果无法保持对称，则把移除的方法放到try/catch块中。</li><li>对象释放时，不会自动把自己从观察者中移除，此时被观察者继续发送通知。但是就像任何其他消息一样，改变的通知发送给了已经释放的对象会触发内存访问异常。因此，<strong>务必在观察者从内存中消失前，将其移除</strong></li><li>协议没有提供方法来查询一个对象是否是观察者或被观察者。你必须在代码中自行避免错误。典型的方案是在观察者初始化期间（init或dealloc）注册为观察者，并在释放时（dealloc）注销。</li></ul><h2 id="兼容KVO"><a href="#兼容KVO" class="headerlink" title="兼容KVO"></a>兼容KVO</h2><p>为了让特定属性符合KVO标准，class必须满足一下内容：</p><ul><li>该类必须是符合该属性的KVC</li><li>该类会为该属性触发KVO通知</li><li>相关的key已经被成功注册</li></ul><p>有两种技术可确保发出KVO通知。NSObject提供自动支持，默认情况下可用于符合键值编码的类的所有属性。通常，如果你遵守Cocoa编码和命名约定，则可以使用自动通知，而不必编写任何代码。</p><p>手动方式为通知触发时提供了更多的控制权，并且需要额外编码。你可以通过实现<code>automaticallyNotifiesObserversForKey:</code>来控制子类属性的自动通知。</p><h3 id="自动通知"><a href="#自动通知" class="headerlink" title="自动通知"></a>自动通知</h3><p>下列方法列举了会触发自动通知的一些场景：</p><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//调用访问器方法。</span></span><br><span class="line">[account setName：@“Savings”];</span><br><span class="line"> </span><br><span class="line"><span class="comment">//使用setValue：forKey：。</span></span><br><span class="line">[account setValue：@“Savings”forKey：@“name”];</span><br><span class="line"> </span><br><span class="line"><span class="comment">//使用密钥路径，其中&#x27;account&#x27;是&#x27;document&#x27;的kvc兼容属性。</span></span><br><span class="line">[document setValue：@“Savings”forKeyPath：@“account.name”];</span><br><span class="line"> </span><br><span class="line"><span class="comment">//使用mutableArrayValueForKey：检索关系代理对象。</span></span><br><span class="line">Transaction * newTransaction = &lt;＃为帐户＃&gt;创建新交易;</span><br><span class="line"><span class="built_in">NSMutableArray</span> * transactions = [account mutableArrayValueForKey：@“transactions”];</span><br><span class="line">[transactions addObject：newTransaction];</span><br></pre></td></tr></table></figure><h3 id="手动通知"><a href="#手动通知" class="headerlink" title="手动通知"></a>手动通知</h3><p>有些情况下，你可能想要控制通知的过程，例如，最大限度减少因应用程序特定原因而不必要的触发通知，或把一组通知整合到一个。</p><p>手动通知和自动通知不是互斥的。手动和自动的通知可以同时触发。如果你只想要手动触发，则需要通过重写<code>automaticallyNotifiesObserversForKey:</code>方法来禁止自动通知。</p><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">+ (<span class="built_in">BOOL</span>)automaticNotifiesObserversForKey:(<span class="built_in">NSString</span> *)theKey &#123;</span><br><span class="line">    <span class="built_in">BOOL</span> automatic = <span class="literal">NO</span>;</span><br><span class="line">    <span class="keyword">if</span> ([theKey isEqualToString：@“balance”]) &#123;</span><br><span class="line">        automatic = <span class="literal">NO</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">        automatic = [<span class="keyword">super</span> automaticNotifiesObserversForKey: theKey];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> automatic;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>**要实现手动观察者通知，你要在值改变前调用<code>willChangeValueForKey:</code>，并在值改变后调用<code>didChangeValueForKey:</code>。有三组类似的方法：</p><ul><li><code>willChangeValueForKey:</code>和<code>didChangeValueForKey:</code>。用于单个对象</li><li><code>willChange:valuesAtIndexes:forKey:</code>和<code>didChange:valuesAtIndexes:forKey:</code>。用于有序集合</li><li><code>willChangeValueForKey:withSetMutation:usingObjects:</code>和<code>willChangeValueForKey:withSetMutation:usingObjects:</code>。用于无须集合</li></ul><p>下面在访问器方法中手动触发：</p><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">- (<span class="keyword">void</span>)setBalance:(<span class="keyword">double</span>)theBalance &#123;</span><br><span class="line">    [<span class="keyword">self</span> willChangeValueForKey:<span class="string">@&quot;balance&quot;</span>];</span><br><span class="line">    _balance = theBalance;</span><br><span class="line">    [<span class="keyword">self</span> didChangeValueForKey:<span class="string">@&quot;balance&quot;</span>];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>为了减少不必要的通知，可以先检查值是否改变了，然后决定是否发通知：</p><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">- (<span class="keyword">void</span>)setBalance:(<span class="keyword">double</span>)theBalance &#123;</span><br><span class="line">    <span class="keyword">if</span> (theBalance != _balance) &#123;</span><br><span class="line">        [<span class="keyword">self</span> willChangeValueForKey:<span class="string">@&quot;balance&quot;</span>];</span><br><span class="line">        _balance = theBalance;</span><br><span class="line">        [<span class="keyword">self</span> didChangeValueForKey:<span class="string">@&quot;balance&quot;</span>];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如果一个操作导致多个key发生改变，必须嵌套发送通知：</p><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">- (<span class="keyword">void</span>)setBalance:(<span class="keyword">double</span>)theBalance &#123;</span><br><span class="line">    [<span class="keyword">self</span> willChangeValueForKey:<span class="string">@&quot;balance&quot;</span>];</span><br><span class="line">    [<span class="keyword">self</span> willChangeValueForKey:<span class="string">@&quot;itemChanged&quot;</span>];</span><br><span class="line">    _balance = theBalance;</span><br><span class="line">    _itemChanged = _itemChanged+<span class="number">1</span>;</span><br><span class="line">    [<span class="keyword">self</span> didChangeValueForKey:<span class="string">@&quot;itemChanged&quot;</span>];</span><br><span class="line">    [<span class="keyword">self</span> didChangeValueForKey:<span class="string">@&quot;balance&quot;</span>];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在有序的to-many关系中，除了指定更改的key，还不许指定更改的类型和所涉及对象的索引。</p><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">- (<span class="keyword">void</span>)removeTransactionsAtIndexes:(<span class="built_in">NSIndexSet</span> *)indexes &#123;</span><br><span class="line">    [<span class="keyword">self</span> willChange:<span class="built_in">NSKeyValueChangeRemoval</span></span><br><span class="line">        valuesAtIndexes:indexes forKey:<span class="string">@&quot;transactions&quot;</span>];</span><br><span class="line"> </span><br><span class="line">    <span class="comment">// Remove the transaction objects at the specified indexes.</span></span><br><span class="line"> </span><br><span class="line">    [<span class="keyword">self</span> didChange:<span class="built_in">NSKeyValueChangeRemoval</span></span><br><span class="line">        valuesAtIndexes:indexes forKey:<span class="string">@&quot;transactions&quot;</span>];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="注册从属keys"><a href="#注册从属keys" class="headerlink" title="注册从属keys"></a>注册从属keys</h2><p>在许多情况下，一个属性的值取决于另一个对象中的一个或多个其他属性的值。如果一个属性的值发生更改，则还应标记派生属性的值以进行更改。</p><h3 id="To-One-关系"><a href="#To-One-关系" class="headerlink" title="To-One 关系"></a>To-One 关系</h3><p>要为一对一关系自动触发通知，应该重写<code>keyPathsForValuesAffectingValueForKey</code>或实现一个合适的方法，该方法遵循它为注册依赖键定义的模式。</p><p>例如，<code>fullName</code>取决于<code>firstName</code>和<code>lastName</code>。返回<code>fullName</code>的方法可以写成如下：</p><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">- （<span class="built_in">NSString</span> *）fullName &#123;</span><br><span class="line">    <span class="keyword">return</span> [<span class="built_in">NSString</span> stringWithFormat：@“％@％@”，firstName，lastName];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>当<code>firstName</code>或<code>lastName</code>发生改变时，必须通知观察<code>fullName</code>属性的程序，因为它们影响这个属性的值。</p><p>一个解决方案是重写<code>keyPathsForValuesAffectingValueForKey</code>来指定<code>fullName</code>属性依赖于<code>lastName</code>和<code>firstName</code>。</p><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">+ (<span class="built_in">NSSet</span> *)keyPathsForValuesAffectingValueForKey:(<span class="built_in">NSString</span> *)key &#123;</span><br><span class="line"> </span><br><span class="line">    <span class="built_in">NSSet</span> *keyPaths = [<span class="keyword">super</span> keyPathsForValuesAffectingValueForKey:key];</span><br><span class="line"> </span><br><span class="line">    <span class="keyword">if</span> ([key isEqualToString:<span class="string">@&quot;fullName&quot;</span>]) &#123;</span><br><span class="line">        <span class="built_in">NSArray</span> *affectingKeys = @[<span class="string">@&quot;lastName&quot;</span>, <span class="string">@&quot;firstName&quot;</span>];</span><br><span class="line">        keyPaths = [keyPaths setByAddingObjectsFromArray:affectingKeys];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> keyPaths;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>重写通常应该调用super并返回一个集合，以免影响超类中对此方法的重写。</p><p>通过重写<code>keyPathsForValuesAffecting&lt;Key&gt;</code>也可以达到相同的效果。</p><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">+ (<span class="built_in">NSSet</span> *)keyPathsForValuesAffectingFullName &#123;</span><br><span class="line">    <span class="keyword">return</span> [<span class="built_in">NSSet</span> setWithObjects:<span class="string">@&quot;lastName&quot;</span>, <span class="string">@&quot;firstName&quot;</span>, <span class="literal">nil</span>];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="To-many-关系"><a href="#To-many-关系" class="headerlink" title="To-many 关系"></a>To-many 关系</h3><p><code>keyPathsForValuesAffectingValueForKey:</code>方法不支持to-many关系的key paths。可以使用下面两种方案来处理to-many 关系：</p><ol><li>使用key-value observing注册父项作为子项的相关属性观察者。当子对象添加到关系或从关系中删除的时候，你必须添加或删除父对象。在<code>observeValueForKeyPath:ofObject:change:context:</code>方法中，你可以更新依赖值以相应更改，如下：<figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">[<span class="keyword">self</span> addObserver:<span class="keyword">self</span> forKeyPath:<span class="string">@&quot;transactions&quot;</span> options:<span class="built_in">NSKeyValueObservingOptionNew</span> context:<span class="literal">NULL</span>];</span><br><span class="line"></span><br><span class="line">- (<span class="keyword">void</span>)observeValueForKeyPath:(<span class="built_in">NSString</span> *)keyPath ofObject:(<span class="keyword">id</span>)object change:(<span class="built_in">NSDictionary</span>&lt;<span class="built_in">NSKeyValueChangeKey</span>,<span class="keyword">id</span>&gt; *)change context:(<span class="keyword">void</span> *)context &#123;</span><br><span class="line">    <span class="built_in">NSLog</span>(<span class="string">@&quot;amount = %@&quot;</span>, [<span class="keyword">self</span> valueForKeyPath:<span class="string">@&quot;transactions.@sum.amount&quot;</span>]);</span><br><span class="line">    [<span class="keyword">self</span> setTotalConsumption:[<span class="keyword">self</span> valueForKeyPath:<span class="string">@&quot;transactions.@sum.amount&quot;</span>]];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li>在Core Data中，则可以将父项作为其托管对象上下文的观察者注册到应用程序的通知中心。父项应以类似于键值观察的方式回应孩子们发布的相关变更通知。</li></ol><h2 id="Key-Value-Observing-的实现细节"><a href="#Key-Value-Observing-的实现细节" class="headerlink" title="Key-Value Observing 的实现细节"></a>Key-Value Observing 的实现细节</h2><p>自动key-value observing 是使用一种叫做<em>isa-swizzling</em>的技术实现的。</p><p><em>isa</em>指针指向维护一个调度表（dispatch table）的对象的类。该调度表包含了指向该类实现的方法的指针，以及其他数据。</p><p>当观察者注册对象的属性时，观察对象的isa指针被修改，指向中间类而不是真正的类。因此，isa指针的值不一定反映实例的实际类。</p><p>永远不要依赖isa指针来确定类成员。而应该使用<code>class</code>方法来决定实例所属的类。</p><h1 id="参考连接"><a href="#参考连接" class="headerlink" title="参考连接"></a>参考连接</h1><p><a href="https://github.com/shizhiang/KVC_KVO-Tutorial">示例代码</a></p><p><a href="https://developer.apple.com/library/archive/documentation/Cocoa/Conceptual/KeyValueCoding/index.html#//apple_ref/doc/uid/10000107-SW1">KVC</a></p><p><a href="https://developer.apple.com/library/archive/documentation/Cocoa/Conceptual/KeyValueObserving/KeyValueObserving.html#//apple_ref/doc/uid/10000177-BCICJDHA">KVO</a></p><div><h1>推荐文章<span style="font-size:0.45em; color:gray"></span></h1><ul><li><a href="http://www.iosprogrammer.tech/how-to-make-view-get-intrinsic-content-size/">最佳实践：iOS开发在xib/storyboard中自定义view</a></li><li><a href="http://www.iosprogrammer.tech/What-is-Content-Hugging-Priorities-Content-Compression-Resistance-Priorities/">什么是Content Hugging Priorities/Content Compression Resistance Priorities</a></li><li><a href="http://www.iosprogrammer.tech/UIStackView-Advanced-Knowledge/">UIStackView的正确使用姿势（最新最全、配视频教程）</a></li></ul></div>]]></content>
      
      
      
        <tags>
            
            <tag> iOS </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>程序员读《增长黑客》</title>
      <link href="Growth-Hacker-FanBing/"/>
      <url>Growth-Hacker-FanBing/</url>
      
        <content type="html"><![CDATA[<p><img src="http://image.iosprogrammer.hongbility.com/Books/%E3%80%8A%E5%A2%9E%E9%95%BF%E9%BB%91%E5%AE%A2%E3%80%8B%E5%B0%81%E9%9D%A2.jpg-200" alt="封面"></p><h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>增长黑客，一群以数据驱动营销、以市场指导产品，通过<strong>技术手段</strong>贯彻增长目标的人。既然增长黑客把技术作为达成目标的工具，那作为一个以技术为生的程序员当然需要了解这一行业。</p><p>增长黑客最早在2010年由Qualaroo的创始人兼首席执行官肖恩·埃利斯提出，之后由安德鲁·陈在2012年4月发表的《Growth Hacker is the new VP Marketing》后引起业界广泛关注与交流，之后在国外尤其是硅谷的各家创业公司中开始设置类似职位并为各公司的发展提供了不可估量的作用。</p><p>但是在国内增长黑客的概念一直没有得到广泛的认识和发展，范冰的《增长黑客》一书正是作为一本启蒙书的形式被广泛认可。作为一名混迹互联网公司略有年头的技术人员，笔者有幸拜读此书并通过本文将书中内容总结出来作为“读后感”。希望为一些想要扩展视野的同行提供些许的帮助。</p><h1 id="内容简介"><a href="#内容简介" class="headerlink" title="内容简介"></a>内容简介</h1><p>根据书中章节和一些重点内容整理的思维导图：<br><img src="http://image.iosprogrammer.hongbility.com/Books/%E5%A2%9E%E9%95%BF%E9%BB%91%E5%AE%A2.png-small" alt="思维导图"></p><p>《增长黑客》以互联网行业九死一生的环境为开端。“在国内，中小企业的平均寿命只有3.7年，小微企业还不到3年。至于创业门槛相对较低的互联网行业，能够幸存的比例甚至更低。”让读者深切体会到行业的残酷、活下去的艰难。并且直言众多互联网创业失败的原因在产品问世伊始就已经注定了。之后借助Hotmail仅仅通过在每封邮件的末尾加上一句“快来Hotmail申请你的免费邮箱”便在实现三周获取了30万用户的奇迹，来证明在互联网使用低成本驱动产品的方法是存在的，而发明这些方法的人就是<strong>增长黑客</strong>。</p><p>之后对增长黑客下了定义：增长黑客是一群以数据驱动营销、以市场指导产品，通过技术化手段贯彻增长目标的人。或许，《Growth Hacker is the new VP Marketing》一书中则定义了增长黑客们的工作内容：增长黑客们试图用更聪明的方式解答产品得以增长的奥秘，并使之成为助力产品增长的长效机制。他们通常采用的手段包括A/B测试、搜索引擎优化、电子邮件召回、病毒营销等，而页面加载速度、注册转化率、E-mail到达水平、病毒因子这些指标成为他们日常关注的对象。从中可以看出，增长黑客离不开对技术的使用，因此<strong>程序员可能是最接近和容易成为增长黑客的一群人</strong>。</p><p>紧接着提出了“AARRR”转化漏斗模型，即：Acquisition（获取用户）、Activiation（激发活跃）、Retention（提高留存）、Revenue（增加收入）、Referral（传播推荐）。后面的几章正是按照这个模型进行谋篇布局的。这个模型也贯穿了一个互联网产品的整个生命周期，并且在任何一个阶段都可能让一个产品折戟沉沙。</p><h2 id="创造正确的产品"><a href="#创造正确的产品" class="headerlink" title="创造正确的产品"></a>创造正确的产品</h2><p>任何营销、推广都是围绕着产品进行的，<strong>一款定位准确、可靠的产品是一切的开端和基石</strong>。</p><p>任何一款互联网产品被创造出来都只有一个目的那就是满足用户需求，PMF（产品与市场契合状态）就是用来描述产品对需求的满足程度的。最小化可行产品（MVP）是验证产品设想的不二之选。</p><p>最小化可行产品除了包含整个产品闭环的核心功能外，还需要为用户提供反馈渠道、方便查看的官方公告模块。其中核心功能比较难把握，在这里说一下我的理解，所谓核心功能应该是刚好可以满足产品闭环的基础功能，比如淘宝的核心功能应该就是浏览商品、下单，至于评价、物流，甚至购物车、搜索都不是核心功能；微信的核心功能就是加好友、文字聊天。通过对核心功能的梳理可以看出，真正的核心功能也正是一个产品的核心价值，它们也回答了一个产品是什么、是做什么的。</p><p>MVP提炼的好可以节省很多前期投入、更快的验证想法，但是在这个过程中也一定不能放松对产品质量的要求，可以不花哨一定要耐用。至于反馈渠道和官方公告就是为了让用户能够便捷的和产品沟通，提升用户的参与感，也能帮助产品更快更好的找到PMF。</p><p>“咕咚小区”在产品还没有满足PMF的前提下就花费大笔资金铺广告最后惨淡收场的例子恰好从反面证明了PMF的重要性。</p><p>用户调研的结果不可尽信。用户调研贯穿于产品的任何一个节点，形式是多种多样的，对产品的影响也是至关重要的。但是由于用户质量的参差不齐、目的不一，就造成用研的结果可能并不能真正反映用户在未来的做法。不要看用户说了什么，要看他们做了什么。</p><h2 id="获取用户"><a href="#获取用户" class="headerlink" title="获取用户"></a>获取用户</h2><p>获取用户，<strong>让潜在用户首次接触到产品</strong>。</p><p>首先获取的范围是潜在用户。应该根据产品的定位来寻找潜在用户，一款定位是年轻女性的产品，男性和大龄女性就不应该是潜在用户，不通物流的地区的用户就不是淘宝的潜在用户。抖音的潜在用户可以是所有的互联网用户，但是在产品早期应该把范围缩小到最容易传播、网络条件较好、网费较便宜的一批用户。</p><p>潜在的种子用户使用产品的过程称为产品的“冷启动”，它是在产品尚不具备完善的生态体系并<strong>能够提供足够多可消费内容</strong>的情况下，从零开始第一批用户和制造内容的过程。这个过程的前提是需要产品的提供方准备足够多的可供种子用户消费的内容，这些内容为种子用户将来要提供的内容的一个基调，种子用户提供的内容又会奠定产品在随后发展过程中的“逼格”，因此产品方既要提供足够多的内容供消费又要保证内容的质量。</p><p>给种子用户设置一定的门槛可能会有意想不到的效果。知乎早期的邀请码和小米的饥饿营销都为用户的入驻和体验设置了更高的门槛，但是却使产品获得了快速的传播，种子用户也为产品提供了一批优质的内容和良好的口碑。</p><p>在获取种子用户的过程中，需要警惕“产品蝗虫的出现”，这批用户是指那些产品目标以外的围观群体，他们可能是单纯好奇的观光客、寻找项目的投资人或是来做竞品调研的产品经理。由于产品前期的用户体量较小，“蝗虫”又有很强的嗅觉，就可能导致产品中出现大量的垃圾内容而影响正常用户的使用。社交产品最可能成为重灾区，早期的微信和子弹短信都曾被黄、赌的蝗虫充斥。</p><p>书中例举了很多获取用户的方法：利用社交网络、内容营销、搜索引擎和应用商店优化、饥饿营销、地推、海外扩张。其中有一些方案可能是被人嗤之以鼻的，比如无良小编的耸动标题、刷榜，但是这些方法却都是行之有效的。</p><h2 id="激发活跃"><a href="#激发活跃" class="headerlink" title="激发活跃"></a>激发活跃</h2><p>潜在用户接触产品后，获取用户的职责也就结束了，这时候用户对平台的忠诚度还很低，只有让用户参与到平台中来，他们才会拥护平台，平台才能出现生机。在MVP中留下反馈建议的入口也是为了让用户参与到平台的建设中来，往往能够为平台提意见的用户就是对平台最忠诚的。</p><p>LinkedIn通过优化新用户注册后邀请用户的数量、给好友发邮件的文案和导入邮箱通讯录的方式来一步步的激发了用户活跃，之后又加入了“声誉”系统把不活跃的用户调动起来，才建立了遍布全球的职场平台。</p><p>A/B测试是一种可以从多个备选方案选出较优的一种的解决方法，它常用于减少页面障碍、提升转化率、确定改版方案、新功能的小范围测试。</p><p>在产品中增加游戏化的元素是一种激发活跃的有效手段。现在产品中随处可见的签到、徽章、积分等元素正是游戏化的例证。这些方案不仅促进了用户的活跃度，而且用户也喜欢分享这些游戏化的“里程碑”，从而又能让产品利用社交化的渠道来获取用户。</p><p>此外，除了工具类的产品外，用户之间都会产生交互，这对于一个用户量不够大的产品是一个硬伤，很多产品也都倒在了这里。自动化脚本，或许是一种解决方案，它可以利用提前准备好的程序来和真实的用户沟通。游戏里面的“机器人”、微博等平台的“僵尸粉”都是活生生的例子，但是对脚本的使用也要把握好，不然会让用户产生反感。</p><h2 id="提高留存"><a href="#提高留存" class="headerlink" title="提高留存"></a>提高留存</h2><p>一鸟在手，胜过双鸟在林。在商业社会中5%的客户留存率增长意味着公司利润30%的增长，把产品卖给老客户的概率是卖给新客户的3倍。</p><p>造成用户留存率低的原因包括：</p><ol><li>存在程序漏洞、性能瓶颈。影响正常使用流程的程序漏洞是最容易引发客户流失的原因。淘宝为了满足海量用户的访问需求耗时几年建设了阿里云，12306至今没有完美解决宕机的问题等等。其中，连接超时、卡顿、黑屏、网络卡顿、交互性能差、CPU使用率高、内存泄漏、耗电过多等问题，都会让用户产生反感。</li><li>用户被频繁骚扰。微博在一段时间内对用户频繁推送轰炸，引起一片骂声，现在大多数推送内容都是关注的内容。即刻的出现也是为了解决信息过量的问题。但是，推送和关注量挂钩也对用户的关注行为产生了负面影响，为了避免过多的推送用户不得不谨小慎微的发起关注。经调查，女性用户对推送的容忍度要高于男性。</li><li>话题产品的热度减退。复仇者联盟的上映带火了一批以此为主题的游戏，但是随着话题产品的热度减退，类似产品的热度也会下降，用户又去追寻另一个热点了。</li><li>有更好的替代品。谷歌在国内最终被百度打败，eBay也因为水土不服败给淘宝，小咖秀、美拍等老牌短视频平台被抖音、快手两个后起之秀秒杀等例子先后上演。随着互联网用户增长的乏力，对已有用户的争夺战更加趋于白热化。</li><li>游戏通关、设备遗失、需求不再存在、产品生命周期终结等其他因素。</li></ol><p>留存率的衡量标准：次日留存率、7日留存率、30日留存率，分别反映了不同的含义。渠道留存，反映了在不同渠道的推广效果。</p><p>提高留存的方案：</p><ol><li>优化产品性能。由于网络和设备的性能千差万别，同一款产品在不同设备上的表现可能大相径庭，为了让产品能够在性能较差的设备上表现出较好的体验就需要团队不断优化。</li><li>有损服务。随着用户量的增加，产品所提供的服务容量越来越捉襟见肘，团队的预算也不是无限的，这就要求产品的生产者不得不舍弃一些特性。</li><li>引导新用户快速上手。对刚接触产品的新用户来说，获取产品内容的路径应该是尽量短的，注册、登录的流程应尽量简洁，尤其是首页的布局应该尽量清晰、突出主要功能。社区型产品适当引导新用户关注一些高质量的内容避免空白的瀑布流。</li><li>召回老用户。最有效的方式当属短信、邮件的唤回，内容包括 提供奖励、告知进展、个性化推荐、用户社交互动展示。探探会给老用户发送一条”近期被N个美女喜欢的短息”；招聘类网站会发送正有N个Boss查看JD的短信或邮件。</li></ol><h2 id="增加收入"><a href="#增加收入" class="headerlink" title="增加收入"></a>增加收入</h2><p>我们每天所需的食物和饮料，不是出自屠户、酿酒师或面包师的恩惠，而是出于他们自利的打算。我们不要求助于他们的爱他心，只要求助于他们的自爱心。我们不要向他们说我们必需，只说他们有利。这句出自《国富论》的经典语句，和《影响力》中的论点不谋而合。完美的诠释了“天下熙熙皆为利来，天下攘攘皆为利往”。</p><p>在完全竞争市场，长期产品的市场出清价格等于该产品的边际成本。互联网产品的边际成本极低甚至可以趋近于零。正因为如此，很多产品都采用免费策略来吸引用户。</p><p>免费产品的赚钱方式包括：增值付费、交叉补贴、广告、公司上市或被收购。</p><p>免费模式固然容易被用户接受，但是也这个因为用户的体验成本太低造成了对产品的低忠诚度和低迁移成本。当免费模式获取到过多的用户时，就造成了更多的维护和营销成本，但是纵然有很多的变现模式，想让用户掏第一分钱确是最难的。</p><p>找不到好的变现模式最终可能会拖垮一个产品。陌陌、抖音、豆瓣这些“国民级”的产品都还在变现的道路上艰难摸索，既要维持用户的脆弱心理又要获取盈利的两难局面很难平衡。</p><p>对于一些小而美的产品来说，用户量并不是最主要的，养活自己才是第一要务，因此它们选择了付费模式。在App Store的付费下载中有一些活的很滋润的付费产品。付费产品的门槛高也促进了用户对平台的忠诚度更高，产品拿了用户的钱也有更强的动力为用户提供更好的服务。</p><h2 id="病毒传播"><a href="#病毒传播" class="headerlink" title="病毒传播"></a>病毒传播</h2><p>病毒传播的两大核心指标是K因子和病毒循环周期。K因子=感染率*转化率，感染率是指某个用户向其他人传播产品的程度，转化率是指被感染人转化成新用户的比例。病毒循环周期是指从用户发出邀请，到新用户完成转化所花费的时间。</p><p>病毒传播中的用户心理把握</p><ol><li>人们总是比较愿意答应自己认识和喜欢的人提出的请求，还乐意主动传播自己喜爱的事物。这一点促使一些产品花重金请明星大咖做广告，或引导用户把内容分享到社交群。</li><li>逐利。趣头条的读新闻奖现金就是很好的利用了这一点。</li><li>互惠。拼多多。</li><li>求助。微信小游戏的分享泛滥。</li><li>炫耀。Keep健身打卡分享、英语流利说完成关卡分享、王者荣耀高光时刻分享。</li><li>稀缺。小米的饥饿营销。</li><li>害怕失去或错过。双十一、618。</li></ol><h1 id="个人感悟"><a href="#个人感悟" class="headerlink" title="个人感悟"></a>个人感悟</h1><ol><li>书中多次提高了Hotmail等邮件公司的创业，这些公司最终发展都不错，但是在中国却很少听说独立的邮件公司，或许是因为邮件的沟通方式在美国和中国的地位截然不同，国内互联网起步较晚，跨过了以邮件为主要沟通方式的阶段而直接买入了IM的形式</li><li>看到产品的人中有很少的一部分会成为用户，又会有更少的一部分会留下来，产品最终的收入来自更少的一部分用户。</li><li>从书中描述来看，Facebook为第三方平台提供的信息要比微信等国内平台所提供的丰富的多，这也促成了很多国外的产品借助社交平台发展壮大。从这点来看国内的大平台自信不足。</li><li>流量越来越便宜促进了直播、短视频行业的兴起。</li><li>作为程序员应该尽力优化产品的性能。据亚马逊的统计数据表明，网站的打开时间每多延迟100毫秒，就意味着多造成100万美元的营收损失，这都是真金白银啊。</li><li>书中多次提到了A/B测试和灰度发布，使用这些手段可以有效的避免对大面积用户的影响。作为一名程序员不应该因为这些工作看上去是无用功而产生排斥心理。证明不可行和证明可行同样重要。</li></ol><h1 id="附"><a href="#附" class="headerlink" title="附"></a>附</h1><p><a href="http://image.iosprogrammer.hongbility.com/Books/%E5%A2%9E%E9%95%BF%E9%BB%91%E5%AE%A2.png">思维导图大图</a></p><div><h1>推荐文章<span style="font-size:0.45em; color:gray"></span></h1><ul><li><a href="http://www.iosprogrammer.tech/relation-cmake-gcc-ninja/">一图搞懂Cmake、GCC、Make、Ninja是什么以及他们的关系</a></li><li><a href="http://www.iosprogrammer.tech/Read-Effective-Objective-C-2-0-2/">读《Effective Objective-C 2.0》（二）</a></li><li><a href="http://www.iosprogrammer.tech/Read-Effective-Objective-C-2-0-1/">读《Effective Objective-C 2.0》（一）</a></li></ul></div>]]></content>
      
      
      
        <tags>
            
            <tag> 其他 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>iOS内存管理</title>
      <link href="iOS-Memory-Management/"/>
      <url>iOS-Memory-Management/</url>
      
        <content type="html"><![CDATA[<p>本文内容是对<a href="https://developer.apple.com/library/archive/documentation/Cocoa/Conceptual/MemoryMgmt/Articles/MemoryMgmt.html#//apple_ref/doc/uid/10000011-SW1">Advanced Memory Management Programming Guide</a>中重点内容的总结</p><h2 id="内存管理策略"><a href="#内存管理策略" class="headerlink" title="内存管理策略"></a>内存管理策略</h2><h3 id="基本内存管理规则"><a href="#基本内存管理规则" class="headerlink" title="基本内存管理规则"></a>基本内存管理规则</h3><p>内存管理模型基于对象所有权的。任何对象可能有一个或多个所有者。对象只要有超过一个所有者就会继续存在；如果一个对象没有所有者了，运行时系统就会把它销毁。为了让开发者清楚自己什么时候拥有/不拥有对象，Cocoa设置了一些规则：</p><ul><li>你拥有你创建的对象 - You own any object you create<blockquote><p>使用以”alloc”, “new”, “copy”, “mutableCopy”开头的方法创建对象</p></blockquote></li><li>你可以使用retain来获取对象的所有权<blockquote><p>可以在两种情况下使用<code>retain</code>：（1）在存储器方法的实现或者<code>init</code>方法中，获取要作为属性值存储的对象的所有权；（2）避免某些操作的副作用造成对象不可用</p></blockquote></li><li>当你不再需要的时候，一定要放弃对象所有权<blockquote><p>给对象发送<code>release</code>/<code>autorelease</code>消息来放弃所有权。因此，在Cocoa术语中，把放弃所有权称为”releasing”一个对象</p></blockquote></li><li>一定不能放弃你没有所有权的对象</li></ul><h2 id="内存管理实战"><a href="#内存管理实战" class="headerlink" title="内存管理实战"></a>内存管理实战</h2><h3 id="使用存储器方法来使内存管理更容易"><a href="#使用存储器方法来使内存管理更容易" class="headerlink" title="使用存储器方法来使内存管理更容易"></a>使用存储器方法来使内存管理更容易</h3><p>如果你的类有一个对象属性，你必须确保被设置的对象在使用过程中不会被释放。因此在它被设置的时候，你必须声明对它的所有权。并且你必须确保之后放弃对当前持有值的所有权。虽然这样做有时候是冗长乏味的，但是如果你坚持这种方法，就可以显著减少内存管理问题。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">@interface Counter : NSObject</span><br><span class="line">@property (nonatomic, retain) NSNumber *count;</span><br><span class="line">@end;</span><br></pre></td></tr></table></figure><blockquote><p>这个<code>property</code>声明了一对存取器方法。通常，我们应当让编译器合成这些方法；但是，看一下它们是怎么实现的会很有意义。</p></blockquote><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">- (<span class="built_in">NSNumber</span> *)count &#123;</span><br><span class="line">    <span class="keyword">return</span> _count;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>“get”存取器只是返回了合成的实例变量并不需要<code>retain</code>或者<code>release</code></p></blockquote><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">- (<span class="keyword">void</span>)setCount:(<span class="built_in">NSNumber</span> *)newCount &#123;</span><br><span class="line">    [newCount <span class="keyword">retain</span>];</span><br><span class="line">    [_count release];</span><br><span class="line">    <span class="comment">// Make the new assignment.</span></span><br><span class="line">    _count = newCount;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>“set”存取器需要先<code>retain</code>新值，之后<code>release</code>旧值，最后进行赋值操作。为了避免前后是同一个对象的情况下出现意外的问题，必须要在<code>realse</code>之前调用<code>retain</code>。</p></blockquote><h3 id="不要在初始化和dealloc方法中使用存取器方法"><a href="#不要在初始化和dealloc方法中使用存取器方法" class="headerlink" title="不要在初始化和dealloc方法中使用存取器方法"></a>不要在初始化和dealloc方法中使用存取器方法</h3><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">- init &#123;</span><br><span class="line">    <span class="keyword">self</span> = [<span class="keyword">super</span> init];</span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">self</span>) &#123;</span><br><span class="line">        _count = [[<span class="built_in">NSNumber</span> alloc] initWithInteger:<span class="number">0</span>];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">self</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- initWithCount:(<span class="built_in">NSNumber</span> *)startingCount &#123;</span><br><span class="line">    <span class="keyword">self</span> = [<span class="keyword">super</span> init];</span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">self</span>) &#123;</span><br><span class="line">        _count = [startingCount <span class="keyword">copy</span>];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">self</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (<span class="keyword">void</span>)dealloc &#123;</span><br><span class="line">    [_count release];</span><br><span class="line">    [<span class="keyword">super</span> dealloc];</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="使用弱引用来避免循环引用"><a href="#使用弱引用来避免循环引用" class="headerlink" title="使用弱引用来避免循环引用"></a>使用弱引用来避免循环引用</h3><p>只有当对象的所有强引用都释放后对象才能被释放，如果两个对象互相强引用了彼此，那么它们都不会被释放，这样就造成了<strong>循环引用</strong><br><img src="https://developer.apple.com/library/archive/documentation/Cocoa/Conceptual/MemoryMgmt/Art/retaincycles_2x.png" alt="循环引用"><br>弱引用可以解决循环引用的问题。弱引用是<em>non-owning</em>的关系。为了保持对象至少有一个引用而不被释放，不能把所有引用都设置成弱引用。因此，Cocoa建立了一个惯例，“parent”对象对“children”对象持有强引用，而children对象弱引用parent对象。如上图表示的一样。</p><p>当向弱引用的对象发送消息时一定要消息。如果向已经释放的兑现发送消息时会引起崩溃。这里特别注意的是：通知中心。当向NotificationCenter注册观察者时，通知中心会持有观察者的弱引用，如果观察者释放时没有主动从通知中心移除自己，通知中心会在之后向被释放掉的观察者发送消息，这时候会引起崩溃。（文档中还提到了delegate，但是在ARC下我们使用weak来修饰，就不会引起问题了。）</p><h3 id="避免正在使用的对象被释放"><a href="#避免正在使用的对象被释放" class="headerlink" title="避免正在使用的对象被释放"></a>避免正在使用的对象被释放</h3><p>下面两种情况是需要特别注意的：</p><ol><li><p>当一个对象从集合中移除的时候：</p><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">heisenObject = [array objectAtIndex:n];</span><br><span class="line">[array removeObjectAtIndex:n];</span><br><span class="line"><span class="comment">// heisenObject could now be invalid.</span></span><br></pre></td></tr></table></figure><blockquote><p>对象从集合中移除的时候，会收到<code>release</code>消息（而不是<code>autorelease</code>）。如果集合是对象的唯一持有者，这个对象会被立即释放。</p></blockquote></li><li><p>“parent object”释放</p><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">id</span> parent = &lt;<span class="meta">#create a parent object#&gt;;</span></span><br><span class="line"><span class="comment">// ...</span></span><br><span class="line">heisenObject = [parent child] ;</span><br><span class="line">[parent release]; <span class="comment">// Or, for example: self.parent = nil;</span></span><br><span class="line"><span class="comment">// heisenObject could now be invalid.</span></span><br></pre></td></tr></table></figure><blockquote><p>一个对象是由另一个对象生成的，之后直接或者间接的释放了父对象。如果这个释放导致了父对象的销毁，并且父对象是子对象的唯一持有者，那么子对象也会同时被销毁。</p></blockquote></li></ol><p>要想避免这些情况，我们可以<code>retain heisenObject</code>。比如：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">heisenObject &#x3D; [[array objectAtIndex:n] retain];</span><br><span class="line">[array removeObjectAtIndex:n];</span><br><span class="line">&#x2F;&#x2F; Use heisenObject...</span><br><span class="line">[heisenObject release];</span><br></pre></td></tr></table></figure><h3 id="不要使用dealloc管理稀缺资源"><a href="#不要使用dealloc管理稀缺资源" class="headerlink" title="不要使用dealloc管理稀缺资源"></a>不要使用dealloc管理稀缺资源</h3><p>不要在<code>dealloc</code>方法中管理文件描述符、网络连接、缓存或者缓冲区等稀有资源。特别是，类中的<code>dealloc</code>方法不是你认为会调用的时候就会调用。<code>dealloc</code>的调用可能会由于bug或者应用“tear-down”造成延迟或者不调用。</p><p>相反地，如果你有一个类的实例来管理稀缺资源，你应该把你的应用设计成当资源不在需要的时候调用“clean up”方法来清理资源，之后释放实例，<code>dealloc</code>会紧接着调用，这样的话，即使<code>dealloc</code>没有调用也不会引起其他问题。</p><p>如果在<code>dealloc</code>中管理稀缺资源可能会引起几个问题：</p><ol><li>对象图拆卸的顺序依赖性<br> 对象图的拆卸链是没有固定顺序的。</li><li>不回收稀缺资源<br> 内存泄露是应该被解决的bug，但是他们不会立即致命。如果稀缺资源没有按照预先设计的正常释放，可能会引起更严重的问题。比如，如果应用程序的文件描述符耗尽了，用户可能将无法保存数据。</li><li>在错误的线程上执行清理逻辑<br> 如果一个对象在意外时间自动释放，它将在它碰巧所在的任何线程的自动释放池块中被释放。对于只能从一个线程触及的资源，这中情况是非常严重的问题。</li></ol><h3 id="集合拥有它们包含的对象"><a href="#集合拥有它们包含的对象" class="headerlink" title="集合拥有它们包含的对象"></a>集合拥有它们包含的对象</h3><p>当把一个对象放到集合中（例如array，dictionary，set），集合会持有这个对象。当对象从集合中移除或者集合本身被释放的时候，集合会放弃所有权。因此，如果你想要创建一个“numbers”的数组时，可以这样做：</p><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">NSMutableArray</span> *array = &lt;#Get a <span class="keyword">mutable</span> array#&gt;;</span><br><span class="line"><span class="built_in">NSUInteger</span> i;</span><br><span class="line"><span class="comment">// ...</span></span><br><span class="line"><span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++) &#123;</span><br><span class="line">    <span class="built_in">NSNumber</span> *convenienceNumber = [<span class="built_in">NSNumber</span> numberWithInteger:i];</span><br><span class="line">    [array addObject:convenienceNumber];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这样做，你没有调用<code>alloc</code>，因此不需要调用<code>release</code>。这里也不需要“retain”这些新的numbers，因为数组会这样做。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">NSMutableArray *array &#x3D; &lt;#Get a mutable array#&gt;;</span><br><span class="line">NSUInteger i;</span><br><span class="line">&#x2F;&#x2F; ...</span><br><span class="line">for (i &#x3D; 0; i &lt; 10; i++) &#123;</span><br><span class="line">    NSNumber *allocedNumber &#x3D; [[NSNumber alloc] initWithInteger:i];</span><br><span class="line">    [array addObject:allocedNumber];</span><br><span class="line">    [allocedNumber release];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这种方式需要在<code>for</code>循环内<code>[allocedNumber release]</code>来匹配<code>alloc</code>，否则的话<code>allocedNumber</code>对象的引用计数就无法匹配了。</p><h3 id="所有权策略是使用引用计数来实现的"><a href="#所有权策略是使用引用计数来实现的" class="headerlink" title="所有权策略是使用引用计数来实现的"></a>所有权策略是使用引用计数来实现的</h3><ul><li>创建对象的时候，引用计数为1</li><li>向对象发送<code>retain</code>消息时，引用计数+1</li><li>向对象发送<code>release</code>消息时，引用计数-1。向对象发送<code>autorelease</code>消息时，对象的引用计数会在autorelease pool block的结尾处-1</li><li>引用计数减到0时，对象被销毁</li></ul><blockquote><p>不要使用<code>retainCount</code>来确定对象的引用计数，它是不准确的。应该使用引用计数规则结合代码来判断对象的引用计数。</p></blockquote><h2 id="使用Autorelease-Pool-Blocks"><a href="#使用Autorelease-Pool-Blocks" class="headerlink" title="使用Autorelease Pool Blocks"></a>使用Autorelease Pool Blocks</h2><p>自动释放池提供了一个可以用来<strong>废弃所有权而且又可以避免对象被立即销毁</strong>的机制。通常情况下，我们不需要创建自动释放吃，但是有些情况下必须使用或者如果使用了会提供一些益处。</p><h3 id="关于自动释放池"><a href="#关于自动释放池" class="headerlink" title="关于自动释放池"></a>关于自动释放池</h3><p>自动释放池是使用<code>@autoreleasepool</code>标记的</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">@autoreleasepool &#123;</span><br><span class="line">    &#x2F;&#x2F; Code that creates autorelease objects.</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在自动释放池的结尾，所有收到<code>autorelease</code>消息的对象会被发送<code>release</code>消息。</p><p>和其他的block类似，自动释放池也能够嵌套</p><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">@autoreleasepool</span> &#123;</span><br><span class="line">    <span class="comment">// . . .</span></span><br><span class="line">    <span class="keyword">@autoreleasepool</span> &#123;</span><br><span class="line">        <span class="comment">// . . .</span></span><br><span class="line">    &#125;</span><br><span class="line">    . . .</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>嵌套的自动释放池遵循就近原则。</p><p>Cocoa总是认为所有的代码会在自动释放池的范围内执行，否则的话自动释放的对象就无法被释放了，这样会导致内存泄露。如果有这种情况，Cocoa会打印出适当的错误信息。AppKit和UIKit框架中的事件循环迭代（例如鼠标点击或者用户触摸）都是在自动释放池内的。因此通常情况下，你不需要创建自动释放池。但是，下面的三种情况下，需要自己创建自动释放池：</p><ul><li>编写非UI framework程序时，例如命令行工具</li><li>在需要创建很多临时对象的循环中。在循环中使用自动释放池可以减少内存峰值</li><li>创建第二线程</li></ul><h3 id="使用自动释放池来降低内存峰值"><a href="#使用自动释放池来降低内存峰值" class="headerlink" title="使用自动释放池来降低内存峰值"></a>使用自动释放池来降低内存峰值</h3><p>有些代码需要创建一些自动释放的临时对象。这些对象直到自动释放池结尾处一直都在内存中。有时候这样做不会造成过多的内存提高；有时候这些对象过大就会造成过多的内存提升，而不得不尽快的释放这些临时对象。对于后一种情况，我们可以创建自己的自动释放池，在自动释放池的结尾这些占用内存的对象都会被销毁来节省内存。</p><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">NSArray</span> *urls = &lt;# An array of file URLs #&gt;;</span><br><span class="line"><span class="keyword">for</span> (<span class="built_in">NSURL</span> *url <span class="keyword">in</span> urls) &#123;</span><br><span class="line"> </span><br><span class="line">    <span class="keyword">@autoreleasepool</span> &#123;</span><br><span class="line">        <span class="built_in">NSError</span> *error;</span><br><span class="line">        <span class="built_in">NSString</span> *fileContents = [<span class="built_in">NSString</span> stringWithContentsOfURL:url</span><br><span class="line">                                         encoding:<span class="built_in">NSUTF8StringEncoding</span> error:&amp;error];</span><br><span class="line">        <span class="comment">/* Process the string, creating and autoreleasing more objects. */</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>for</code>循环每次都处理一个文件。在自动释放池中<code>fileContents</code>对象是“autoreleased”，当到达自动释放池的结尾会自动释放。每次都会自动回收内存，就避免了内存占用过多的问题。</p><p>切记，自动释放的对象只要超出最近的自动释放池范围后就会被释放。也就是说，自动释放的对象被释放后就无法继续使用了，不要向这些对象发送消息，也不要把它们作为返回值。例如下面的这种情况：</p><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">– (<span class="keyword">id</span>)findMatchingObject:(<span class="keyword">id</span>)anObject &#123;</span><br><span class="line"> </span><br><span class="line">    <span class="keyword">id</span> match;</span><br><span class="line">    <span class="keyword">while</span> (match == <span class="literal">nil</span>) &#123;</span><br><span class="line">        <span class="keyword">@autoreleasepool</span> &#123;</span><br><span class="line"> </span><br><span class="line">            <span class="comment">/* Do a search that creates a lot of temporary objects. */</span></span><br><span class="line">            match = [<span class="keyword">self</span> expensiveSearchForObject:anObject];</span><br><span class="line"> </span><br><span class="line">            <span class="keyword">if</span> (match != <span class="literal">nil</span>) &#123;</span><br><span class="line">                [match <span class="keyword">retain</span>]; <span class="comment">/* Keep match around. */</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    <span class="keyword">return</span> [match autorelease];   <span class="comment">/* Let match go and return it. */</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>向自动释放池内的<code>match</code>对象发送<code>retain</code>消息来延长它的生命期，这样我们就可以把自动释放池内的对象作为返回值了，同时使用<code>autorelease</code>标记返回值是为了匹配<code>retain</code>的引用计数。</p><h3 id="自动释放池和线程"><a href="#自动释放池和线程" class="headerlink" title="自动释放池和线程"></a>自动释放池和线程</h3><p>每一个Cocoa的应用程序都有自己的自动释放池栈。如果你正在编写只包含Foundation框架的程序，或者自己创建了一个线程，你需要自己创建自动释放池。</p><p>如果应用或线程是长久保存的并且潜在的生成了很多自动释放的对象，这时应该定期的清空并且创建自动释放池（就像 Application Kit 在主线程中做的那样）；否则，对象的积累会增加内存的占用。如果，独立的线程并没有使用 Cocoa 的调用，你没有必要去创建一个自动释放池。</p><blockquote><p>如果使用了 POSIX 线程 APIS 而不是 NSThread 对象来创建线程，你不能使用 Cocoa，包括 NSautoreleasePool，除非 Cocoa 是在多线程模式下，Cocoa 进入了多线程模式只有在首次创建 NSThread 对象的时候，为了在第二个 POSIX 线程中使用 Cocoa ，你的应用必须首先至少创建了一个独立的 NSThread 对象，这个对象可以立即退出。你可以通过 NSThread 类方法 isMultiTheraded 来测试 Cocoa 是否在多线程模式下。</p></blockquote><div><h1>推荐文章<span style="font-size:0.45em; color:gray"></span></h1><ul><li><a href="http://www.iosprogrammer.tech/how-to-make-view-get-intrinsic-content-size/">最佳实践：iOS开发在xib/storyboard中自定义view</a></li><li><a href="http://www.iosprogrammer.tech/What-is-Content-Hugging-Priorities-Content-Compression-Resistance-Priorities/">什么是Content Hugging Priorities/Content Compression Resistance Priorities</a></li><li><a href="http://www.iosprogrammer.tech/UIStackView-Advanced-Knowledge/">UIStackView的正确使用姿势（最新最全、配视频教程）</a></li></ul></div>]]></content>
      
      
      
        <tags>
            
            <tag> iOS </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Objective-C 消息转发</title>
      <link href="Objective-C-Message-Forward/"/>
      <url>Objective-C-Message-Forward/</url>
      
        <content type="html"><![CDATA[<h4 id="一些概念"><a href="#一些概念" class="headerlink" title="一些概念"></a>一些概念</h4><p><strong>静态绑定</strong>：在编译期就能决定运行时所应调用的函数。代表语言：C、C++等<br><strong>动态绑定</strong>：所要调用的函数直到运行期才能确定。代表语言：OC、swift等<br><strong>消息传递</strong>：对象正常解读消息，传递过去<br><strong>消息转发</strong>：对象无法解读消息，之后进行消息转发</p><h4 id="消息处理流程"><a href="#消息处理流程" class="headerlink" title="消息处理流程"></a>消息处理流程</h4><ol><li>OC中调用方法<code>[a method]</code>后都是在执行<code>id objc_msgSend(id receiver, SEL op, ...) </code><blockquote><p><code>id objc_msgSend(id self, SEL op, ...) </code>是一个参数个数可变的函数，第一参数代表接受者，第二个参数代表选择子（OC函数名），之后的参数就是消息中传入的参数。</p></blockquote></li><li>当消息发送给对象时，消息函数跟随对象的isa指针找到类结构，并尝试在cache中搜索类中是否有对应的<code>SEL</code>，如果找到在cache中找到了则直接调用，这种情况下消息发送的耗时和函数调用相差无几</li><li>若cache中搜索失败，则到该类对应的<code>dispatch table</code>中搜寻方法，如果能找到这个跟选择子名称相同的方法，就跳转到其实现代码，往下执行。</li><li>该类的<code>dispatch table</code>中没有找到则继续沿着类层级向上寻找直到NSObject，找到后则进行方法调用并缓存。</li><li>如果最终还是找不到，那就进入消息转发的流程去进行处理。</li></ol><h4 id="消息转发流程"><a href="#消息转发流程" class="headerlink" title="消息转发流程"></a>消息转发流程</h4><p><img src="https://upload-images.jianshu.io/upload_images/424855-83a396fca4f6c206.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="msg_forward.png"></p><ol><li>调用resolveInstanceMethod：征询接受者（所属的类）是否可以添加方法以处理未知的选择子？(此过程称为动态方法解析）若有，转发结束。若没有，走第二步。</li><li>调用forwardingTargetForSelector：询问接受者是否有其他对象能处理此消息。若有，转发结束，一切如常。若没有，走第三步。</li><li>调用forwardInvocation：运行期系统将消息封装到NSInvocation对象中，再给接受者一次机会。</li><li>以上三步还不行，就抛出异常：unrecognized selector sent to instance xxxx</li></ol><h4 id="消息转发实例"><a href="#消息转发实例" class="headerlink" title="消息转发实例"></a>消息转发实例</h4><ol><li><p>在ViewController的头文件中声明一个方法，但是不要在ViewController.m中实现</p> <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">ViewController.h</span><br><span class="line"></span><br><span class="line">#import &lt;UIKit&#x2F;UIKit.h&gt;</span><br><span class="line"></span><br><span class="line">@interface ViewController : UIViewController</span><br><span class="line"></span><br><span class="line">- (void)testForwardMethod;</span><br><span class="line"></span><br><span class="line">@end</span><br></pre></td></tr></table></figure></li><li><p>在AppDelegate中调用ViewController的<code>testForwardMethod </code>方法</p> <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">AppDelegate.m</span><br><span class="line"></span><br><span class="line">[[[ViewController alloc] init] testForwardMethod];</span><br></pre></td></tr></table></figure></li><li><p>这时候编译没有问题，但是运行会出现<code>-[ViewController testForwardMethod]: unrecognized selector sent to instance 0x10581bfe0</code></p></li><li><p>在ViewController.m中增加消息转发的方法</p> <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">ViewController.m</span><br><span class="line"></span><br><span class="line">- (id)forwardingTargetForSelector:(SEL)aSelector</span><br><span class="line">&#123;</span><br><span class="line">    NSLog(@&quot;ViewController forwardingTargetForSelector&quot;);</span><br><span class="line">    return [[TestView alloc] init];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 如果有方法的实现，所有消息转发的过程都不会进行</span><br><span class="line">&#x2F;&#x2F;- (void)testForwardMethod</span><br><span class="line">&#x2F;&#x2F;&#123;</span><br><span class="line">&#x2F;&#x2F;    NSLog(@&quot;ViewController testForwardMethod&quot;);</span><br><span class="line">&#x2F;&#x2F;&#125;</span><br><span class="line"></span><br><span class="line">TestView.m</span><br><span class="line"></span><br><span class="line">- (void)testForwardMethod</span><br><span class="line">&#123;</span><br><span class="line">    NSLog(@&quot;TestView testForwardMethod&quot;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><ul><li>(id)forwardingTargetForSelector:(SEL)aSelector; 把aSelector转发给其他类对象。</li></ul></blockquote></li><li><p>在ViewController.m中增加两个消息转发的方法</p> <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">ViewController.m</span><br><span class="line">  </span><br><span class="line">- (NSMethodSignature *)methodSignatureForSelector:(SEL)aSelector</span><br><span class="line">&#123;</span><br><span class="line">    NSLog(@&quot;ViewController methodSignatureForSelector&quot;);</span><br><span class="line">    if (aSelector &#x3D;&#x3D; @selector(testForwardMethod))</span><br><span class="line">    &#123;</span><br><span class="line">        NSLog(@&quot;ViewController methodSignatureForSelector equal&quot;);</span><br><span class="line">        return [NSMethodSignature signatureWithObjCTypes:&quot;v@:&quot;];</span><br><span class="line">    &#125;</span><br><span class="line">    return [super methodSignatureForSelector:aSelector];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">-  (void)forwardInvocation:(NSInvocation *)anInvocation</span><br><span class="line">&#123;</span><br><span class="line">    NSLog(@&quot;ViewController forwardInvocation:&quot;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><ol><li><code>- (NSMethodSignature *)methodSignatureForSelector:(SEL)aSelector</code>返回一NSMethodSignature对象，该对象包含给定选择器标识的方法的描述。在方法转发过程中如果需要使<code>NSInvocation </code>则就需要使用这个方法</li></ol></blockquote></li><li><p><code>signatureWithObjCTypes:</code>是用C字符串来创建<code>NSMethodSignature</code>对象，详细的描述以看<a href="https://blog.csdn.net/bigtiger1648/article/details/51084957">这篇文章</a></p></li></ol><h4 id="避开动态绑定"><a href="#避开动态绑定" class="headerlink" title="避开动态绑定"></a>避开动态绑定</h4><p>要想不使用OC的动态绑定，唯一的方案是获取到方法地址直接调用。 **这种方案仅适用于 对一个方法重复多次调用，并且对性能敏感 的情况 **</p><ol><li>通过<code>NSObject</code>的<code>methodForSelector</code>获取到方法实现的地址</li><li>使用指针直接调用方法<br>下面是以<code>setFilled:</code>方法为例 <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">void (*setter)(id, SEL, BOOL);</span><br><span class="line">int i;</span><br><span class="line"></span><br><span class="line">setter &#x3D; (void (*)(id, SEL, BOOL))[target</span><br><span class="line">    methodForSelector:@selector(setFilled:)];</span><br><span class="line">for ( i &#x3D; 0 ; i &lt; 1000 ; i++ )</span><br><span class="line">    setter(targetList[i], @selector(setFilled:), YES);</span><br></pre></td></tr></table></figure><blockquote><p><code>methodForSelector</code>不是Objective-C的特性，而是由Cocoa runtime system提供</p></blockquote></li></ol><div><h1>推荐文章<span style="font-size:0.45em; color:gray"></span></h1><ul><li><a href="http://www.iosprogrammer.tech/how-to-make-view-get-intrinsic-content-size/">最佳实践：iOS开发在xib/storyboard中自定义view</a></li><li><a href="http://www.iosprogrammer.tech/What-is-Content-Hugging-Priorities-Content-Compression-Resistance-Priorities/">什么是Content Hugging Priorities/Content Compression Resistance Priorities</a></li><li><a href="http://www.iosprogrammer.tech/UIStackView-Advanced-Knowledge/">UIStackView的正确使用姿势（最新最全、配视频教程）</a></li></ul></div>]]></content>
      
      
      
        <tags>
            
            <tag> iOS </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>跟我一起学习React Native之调用原生模块</title>
      <link href="learn-react-native-with-me-call-native/"/>
      <url>learn-react-native-with-me-call-native/</url>
      
        <content type="html"><![CDATA[<h4 id="写在前面"><a href="#写在前面" class="headerlink" title="写在前面"></a>写在前面</h4><p>这篇文章是“<a href="http://www.iosprogrammer.tech/categories/react-native/">跟我一起学react-native</a>”系列文章的第四篇。这系列文章会随着这个新闻项目的进行更新。想要跟我一起学习React Native的朋友可以关注我的微信公众号<strong>iOS进阶指南</strong>，或者<a href="https://tech.us18.list-manage.com/subscribe?u=340bfbe6219cff7b854f892c2&id=ec1d8e7ba3">订阅</a>我的<a href="http://www.iosprogrammer.tech/">个人博客</a>。</p><h4 id="效果图"><a href="#效果图" class="headerlink" title="效果图"></a>效果图</h4><p><img src="https://upload-images.jianshu.io/upload_images/424855-d0105c3529fc4c43.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/180" alt="Share_WebView.png"></p><h4 id="加载WebView"><a href="#加载WebView" class="headerlink" title="加载WebView"></a>加载WebView</h4><p>通过<a href="https://facebook.github.io/react-native/docs/webview">官方文档</a>可以查看WebView组件的详情。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&lt;WebView</span><br><span class="line">  source&#x3D;&#123;&#123; uri: &#39;https:&#x2F;&#x2F;www.baidu.com&#x2F; &#125;&#125;</span><br><span class="line">  injectedJavaScript&#x3D;&#39;window.postMessage(document.title)&#39;</span><br><span class="line">  onMessage&#x3D;&#123;this.handleMessage&#125;</span><br><span class="line">&#x2F;&gt;</span><br></pre></td></tr></table></figure><blockquote><p><code>source</code>: 要加载的资源；<br><code>injectedJavaScript</code>: 当资源加载完成后要执行的JS<strong>字符串</strong>；<br><code>window.postMessage()</code>会发出一个带有’data’参数的消息；<br><code>onMessage</code>来处理postMessage发出的消息，这里是把页面的title作为navigationBar的title。</p></blockquote><h4 id="调用iOS原生模块"><a href="#调用iOS原生模块" class="headerlink" title="调用iOS原生模块"></a>调用iOS原生模块</h4><p>建议先阅读<a href="https://facebook.github.io/react-native/docs/native-modules-ios">官方文档</a>。这里以调用原生的友盟分享为例。（集成友盟分享和项目中info.plist中的相关设置不是这里的主要内容，有需要的可以百度一下。）</p><ol><li>项目中新建UShare类作为和RN的桥接类。<img src="https://upload-images.jianshu.io/upload_images/424855-a73f85b5f47019ac.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="UShare_Class.png"></li><li>UShare.m<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line">#import &quot;UShare.h&quot;</span><br><span class="line">#import &lt;UMSocialCore&#x2F;UMSocialCore.h&gt;</span><br><span class="line">#import &lt;React&#x2F;RCTBridgeModule.h&gt;</span><br><span class="line"></span><br><span class="line">@interface UShare () &lt;RCTBridgeModule&gt;</span><br><span class="line"></span><br><span class="line">@end</span><br><span class="line"></span><br><span class="line">@implementation UShare</span><br><span class="line">&#x2F;&#x2F; 把UShare模块名暴露给JS</span><br><span class="line">RCT_EXPORT_MODULE();</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; platform: 0 QQ 1 QQ空间 2 微信 3 朋友圈 4 微博</span><br><span class="line">RCT_EXPORT_METHOD(shareToPlatform:(int)platform content:(NSString *)content)</span><br><span class="line">&#123;</span><br><span class="line">  UMSocialPlatformType type &#x3D; UMSocialPlatformType_UnKnown;</span><br><span class="line">  switch (platform)</span><br><span class="line">  &#123;</span><br><span class="line">    case 0:</span><br><span class="line">      type &#x3D; UMSocialPlatformType_QQ;</span><br><span class="line">      break;</span><br><span class="line">    case 1:</span><br><span class="line">      type &#x3D; UMSocialPlatformType_Qzone;</span><br><span class="line">      break;</span><br><span class="line">    case 2:</span><br><span class="line">      type &#x3D; UMSocialPlatformType_WechatSession;</span><br><span class="line">      break;</span><br><span class="line">    case 3:</span><br><span class="line">      type &#x3D; UMSocialPlatformType_WechatTimeLine;</span><br><span class="line">      break;</span><br><span class="line">    case 4:</span><br><span class="line">      type &#x3D; UMSocialPlatformType_Sina;</span><br><span class="line">      break;</span><br><span class="line">  &#125;</span><br><span class="line">&#x2F;&#x2F; 分享一个纯文本内容作为示例</span><br><span class="line">  UMSocialMessageObject *msgObj &#x3D; [UMSocialMessageObject messageObject];</span><br><span class="line">  msgObj.text &#x3D; content;</span><br><span class="line">  [[UMSocialManager defaultManager] shareToPlatform:type messageObject:msgObj currentViewController:[[UIApplication sharedApplication] keyWindow].rootViewController completion:^(id result, NSError *error) &#123;</span><br><span class="line">    </span><br><span class="line">  &#125;];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">@end</span><br></pre></td></tr></table></figure><blockquote><ol><li>桥接类必须遵守<code>RCTBridgeModule </code>协议</li><li>在类的.m文件中添加<code>RCT_EXPORT_MODULE()</code>，这个宏是用来指定暴露给JS的模块名，如果宏中没有参数则使用OC类名，如果OC类名以RCT开头，JS的模块名会去掉前缀。</li><li><code>RCT_EXPORT_METHOD</code>：把OC方法暴露给JS模块的宏。注意：OC方法暴露给JS后，JS的方法名是OC方法名中第一个冒号前面的部分，在这里就是<code>shareToPlatform </code>，而不是<code>shareToPlatform: content :</code>，并且暴露给JS的方法都被认为返回<code>void</code>，如果要返回内容需要使用回调。</li></ol></blockquote></li><li>JS中调用<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">import &#123; NativeModules &#125; from &#39;react-native&#39;</span><br><span class="line"></span><br><span class="line">var share &#x3D; NativeModules.UShare</span><br><span class="line">share.shareToPlatform(platform, &quot;分享测试&quot;)</span><br></pre></td></tr></table></figure></li></ol><p><strong>如果这篇文章能为你提供些许的帮助，我将不胜荣幸。如果你能慷慨的点个赞或者关注我，我将万分感激。</strong></p><div><h1>推荐文章<span style="font-size:0.45em; color:gray"></span></h1><ul><li><a href="http://www.iosprogrammer.tech/learn-react-native-with-me-mine-and-settings/">跟我一起学习React Native之我的和设置</a></li><li><a href="http://www.iosprogrammer.tech/learn-react-native-with-me-project-instruction/">跟我一起学React Native之项目结构搭建</a></li><li><a href="http://www.iosprogrammer.tech/learn-react-native-with-me-questions/">跟我一起学习React Native之遇到的问题和解决方法</a></li></ul></div>]]></content>
      
      
      
        <tags>
            
            <tag> react-native </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>跟我一起学习React Native之我的和设置</title>
      <link href="learn-react-native-with-me-mine-and-settings/"/>
      <url>learn-react-native-with-me-mine-and-settings/</url>
      
        <content type="html"><![CDATA[<h4 id="写在前面"><a href="#写在前面" class="headerlink" title="写在前面"></a>写在前面</h4><p>这篇文章是“<a href="http://www.iosprogrammer.tech/categories/react-native/">跟我一起学react-native</a>”系列文章的第三篇。这系列文章会随着这个新闻项目的进行更新。想要跟我一起学习React Native的朋友可以关注我的微信公众号<strong>iOS进阶指南</strong>，或者订阅我的<a href="http://www.iosprogrammer.tech/">个人博客</a>。</p><h4 id="效果图"><a href="#效果图" class="headerlink" title="效果图"></a>效果图</h4><p><img src="https://upload-images.jianshu.io/upload_images/424855-f451b6cc1f588e6e.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="我的和设置 效果图"></p><h4 id="“我的”界面"><a href="#“我的”界面" class="headerlink" title="“我的”界面"></a>“我的”界面</h4><ol><li><p> 使用sectionList实现类似iOS中group类型的tableView</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">render() &#123;</span><br><span class="line">  return (</span><br><span class="line">    &lt;SectionList style&#x3D;&#123;&#123; backgroundColor: &#39;#eeeeee&#39; &#125;&#125;</span><br><span class="line">      renderItem&#x3D;&#123;this._renderItem&#125;</span><br><span class="line">        renderSectionHeader&#x3D;&#123;(&#123; section: &#123; title &#125; &#125;) &#x3D;&gt; (</span><br><span class="line">          &lt;View style&#x3D;&#123;styles.sectionHeader&#125; &#x2F;&gt;</span><br><span class="line">        )&#125;</span><br><span class="line">        ItemSeparatorComponent&#x3D;&#123;() &#x3D;&gt;</span><br><span class="line">          &lt;View style&#x3D;&#123;&#123; height: 0.5, backgroundColor: &#39;#999999&#39; &#125;&#125; &#x2F;&gt;</span><br><span class="line">        &#125;</span><br><span class="line">        sections&#x3D;&#123;[</span><br><span class="line">          &#123; data: [&#123; id: 0 &#125;] &#125;,</span><br><span class="line">          &#123; data: [&#123; id: 10, name: &#39;关注的新闻&#39;, photo: require(&#39;..&#x2F;..&#x2F;img&#x2F;news.png&#39;) &#125;] &#125;,</span><br><span class="line">          &#123;</span><br><span class="line">            data: [&#123; id: 20, name: &#39;反馈和建议&#39;, photo: require(&#39;..&#x2F;..&#x2F;img&#x2F;feedback.png&#39;) &#125;,</span><br><span class="line">            &#123; id: 21, name: &#39;设置&#39;, photo: require(&#39;..&#x2F;..&#x2F;img&#x2F;setting.png&#39;) &#125;]</span><br><span class="line">          &#125;,</span><br><span class="line">        ]&#125;</span><br><span class="line">        keyExtractor&#x3D;&#123;(item) &#x3D;&gt; item.id&#125;</span><br><span class="line">    &#x2F;&gt;</span><br><span class="line">  )</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>renderItem：渲染每一行；renderSectionHeader：渲染组头视图；  ItemSeparatorComponent：每一行之间的分割线，类似iOS中的separator；sections：数据源。id用来区分不同的行。</p></li><li><p>渲染一行</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line">_renderItem(info) &#123;</span><br><span class="line">  if (info.item.id &#x3D;&#x3D; 0) &#123;</span><br><span class="line">    return (</span><br><span class="line">      &lt;TouchableHighlight onPress&#x3D;&#123;() &#x3D;&gt; self.onPress(info.item)&#125;&gt;</span><br><span class="line">        &lt;View style&#x3D;&#123;styles.personInfo&#125;&gt;</span><br><span class="line">          &lt;Image</span><br><span class="line">            style&#x3D;&#123;styles.avatar&#125;</span><br><span class="line">              source&#x3D;&#123;&#123; uri: &#39;http:&#x2F;&#x2F;image.iosprogrammer.hongbility.com&#x2F;react-native&#x2F;problem-1.png&#39; &#125;&#125;</span><br><span class="line">                resizeMode&#x3D;&#39;cover&#39;</span><br><span class="line">          &#x2F;&gt;</span><br><span class="line">          &lt;View style&#x3D;&#123;styles.nickname&#125;&gt;</span><br><span class="line">            &lt;View style&#x3D;&#123;&#123; flex: 1, justifyContent: &#39;center&#39; &#125;&#125;&gt;</span><br><span class="line">              &lt;Text&gt;登录&#x2F;注册&lt;&#x2F;Text&gt;</span><br><span class="line">            &lt;&#x2F;View&gt;</span><br><span class="line">            &lt;View style&#x3D;&#123;&#123; flex: 1, justifyContent: &#39;center&#39; &#125;&#125;&gt;</span><br><span class="line">              &lt;Text style&#x3D;&#123;&#123; color: &#39;#999999&#39; &#125;&#125;&gt;查看个人主页&lt;&#x2F;Text&gt;</span><br><span class="line">            &lt;&#x2F;View&gt;</span><br><span class="line">          &lt;&#x2F;View&gt;</span><br><span class="line">          &lt;Image</span><br><span class="line">            style&#x3D;&#123;styles.rightArrow&#125;</span><br><span class="line">            source&#x3D;&#123;require(&#39;..&#x2F;..&#x2F;img&#x2F;right_arrow.png&#39;)&#125;</span><br><span class="line">          &#x2F;&gt;</span><br><span class="line">        &lt;&#x2F;View&gt;</span><br><span class="line">      &lt;&#x2F;TouchableHighlight&gt;</span><br><span class="line">    )</span><br><span class="line">  &#125; else &#123;</span><br><span class="line">    return (</span><br><span class="line">      &lt;View style&#x3D;&#123;styles.cell&#125;&gt;</span><br><span class="line">        &lt;SimpleCell</span><br><span class="line">          title&#x3D;&#123;info.item.name&#125;</span><br><span class="line">          photo&#x3D;&#123;info.item.photo&#125;</span><br><span class="line">          onPress&#x3D;&#123;() &#x3D;&gt; self.onPress(info.item)&#125;</span><br><span class="line">        &#x2F;&gt;</span><br><span class="line">      &lt;&#x2F;View&gt;</span><br><span class="line">    )</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>从效果图可以看出，第一组第一行的内容和其他行不相同，因此分开来处理。<br><br>TouchableHighlight：这个组件用来接收用户的点击事件。**<em>只能有一个子节点。否则会报错**</em></p></li></ol><p><strong>注意：</strong>onPress={() =&gt; self.onPress(info.item)} 这里用的是<strong>self</strong>而不是this。self的来源是：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">constructor(props) &#123;</span><br><span class="line">  super(props)</span><br><span class="line">  self &#x3D; this</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>不用this的原因是这里的this表示的不是当前的MeScreen对象，所以如果用this就无法调用到onPress事件。</p><h4 id="“SimpleCell”组件"><a href="#“SimpleCell”组件" class="headerlink" title="“SimpleCell”组件"></a>“SimpleCell”组件</h4>  <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">export default class SimpleCell extends React.Component &#123;</span><br><span class="line">  render() &#123;</span><br><span class="line">    let logo &#x3D; this.props.photo ? &lt;Image style&#x3D;&#123;styles.logo&#125; source&#x3D;&#123;this.props.photo&#125;&#x2F;&gt; : null</span><br><span class="line">    let detail &#x3D; this.props.detail ? &lt;View style&#x3D;&#123;styles.detail&#125;&gt; </span><br><span class="line">    &lt;Text style&#x3D;&#123;&#123;color: &#39;#999999&#39;&#125;&#125;&gt;&#123;this.props.detail&#125;&lt;&#x2F;Text&gt; &lt;&#x2F;View&gt; : null</span><br><span class="line">    return (</span><br><span class="line">      &lt;TouchableHighlight underlayColor&#x3D;&#39;#999&#39; onPress&#x3D;&#123;this.props.onPress&#125;&gt;</span><br><span class="line">        &lt;View style&#x3D;&#123;styles.container&#125;&gt;</span><br><span class="line">          &#123;logo&#125;</span><br><span class="line">          &lt;View style&#x3D;&#123;styles.titleView&#125;&gt;</span><br><span class="line">            &lt;Text&gt;&#123;this.props.title&#125;&lt;&#x2F;Text&gt;</span><br><span class="line">          &lt;&#x2F;View&gt;</span><br><span class="line">          &#123;detail&#125;</span><br><span class="line">          &lt;Image style&#x3D;&#123;styles.rightArrow&#125;</span><br><span class="line">            source&#x3D;&#123;require(&#39;..&#x2F;..&#x2F;img&#x2F;right_arrow.png&#39;)&#125;</span><br><span class="line">          &#x2F;&gt;</span><br><span class="line">        &lt;&#x2F;View&gt;</span><br><span class="line">      &lt;&#x2F;TouchableHighlight&gt;</span><br><span class="line">    )</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>“我的”中的cell前面有icon，“设置”里面没有，因此这里根据条件判断是否显示。</p><p>如遇到问题可以参考<a href="http://www.iosprogrammer.tech/learn-react-native-with-me-questions">遇到的问题和解决方案</a></p><div><h1>推荐文章<span style="font-size:0.45em; color:gray"></span></h1><ul><li><a href="http://www.iosprogrammer.tech/learn-react-native-with-me-call-native/">跟我一起学习React Native之调用原生模块</a></li><li><a href="http://www.iosprogrammer.tech/learn-react-native-with-me-project-instruction/">跟我一起学React Native之项目结构搭建</a></li><li><a href="http://www.iosprogrammer.tech/learn-react-native-with-me-questions/">跟我一起学习React Native之遇到的问题和解决方法</a></li></ul></div>]]></content>
      
      
      
        <tags>
            
            <tag> react-native </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>跟我一起学React Native之项目结构搭建</title>
      <link href="learn-react-native-with-me-project-instruction/"/>
      <url>learn-react-native-with-me-project-instruction/</url>
      
        <content type="html"><![CDATA[<h4 id="写在前面"><a href="#写在前面" class="headerlink" title="写在前面"></a>写在前面</h4><p>这篇文章是“<a href="http://www.iosprogrammer.tech/categories/react-native/">跟我一起学react-native</a>”系列文章的第二篇。这系列文章会随着这个新闻项目的进行更新。想要跟我一起学习React Native的朋友可以关注我的微信公众号<strong>iOS进阶指南</strong>，或者订阅我的<a href="http://www.iosprogrammer.tech/">个人博客</a>。</p><p><a href="%5Bhttp://www.iosprogrammer.tech/learn-react-native-with-me-construction/%5D(http://www.iosprogrammer.tech/learn-react-native-with-me-construction/)">上一篇文章</a>讲了React Native的环境搭建过程，本篇文章将讨论“水滴新闻”项目结构的搭建。</p><h4 id="最终效果"><a href="#最终效果" class="headerlink" title="最终效果"></a>最终效果</h4><p><img src="https://upload-images.jianshu.io/upload_images/424855-c3242548a1c76b6b.gif?imageMogr2/auto-orient/strip" alt="效果"></p><h4 id="项目文件结构"><a href="#项目文件结构" class="headerlink" title="项目文件结构"></a>项目文件结构</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">rn_shuidi</span><br><span class="line">　| - - - - - - - App.js</span><br><span class="line">　| - - - - - - - app.json</span><br><span class="line">　| - - - - - - - index.js</span><br><span class="line">　| - - - - - - - node_modules</span><br><span class="line">　| - - - - - - - shuidi</span><br><span class="line">　　| - - - - - - - home</span><br><span class="line">　　　| - - - - - - - HomeScreen.js</span><br><span class="line">　　　| - - - - - - - NodeScreen.js</span><br><span class="line">　　| - - - - - - - attention</span><br><span class="line">　　| - - - - - - - me</span><br><span class="line">　| - - - - - - - android</span><br><span class="line">　| - - - - - - - ios</span><br><span class="line">　| - - - - - - - img</span><br><span class="line">　　| - - - - - - - home_normal.png</span><br><span class="line">　　| - - - - - - - home_selected.png</span><br><span class="line">　| - - - - - - - package.json</span><br></pre></td></tr></table></figure><h4 id="react-navigation"><a href="#react-navigation" class="headerlink" title="react-navigation"></a>react-navigation</h4><p>因为项目中包含多个页面，页面之间切换要使用TabBar和Navigation，因此要使用react-navigation这个框架。<br>安装react-navigation </p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">cd rn_shuidi</span><br><span class="line">npm install react-navigation</span><br></pre></td></tr></table></figure><h4 id="Navigation"><a href="#Navigation" class="headerlink" title="Navigation"></a>Navigation</h4><p>下面以“主页为例”创建navigation</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">App.js</span><br><span class="line"></span><br><span class="line">import &#123; createStackNavigator, createBottomTabNavigator &#125; from &#39;react-navigation&#39;</span><br><span class="line">import HomeScreen from &#39;.&#x2F;shuidi&#x2F;home&#x2F;HomeScreen&#39;</span><br><span class="line">import NodeScreen from &#39;.&#x2F;shuidi&#x2F;home&#x2F;NodeScreen&#39;</span><br><span class="line"></span><br><span class="line">const HomeStack &#x3D; createStackNavigator(&#123;</span><br><span class="line">    Home: &#123; screen: HomeScreen &#125;,</span><br><span class="line">    Nodes: &#123; screen: NodeScreen &#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><p>StackNavigation可类比为iOS中的UINavigation，是一种栈类型的导航结构。<br><br><br>Home和Nodes分别是导航中的两个页面（控制器）。这里的名字会在执行导航行为的时候使用到。<br><br><br>screen参数是要放在导航中的页面。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">HomeScreen.js</span><br><span class="line">constructor(props) &#123;</span><br><span class="line">    super(props)</span><br><span class="line">    this.state &#x3D; &#123; text: &#39;old&#39; &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">static navigationOptions &#x3D; &#123;</span><br><span class="line">    title: &#39;主页&#39;,</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">&lt;Text&gt;&#123;this.state.text&#125;&lt;&#x2F;Text&gt;</span><br><span class="line"></span><br><span class="line">&lt;Button</span><br><span class="line">    title&#x3D;&quot;Go to NodeScreen&quot;</span><br><span class="line">    onPress&#x3D;&#123;() &#x3D;&gt; &#123;</span><br><span class="line">            this.props.navigation.navigate(&#39;Nodes&#39;, &#123;</span><br><span class="line">           title: &#39;测试节点&#39;, callback: ((data) &#x3D;&gt; &#123;</span><br><span class="line">           this.setState(&#123; text: data &#125;)</span><br><span class="line">         &#125;)</span><br><span class="line">      &#125;)</span><br><span class="line">   &#125;&#125;</span><br><span class="line">&#x2F;&gt;</span><br></pre></td></tr></table></figure><p>navigationOptions是对导航的配置，这里设置了title。相当于<code>self.title=&quot;主页&quot;</code></p><p>点击“Go to NodeScreen”这个<code>Button</code>后会跳转到标签为“Nodes”的页面，如果App.js的<code>HomeStack</code>中不包含“Nodes”标签则不会跳转。</p><p>title和callback分别是传递到“Nodes”页面的参数。其中callback是一个回调，用来进行反向传值。当“Nodes”页面以“data”为参数回调callback之后，<code>this.setState</code>保存接受到的参数，当前页面就会随之改变。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">NodeScreen.js</span><br><span class="line"></span><br><span class="line">static navigationOptions &#x3D; (&#123; navigation &#125;) &#x3D;&gt; &#123;</span><br><span class="line">    return &#123;</span><br><span class="line">        title: navigation.getParam(&#39;title&#39;, &#39;节点&#39;),</span><br><span class="line">    &#125;;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">const callback &#x3D; navigation.getParam(&#39;callback&#39;)</span><br><span class="line"></span><br><span class="line">&lt;Button</span><br><span class="line">    title&#x3D;&quot;反向传值测试&quot;</span><br><span class="line">    onPress&#x3D;&#123;() &#x3D;&gt; &#123;</span><br><span class="line">        this.props.navigation.goBack(),</span><br><span class="line">        callback(&#39;我是反向传值&#39;)</span><br><span class="line">    &#125;&#125;</span><br><span class="line">&#x2F;&gt;</span><br></pre></td></tr></table></figure><p><code>navigation.getParam(&#39;title&#39;, &#39;节点&#39;)</code>获取<code>navigation</code>中的<code>title</code>参数。</p><p>点击“反向传值测试”，回到上一级页面，之后调用callback，把字符串“我是反向传值”传递到上一级页面。</p><p><strong>TabBar</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line">App.js</span><br><span class="line"></span><br><span class="line">createBottomTabNavigator(</span><br><span class="line">  &#123;</span><br><span class="line">    Home: HomeStack,</span><br><span class="line">    Attention: AttentionStack,</span><br><span class="line">    Me: MeStack</span><br><span class="line">  &#125;,</span><br><span class="line">  navigationOptions: (&#123; navigation &#125;) &#x3D;&gt; (&#123;</span><br><span class="line">    tabBarLabel: (&#123;focused, tintColor&#125;) &#x3D;&gt; &#123;</span><br><span class="line">      const &#123; routeName &#125; &#x3D; navigation.state</span><br><span class="line">      var title &#x3D; &#39;&#39;</span><br><span class="line">      if (routeName &#x3D;&#x3D;&#x3D; &#39;Home&#39;) &#123;</span><br><span class="line">        title &#x3D; &#39;主页&#39;</span><br><span class="line">      &#125; else if (routeName &#x3D;&#x3D;&#x3D; &#39;Attention&#39;) &#123;</span><br><span class="line">        title &#x3D; &#39;关注&#39;</span><br><span class="line">      &#125; else &#123;</span><br><span class="line">        title &#x3D; &#39;我&#39;</span><br><span class="line">      &#125;</span><br><span class="line">      return &lt;Text&gt;&#123;title&#125;&lt;&#x2F;Text&gt;</span><br><span class="line">    &#125;,</span><br><span class="line">    tabBarIcon: (&#123; focused, tintColor &#125;) &#x3D;&gt; &#123;</span><br><span class="line">      const &#123; routeName &#125; &#x3D; navigation.state;</span><br><span class="line">      var iconName &#x3D; &#39;&#39;;</span><br><span class="line">      if (routeName &#x3D;&#x3D;&#x3D; &#39;Home&#39;) &#123;</span><br><span class="line">        iconName &#x3D; focused ? require(&#39;.&#x2F;img&#x2F;home_selected.png&#39;) : requi(&#39;.&#x2F;img&#x2F;home_normal.png&#39;)</span><br><span class="line">      &#125; else if (routeName &#x3D;&#x3D;&#x3D; &#39;Attention&#39;) &#123;</span><br><span class="line">        iconName &#x3D; focused ? require(&#39;.&#x2F;img&#x2F;attention_selected.png&#39;) : requi(&#39;.&#x2F;img&#x2F;attention_normal.png&#39;)</span><br><span class="line">      &#125; else &#123;</span><br><span class="line">        iconName &#x3D; focused ? require(&#39;.&#x2F;img&#x2F;me_selected.png&#39;) : requi(&#39;.&#x2F;img&#x2F;me_normal.png&#39;)</span><br><span class="line">      &#125;</span><br><span class="line">      return &lt;Image </span><br><span class="line">        source&#x3D;&#123;iconName&#125;</span><br><span class="line">        style&#x3D;&#123;&#123; width: 26, height: 26 &#125;&#125;</span><br><span class="line">      &gt;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;),</span><br><span class="line">  tabBarOptions: &#123;</span><br><span class="line">    activeTintColor: &#39;blue&#39;,</span><br><span class="line">    inactiveTintColor: &#39;black&#39;,</span><br><span class="line">  &#125;</span><br><span class="line">)</span><br></pre></td></tr></table></figure><p><code>tabBarLabel</code>和<code>tabBarIcon</code>分别是当前标签页显示的标题和图片，其中图片根据<code>focused</code>展示不同内容。</p><h4 id="在navigationbar的子页面中隐藏tabbar"><a href="#在navigationbar的子页面中隐藏tabbar" class="headerlink" title="在navigationbar的子页面中隐藏tabbar"></a>在navigationbar的子页面中隐藏tabbar</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">HomeStack.navigationOptions &#x3D; (&#123; navigation &#125;) &#x3D;&gt; &#123;</span><br><span class="line">let tabBarVisible &#x3D; true;</span><br><span class="line">if (navigation.state.index &gt; 0) &#123;</span><br><span class="line">tabBarVisible &#x3D; false;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">return &#123;</span><br><span class="line">tabBarVisible,</span><br><span class="line">&#125;;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>至此，项目结构搭建完成了。这个过程中如遇到问题可以参考<a href="http://www.iosprogrammer.tech/learn-react-native-with-me-questions">遇到的问题和解决方案</a>🎉🎉🎉</p><p>因为MarkDown解析的问题，排版不好，请见谅。</p><div><h1>推荐文章<span style="font-size:0.45em; color:gray"></span></h1><ul><li><a href="http://www.iosprogrammer.tech/learn-react-native-with-me-call-native/">跟我一起学习React Native之调用原生模块</a></li><li><a href="http://www.iosprogrammer.tech/learn-react-native-with-me-mine-and-settings/">跟我一起学习React Native之我的和设置</a></li><li><a href="http://www.iosprogrammer.tech/learn-react-native-with-me-questions/">跟我一起学习React Native之遇到的问题和解决方法</a></li></ul></div>]]></content>
      
      
      
        <tags>
            
            <tag> react-native </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>跟我一起学习React Native之遇到的问题和解决方法</title>
      <link href="learn-react-native-with-me-questions/"/>
      <url>learn-react-native-with-me-questions/</url>
      
        <content type="html"><![CDATA[<p>这篇文章是“<a href="http://www.iosprogrammer.tech/categories/react-native/">跟我一起学react-native</a>”系列文章的答疑篇。这系列文章会持续更新。想要跟我一起学习RN的朋友可以关注我的微信公众号iOS进阶指南，或者订阅<a href="http://www.iosprogrammer.tech/">我的个人博客</a>。</p><ol><li>No bundle URL present.<br><br><br> <img src="http://image.iosprogrammer.hongbility.com/react-native/problem-1.png" alt="No bundle URL present"><br><br><blockquote><ul><li>Run “react-native run-ios”</li><li>When the error appears, run “npm install”</li><li>Then run “react-native run-ios” again.</li></ul></blockquote></li><li>isMounted(…) is deprecated in plain JavaScript React classes…</li><li>Class RCTCxxModule was not exported. Did you forget to use RCT_EXPORT_MODULE()?<br>这两个目前没找到好的解决办法，暂时隐藏警告吧，以后找到好的办法再更新。<br>这个问题在react-navigation的github主页里面有一个<a href="https://github.com/react-navigation/react-navigation/issues/3956">专门的issue</a>，但是根据react-navigation的开发者说这个是react-native内部调用了废弃的方法所至。<br>目前大家的统一解决办法是在index.js文件中添加<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">import &#123; YellowBox &#125; from &#39;react-native&#39;;</span><br><span class="line">YellowBox.ignoreWarnings([&#39;Warning: isMounted(...) is deprecated&#39;, &#39;Module RCTImageLoader&#39;]);</span><br><span class="line">YellowBox.ignoreWarnings([&#39;Class RCTCxxModule&#39;]);</span><br></pre></td></tr></table></figure></li><li>Image加载不出来，onload不执行的问题。<br>iOS 8以上，默认不支持HTTP。需要在info.plist中设置App Transport Security Settings -&gt; Allow Arbitray Loads = YES</li><li>RCTBridge required dispatch_sync to load RCTDevLoadingView. This may lead to deadlocks.<br>APPDelegate.m<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line">...</span><br><span class="line">#if RCT_DEV</span><br><span class="line">#import &lt;React&#x2F;RCTDevLoadingView.h&gt;</span><br><span class="line">#endif</span><br><span class="line"></span><br><span class="line">@implementation AppDelegate</span><br><span class="line"></span><br><span class="line">- (BOOL)application:(UIApplication *)application didFinishLaunchingWithOptions:(NSDictionary *)launchOptions</span><br><span class="line">&#123;</span><br><span class="line">  NSURL *jsCodeLocation;</span><br><span class="line"></span><br><span class="line">  jsCodeLocation &#x3D; [[RCTBundleURLProvider sharedSettings] jsBundleURLForBundleRoot:@&quot;index&quot; fallbackResource:nil];</span><br><span class="line">  </span><br><span class="line">  RCTBridge *bridge &#x3D; [[RCTBridge alloc] initWithBundleURL:jsCodeLocation</span><br><span class="line">                                            moduleProvider:nil</span><br><span class="line">                                             launchOptions:launchOptions];</span><br><span class="line">#if RCT_DEV</span><br><span class="line">  [bridge moduleForClass:[RCTDevLoadingView class]];</span><br><span class="line">#endif</span><br><span class="line"></span><br><span class="line">  RCTRootView *rootView &#x3D; [[RCTRootView alloc] initWithBridge:bridge moduleName:@&quot;rn_shuidi&quot; initialProperties:launchOptions];</span><br><span class="line">  rootView.backgroundColor &#x3D; [[UIColor alloc] initWithRed:1.0f green:1.0f blue:1.0f alpha:1];</span><br><span class="line"></span><br><span class="line">  self.window &#x3D; [[UIWindow alloc] initWithFrame:[UIScreen mainScreen].bounds];</span><br><span class="line">  UIViewController *rootViewController &#x3D; [UIViewController new];</span><br><span class="line">  rootViewController.view &#x3D; rootView;</span><br><span class="line">  self.window.rootViewController &#x3D; rootViewController;</span><br><span class="line">  [self.window makeKeyAndVisible];</span><br><span class="line">  return true;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ol><div><h1>推荐文章<span style="font-size:0.45em; color:gray"></span></h1><ul><li><a href="http://www.iosprogrammer.tech/learn-react-native-with-me-call-native/">跟我一起学习React Native之调用原生模块</a></li><li><a href="http://www.iosprogrammer.tech/learn-react-native-with-me-mine-and-settings/">跟我一起学习React Native之我的和设置</a></li><li><a href="http://www.iosprogrammer.tech/learn-react-native-with-me-project-instruction/">跟我一起学React Native之项目结构搭建</a></li></ul></div>]]></content>
      
      
      
        <tags>
            
            <tag> react-native </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>跟我一起学习React Native之环境搭建</title>
      <link href="learn-react-native-with-me-construction/"/>
      <url>learn-react-native-with-me-construction/</url>
      
        <content type="html"><![CDATA[<p>这篇文章是“<a href="http://www.iosprogrammer.tech/categories/react-native/">跟我一起学react-native</a>”系列文章的第一篇。这系列文章会持续更新。想要跟我一起学习React Native的朋友可以关注我的微信公众号<strong>iOS进阶指南</strong>，或者订阅<a href="http://www.iosprogrammer.tech/">我的个人博客</a>。</p><h3 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h3><p>最近想要做一款新闻类的App，主要特点是把新闻事件按照时间线整理出来方便跟踪事情的发展。</p><p>作为一个雷（xia）厉（bi）风（dao）行（gu）的程序员肯定说干就干。</p><p>俗话说不想火的应用不是好App，想要更多的用户肯定不能只局限于一个平台，那就要让这个应用同时登陆安卓和iOS两个平台。但是我作为一个万年iOSer，现在从头开始学安卓恐怕有点不赶趟了。</p><p>根据当前敌我态势和恶劣的环境，跨平台开发成为了最优选择。</p><p>那怎么样达到跨平台开发的目的呢？根据百度爸爸的指导和以往的所见所闻，就要在阿里的weex和Facebook的react-native中二选一了。</p><p>从这篇文章的标题来看，大家肯定知道要选rn，其实最开始我选的是weex，奈何经过三四天的奋战和四处求教，我实在是没有搞定环境，在这里不得不说weex的官方文档真的可以称为简陋，当然我可能是因为我前几天手贱把Mac的系统升级到了Mojave。</p><p>在不得不放弃weex以后，只能🙏RN能给点面子。多亏上天眷顾，环境稍微折腾了一下就搞定了。</p><h3 id="环境搭建"><a href="#环境搭建" class="headerlink" title="环境搭建"></a>环境搭建</h3><ol><li><p>安装Node和Watchman</p> <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">brew install node</span><br><span class="line">brew install watchman</span><br></pre></td></tr></table></figure><p> 其中，node需要是8或者更新的版本。Watchman是Facebook用来监视文件系统更改的工具，RN强烈建议使用。</p></li><li><p>安装React Native command line interface.</p> <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm install -g react-native-cli</span><br></pre></td></tr></table></figure></li><li><p>创建项目</p> <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">react-native init rn-test</span><br></pre></td></tr></table></figure></li><li><p>运行项目</p> <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">cd rn-test</span><br><span class="line">react-native run-ios</span><br></pre></td></tr></table></figure><p> 项目默认会在iPhone 6的模拟器上运行。<br><br> <img src="http://image.iosprogrammer.hongbility.com/react-native/new-project-screenshot.png" alt="iPhone 6 Screenshot"><br><br> 至此，环境搭建完成，这个过程中如遇到问题可以参考<a href="http://www.iosprogrammer.tech/learn-react-native-with-me-questions">遇到的问题和解决方案</a></p></li></ol><div><h1>推荐文章<span style="font-size:0.45em; color:gray"></span></h1><ul><li><a href="http://www.iosprogrammer.tech/learn-react-native-with-me-call-native/">跟我一起学习React Native之调用原生模块</a></li><li><a href="http://www.iosprogrammer.tech/learn-react-native-with-me-mine-and-settings/">跟我一起学习React Native之我的和设置</a></li><li><a href="http://www.iosprogrammer.tech/learn-react-native-with-me-project-instruction/">跟我一起学React Native之项目结构搭建</a></li></ul></div>]]></content>
      
      
      
        <tags>
            
            <tag> react-native </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>WebSocket简介和SocketRocket源码分析</title>
      <link href="WebSocket-And-SocketRocket-Source-Analysis/"/>
      <url>WebSocket-And-SocketRocket-Source-Analysis/</url>
      
        <content type="html"><![CDATA[<p><a href="http://www.iosprogrammer.tech/iOS-SocketRocket/">之前的文章</a>讲了SocketRocket的用法，这里讲一下什么是WebSocket并且对SocketRocket的源码进行分析。</p><h3 id="WebSocket"><a href="#WebSocket" class="headerlink" title="WebSocket"></a>WebSocket</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">The WebSocket Protocol is an independent TCP-based protocol.&lt;br&gt;Its only relationship to HTTP is that its handshake is interpreted by HTTP servers as an Upgrade request.</span><br></pre></td></tr></table></figure><div align=center><img src="http://image.iosprogrammer.hongbility.com/WebSocket-SocketRocket-Source/6651f2f811ec133b0e6d7e6d0e194b4c_hd.jpg"></div><p>WebSocket的特点:</p><pre><code>1. 建立在 TCP 协议之上，服务器端的实现比较容易。2. 与 HTTP 协议有着良好的兼容性。默认端口也是80和443，并且握手阶段采用 HTTP 协议，因此握手时不容易屏蔽，能通过各种 HTTP 代理服务器。3. 数据格式比较轻量，性能开销小，通信高效。4. 可以发送文本，也可以发送二进制数据。5. 没有同源限制，客户端可以与任意服务器通信。6. 协议标识符是ws（如果加密，则为wss），服务器网址就是URL。`ws://example.com:80/some/path`7. 全双工通信。</code></pre><p>WebSocket握手类似于HTTP：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">GET &#x2F;chat HTTP&#x2F;1.1</span><br><span class="line">Host: server.example.com</span><br><span class="line">Upgrade: websocket</span><br><span class="line">Connection: Upgrade</span><br><span class="line">Sec-WebSocket-Key: x3JJHMbDL1EzLkh9GBhXDw&#x3D;&#x3D;</span><br><span class="line">Sec-WebSocket-Protocol: chat, superchat</span><br><span class="line">Sec-WebSocket-Version: 13</span><br><span class="line">Origin: http:&#x2F;&#x2F;example.com</span><br></pre></td></tr></table></figure><blockquote><p>Upgrade和Connection是在通知Apache或者Nginx等代理服务器，正在进行的是websocket协议连接而不是普通的HTTP。<br><br>Sec-WebSocket-Key是浏览器随机生成的base64编码值，用来验证服务器是不是真正的websocket。<br> Sec_WebSocket-Protocol 是一个用户定义的字符串，用来区分同URL下，不同的服务所需要的协议。<br> Sec-WebSocket-Version 是告诉服务器所使用的协议版本。</p></blockquote><p>服务器验证通过后会返回：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">HTTP&#x2F;1.1 101 Switching Protocols</span><br><span class="line">Upgrade: websocket</span><br><span class="line">Connection: Upgrade</span><br><span class="line">Sec-WebSocket-Accept: HSmrc0sMlYUkAGmm5OPpG2HaGWk&#x3D;</span><br><span class="line">Sec-WebSocket-Protocol: chat</span><br></pre></td></tr></table></figure><blockquote><p>Upgrade和Connection的作用同样是为了表明进行的是websocket连接。<br><br>Sec-WebSocket-Accept 这个则是经过服务器确认，并且加密过后的 Sec-WebSocket-Key，用来给客户端验证身份。<br><br>Sec-WebSocket-Protocol 则是表示最终使用的协议。</p></blockquote><p>数据帧：<br><br><img src="http://image.iosprogrammer.hongbility.com/WebSocket-SocketRocket-Source/frame_form.png" alt="数据帧格式"></p><div align=center><font color="gray" size="2">数据帧格式</font></div><ol><li><p>不同于其他协议，WebSocket是基于帧的而不是基于流<br></p></li><li><p>字段解释:</p><ol><li>FIN: 1 bit 表示是否是当前信息的最后一段</li><li>RSV1, RSV2, RSV3: 1 bit 除非双方协商定义了非0值，否则为0</li><li>Opcode: 4 bits 定义了数据包的类型，如果不是已定义类型则表示连接出错。定义的数据类型包括: 0x0表示中间数据包；0x1表示text类型数据包；0x2表示binary类型数据包；0x3-7保留；0x8表示连接关闭；0x9表示ping；0xA表示pong；0xB-F保留</li><li>MASK：1 bit 表示Payload是否经过掩码处理。MASK如果是1，Masking-Key的数据即是掩码密钥，用于解码PayloadData。客户端发出的数据帧需要进行掩码处理，所以此为是1。</li><li>Payload length：7 bit，7+16 bits，or 7+64 bits 表示payload data的长度，如果其值是0-125，则是payload的真实长度；如果是126，则后面的2个字节形成的16bits无符号整型数的值是payload的真实长度；如果是127，则后面8个字节形成的64bits无符号整型数的值是payload的真实长度。</li></ol></li><li><p>掩码</p><ol><li>掩码值必须是随机的32-bit值</li><li>掩码值并不会影响Payload data的长度。</li><li>掩码算法：掩码后的第i字节数据 = 掩码前的第i字节的数据 XOR 掩码key的第（i mod 4）字节的数据</li></ol></li></ol><h3 id="SocketRocket源码解析"><a href="#SocketRocket源码解析" class="headerlink" title="SocketRocket源码解析"></a>SocketRocket源码解析</h3><ol start="0"><li><p>辅助类简单说明</p><ol><li><text>_SRRunLoopThread</text>: 承载和处理所有事件的线程。通过<code>NSRunLoop (SRWebSocket)</code>把这个线程放到了RunLoop里。并且在<code>- (void)main</code>中使用一个while循环使这个线程正常情况下永不停止。</li><li>SRIOConsumer和SRIOConsumerPool: 用来处理收到的消息。</li></ol></li><li><p>主要方法说明</p><ol><li><p><code>- (id)initWithURLRequest:(NSURLRequest *)request protocols:(NSArray *)protocols allowsUntrustedSSLCertificates:(BOOL)allowsUntrustedSSLCertificates</code> 基本初始化方法。初始化了SRSocket类内的几个成员变量。</p></li><li><p><code>_SR_commonInit</code></p><ol><li>判断协议类型</li><li>初始化了_workQueue，这个GCD队列用来处理主要的业务逻辑，包括处理错误、发送内容、关闭连接等。</li><li>初始化_delegateDispatchQueue，这个队列是用来向外发送通知的。我们可以通过<code>- (void)setDelegateOperationQueue:(NSOperationQueue*) queue</code>或<code>- (void)setDelegateDispatchQueue:(dispatch_queue_t) queue</code>来自定义这个队列。</li></ol></li><li><p><code>_initializeStreams</code> 创建输入/出流</p></li><li><p><code>open</code>/<code>openConnection</code> 这两个方法和被他们调用的方法是用来配置并打开流的</p></li><li><p><code>didConnect</code></p><ol><li>构建HTTP Header</li><li>发送HTTP Header</li><li>注册一个接收服务器返回Header信息的监听，并在回调内进行相应处理</li></ol></li><li><p><code>- (void)safeHandleEvent:(NSStreamEvent)eventCode stream:(NSStream *)aStream</code></p><ol><li>这是NSStream的回调方法，输入和输出流的共同回调</li><li><code>NSStreamEventOpenCompleted</code> 连接打开；<code>NSStreamEventHasBytesAvailable</code> 可读取；<code>NSStreamEventHasSpaceAvailable</code> 可写入数据</li><li>在<code>NSStreamEventOpenCompleted</code>里面的<code>[self _pumpScanner];</code>用来触发第5条中的3，来处理服务器返回的握手Header信息</li></ol></li><li><p><code>_pumpWriting</code></p><ol><li>向输出流写数据<code>[_outputStream write:_outputBuffer.bytes + _outputBufferOffset maxLength:dataLength - _outputBufferOffset]</code></li><li><code>if (_outputBufferOffset &gt; 4096 &amp;&amp; _outputBufferOffset &gt; (_outputBuffer.length &gt;&gt; 1)) &#123; _outputBuffer = [[NSMutableData alloc] initWithBytes:(char *)_outputBuffer.bytes + _outputBufferOffset length:_outputBuffer.length - _outputBufferOffset]; _outputBufferOffset = 0; &#125;</code> 当缓存超过4M时清空</li></ol></li><li><p><code>- (void)_sendFrameWithOpcode:(SROpCode)opcode data:(id)data</code> 把数据组装成符合协议要求的格式。参考“数据帧格式”的图片。</p><ol><li>向frame_buffer中写入fin/opcode字段</li><li>写入mask字段</li><li>根据要发送的数据得到未掩码数据<code>unmasked_payload</code></li><li>使用<code>int SecRandomCopyBytes(SecRandomRef rnd, size_t count, void *bytes);</code>得到掩码key<code>mask_key</code></li><li>根据mask_key和unmasked_payload得到掩码后数据并切入frame_buffer</li></ol></li><li><p><code>_HTTPHeadersDidFinish</code> 处理服务器返回的握手信息。通过对服务器返回的握手信息的分析来判断连接是否成功打开。</p></li><li><p><code>_innerPumpScanner</code> 处理收到的数据，读取未读数据，并且把未读数据通过<code>consumer.handler(self, slice);</code>返回给consumer来解析数据内容。</p></li><li><p><code>- (void)_handleFrameWithData:(NSData *)frameData opCode:(NSInteger)opcode</code> 根据opCode对收到的数据进行分类处理</p></li><li><p><code>- (void)_readFrameContinue</code> 这个是主要的数据处理方法。整个数据结构的处理的过程就是按照WebSocket协议的规定来的。</p></li></ol></li></ol><p>到此，SocketRocket的源码分析就结束了。其中一些地方说的比较啰嗦，有些地方说的可能不够详细。大家在看源码的时候一定要对照着WebSocket的协议内容。如果有不清楚的地方欢迎咨询。有说的不对的地方也欢迎指正。<br></p><p>祝你早日走上人生巅峰!!!</p><h3 id="参考文章"><a href="#参考文章" class="headerlink" title="参考文章"></a>参考文章</h3><p><a href="http://www.ruanyifeng.com/blog/2017/05/websocket.html">阮一峰的网络日志</a><br><br><a href="https://www.zhihu.com/question/20215561">知乎</a><br><br><a href="https://tools.ietf.org/html/rfc6455">RFC6455 WebSocket Protocol</a></p><div><h1>推荐文章<span style="font-size:0.45em; color:gray"></span></h1><ul><li><a href="http://www.iosprogrammer.tech/how-to-make-view-get-intrinsic-content-size/">最佳实践：iOS开发在xib/storyboard中自定义view</a></li><li><a href="http://www.iosprogrammer.tech/What-is-Content-Hugging-Priorities-Content-Compression-Resistance-Priorities/">什么是Content Hugging Priorities/Content Compression Resistance Priorities</a></li><li><a href="http://www.iosprogrammer.tech/UIStackView-Advanced-Knowledge/">UIStackView的正确使用姿势（最新最全、配视频教程）</a></li></ul></div>]]></content>
      
      
      
        <tags>
            
            <tag> iOS </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Mac OS/iOS中日历、备忘录、提醒事项的使用以及使用iMessage共享屏幕</title>
      <link href="Calendar-Notes-Reminders/"/>
      <url>Calendar-Notes-Reminders/</url>
      
        <content type="html"><![CDATA[<p>既然花了上万元买了一台苹果的设备就要好好利用。本篇文章让我们学习一下iPhone/Mac自带的几个APP的使用。</p><h2 id="一-日历"><a href="#一-日历" class="headerlink" title="一. 日历"></a>一. 日历</h2><p>这部分我直接用电脑上的截图，和手机上的是一样的不用担心。<br><br><strong>日常使用</strong>：我们学校的课程表是外包给一个科技公司，可以自动导入日历的，安卓的也可以。如果其他朋友没有这种服务的话，需要添加课程表的话就看看有没有特殊的软件可以导入。实在不行就手动导入了，日程是可以设置循环周期的。<br><img src="http://image.iosprogrammer.hongbility.com/Calendar-Notes-Reminders/calendar-1.jpg" alt="课表"><br><strong>团队协作</strong>：比如我会给我同事发日历，开会时间，并且设置了提前一天和提前6小时提醒，怕有些人会忘记= =。这个功能在使用之前需要把同事们的绑定iCloud的手机号/邮箱地址存入通讯录中，添加名字的时候直接输入参加会议的成员名字，对方即可收到通知（前提是对方打开了日历的通知）<br><img src="http://image.iosprogrammer.hongbility.com/Calendar-Notes-Reminders/calendar-2.jpg" alt="团队协作"><br><strong>时间管理</strong>的好习惯：我放假回家和同学频繁聚餐约饭，我甚至把每顿饭时间地点人物提前写在日历上提醒自己（对，我基本不放人家鸽子，答应的事情除非天塌下来才会爽约）<br><img src="http://image.iosprogrammer.hongbility.com/Calendar-Notes-Reminders/calendar-3.jpg"></p><h2 id="二、备忘录"><a href="#二、备忘录" class="headerlink" title="二、备忘录"></a>二、备忘录</h2><p><strong>日常使用</strong>：我已经不把这个东西当备忘录了，已经是我的随身笔记本了。（其实英文版的系统就叫Note）<br><img src="http://image.iosprogrammer.hongbility.com/Calendar-Notes-Reminders/notes-1.jpg"><br><strong>多种媒体/多种形式的文件支持</strong>：图片、手绘、扫描文件、插入文件（例如pdf.）、表格、地图、音频、视频，而且在mac上截图后直接粘贴是相当方便的。<br><img src="http://image.iosprogrammer.hongbility.com/Calendar-Notes-Reminders/notes-2.jpg" alt="多种文件格式支持"><br><img src="http://image.iosprogrammer.hongbility.com/Calendar-Notes-Reminders/notes-4.jpg" alt="表格功能"><br><img src="http://image.iosprogrammer.hongbility.com/Calendar-Notes-Reminders/notes-8.jpg" alt="烧烤list"></p><p><strong>团队协作</strong>：同样又是iCloud账号共享给好友，可以同时修改同一份文案，实时的协作。另一个人有改动你马上可以看到，宛如直播同事码字一样。可以打开提醒和高亮显示所有修改，这样修改的部分一目了然。<br><img src="http://image.iosprogrammer.hongbility.com/Calendar-Notes-Reminders/notes-11.jpg"><br><strong>排版也像Word一样好用</strong>：选项要么在最顶部的状态栏里面，要么就选中词以后单击右键会调出更多选项，只有你想不到，没有备忘录做不到。（这些特殊功能要Mac才可以实现，手机端不可调整，仅可以做除了这个部分的功能）<br><img src="http://image.iosprogrammer.hongbility.com/Calendar-Notes-Reminders/notes-12.jpg" alt="顶部状态栏"><br><img src="http://image.iosprogrammer.hongbility.com/Calendar-Notes-Reminders/notes-13.jpg" alt="排版"><br><strong>快捷的“拷贝”功能</strong>：当两台苹果设备同时协作的时候，打开蓝牙和wifi功能，不管是否连接，打开就好（这个原理类似于内联网？我问了一个学计算机的同学）。需要拷贝的文字或者图片，图片得在原生的“照片”软件中拷贝（如下图）；文字的话直接复制即可。然后在想粘贴的地方粘贴即可。<br><img src="http://image.iosprogrammer.hongbility.com/Calendar-Notes-Reminders/notes-14.jpg" alt="拷贝"></p><h2 id="三、提醒事项"><a href="#三、提醒事项" class="headerlink" title="三、提醒事项"></a>三、提醒事项</h2><p><strong>提醒你做固定周期、固定时间和固定地点必须要做但是又怕忘记的的事情</strong>。比如提醒每天做法语作业，运动，记账，固定时间吃药等。在 设置——通知——提醒事项 里面，检查下通知是否是出现。有些事情要坚持下来，不是说没时间做，是态度问题或者说是优先级排序的问题，就是你重不重视它，如果有个人或者软件来提醒你的话，每天坚持做某件事情不再是一件难事。<br><img src="http://image.iosprogrammer.hongbility.com/Calendar-Notes-Reminders/reminders-2.jpg" alt="日常提醒"><br><img src="http://image.iosprogrammer.hongbility.com/Calendar-Notes-Reminders/reminders-5.jpg" alt="日常提醒"></p><h2 id="四、iMessage共享屏幕"><a href="#四、iMessage共享屏幕" class="headerlink" title="四、iMessage共享屏幕"></a>四、iMessage共享屏幕</h2><ol><li>在Mac上的“信息”应用中，给您要与之共享的联系人发送信息，然后点按“详细信息”</li><li>点按“屏幕共享”按钮，然后执行以下一项操作。</li></ol><ul><li><p>共享屏幕：选取“邀请共享我的屏幕”</p></li><li><p>查看您朋友给的屏幕：选取“请求共享屏幕”</p><p>当共享屏幕请求被允许后，系统会自动开始音频通话（这样你们可以边说边做）且“屏幕共享”应用将打开。</p></li></ul><ol start="3"><li>若要停止共享屏幕，请执行以下一项操作</li></ol><ul><li>如果正在共享您的屏幕：点按菜单栏中的屏幕共享图标，选取“结束屏幕共享”。（如果您尚未准备好停止共享，请选取“暂停屏幕共享”；再次选取该按钮以继续共享。）</li><li>如果正在查看您朋友的屏幕：选取“屏幕共享”&gt;“退出”，或者点按屏幕共享窗口中的红色关闭按钮。</li></ul><h4 id="如果您不能共享屏幕"><a href="#如果您不能共享屏幕" class="headerlink" title="如果您不能共享屏幕"></a>如果您不能共享屏幕</h4><p>在 Mac 上的“信息”应用  中，如果“屏幕共享”按钮  呈灰色，请尝试以下操作：<br>确保尝试进行共享的联系人用来登录 iCloud 的 Apple ID 与用来登录“信息”的相同。<br>如果联系人无法使用同一个 Apple ID 登录 iCloud 和“信息”，请打开您的“通讯录”应用，确保该联系人的名片中包含了两个 Apple ID，即该联系人用于登录 iCloud 的 Apple ID 以及登录“信息”的 Apple ID。然后再次尝试共享。</p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>iCloud真的是苹果的黑科技，如果你买了苹果产品没有充分用到iCloud功能，真的很浪费钱啊，这个肯定是算在售价里面的。购买并使用苹果产品，更多情况下我理解为买他们的服务和操作系统，因为比起Windows真的太好用了。<br><br>把你的日常事务电子化，并且存储在云端，实时同步，不受地域限制。<br><br>如果苹果系统本身有原生app的，就别去下别的软件了，比如印象笔记、有道云笔记等（个人观点），支持苹果原生app的理由：</p><ol><li>简约，操作不繁琐 </li><li>其他app功能大同小异，操作繁琐，有些功能不实用，还有广告，苹果的打开直接</li><li>兼容性强，可以共享给很多app </li><li>可以在你的多个设备上同步</li></ol><div><h1>推荐文章<span style="font-size:0.45em; color:gray"></span></h1><ul><li><a href="http://www.iosprogrammer.tech/relation-cmake-gcc-ninja/">一图搞懂Cmake、GCC、Make、Ninja是什么以及他们的关系</a></li><li><a href="http://www.iosprogrammer.tech/Read-Effective-Objective-C-2-0-2/">读《Effective Objective-C 2.0》（二）</a></li><li><a href="http://www.iosprogrammer.tech/Read-Effective-Objective-C-2-0-1/">读《Effective Objective-C 2.0》（一）</a></li></ul></div>]]></content>
      
      
      
        <tags>
            
            <tag> 其他 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>把域名提交到百度资源平台</title>
      <link href="Submit-Domain-To-Baidu/"/>
      <url>Submit-Domain-To-Baidu/</url>
      
        <content type="html"><![CDATA[<p>上一篇<a href="http://www.iosprogrammer.tech/deploy-hexo-to-gitlab/">博客</a>讲了怎么把Hexo博客部署到Gitlab。</p><h3 id="本文的目的"><a href="#本文的目的" class="headerlink" title="本文的目的"></a>本文的目的</h3><p>作为一个开发者写博客的目的除了记录知识和自己的想法外就是分享。要把我们的博客分享出去最好的办法就是让其他人可以通过搜索引擎查找到。</p><p>那么怎么让如此忙碌的搜索引擎知道咱们呢？其实每一个搜索引擎都有一个让广大站长们提交链接的地方，比如<a href="https://ziyuan.baidu.com/">百度资源平台</a>。</p><p>下面跟着我来把博客提交到百度吧。</p><h3 id="正文"><a href="#正文" class="headerlink" title="正文"></a>正文</h3><h4 id="向百度提交域名"><a href="#向百度提交域名" class="headerlink" title="向百度提交域名"></a>向百度提交域名</h4><ol><li>打开<a href="https://ziyuan.baidu.com/">百度资源平台</a>并注册/登录百度账号。</li><li>打开<a href="https://ziyuan.baidu.com/site/index">用户中心的站点管理页面</a></li><li>填写要添加的站点<img src="http://image.iosprogrammer.hongbility.com/Submit-Domain-To-Baidu/add-site-input.png"><blockquote><p>建议以www开头</p></blockquote></li><li>根据实际情况选择站点属性。最多选择3个且30天只能修改一次。</li><li>验证网站所有权<img src="http://image.iosprogrammer.hongbility.com/Submit-Domain-To-Baidu/add-set-owner.png"> <blockquote><p>我使用的是CNAME验证，在阿里云配置CNAME<img src="http://image.iosprogrammer.hongbility.com/Submit-Domain-To-Baidu/add-site-owner-cname.png"></p></blockquote></li></ol><h4 id="向百度提交链接"><a href="#向百度提交链接" class="headerlink" title="向百度提交链接"></a>向百度提交链接</h4><ol><li>打开<a href="https://ziyuan.baidu.com/linksubmit/index">提交链接</a></li><li>提交方式分为自动提交和主动提交两大类，自动提交又分成主动推送、自动推送、sitemap三类。<blockquote><p>1、主动推送：最为快速的提交方式，推荐您将站点当天新产出链接立即通过此方式推送给百度，以保证新链接可以及时被百度收录。<br><br>2、自动推送：最为便捷的提交方式，请将自动推送的JS代码部署在站点的每一个页面源代码中，部署代码的页面在每次被浏览时，链接会被自动推送给百度。可以与主动推送配合使用。 <br><br>3、sitemap：您可以定期将网站链接放到sitemap中，然后将sitemap提交给百度。百度会周期性的抓取检查您提交的sitemap，对其中的链接进行处理，但收录速度慢于主动推送。 <br><br>4、手动提交：一次性提交链接给百度，可以使用此种方式。<br><br><br>效率比较：主动推送 &gt; 自动推送 &gt; sitemap</p></blockquote></li><li>主动推送<ol><li>安装插件<code>npm install hexo-baidu-url-submit --save</code></li><li>在博客的根目录中新增字段<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"># 提交链接给百度 主动推送</span><br><span class="line">baidu_url_submit:</span><br><span class="line"> count: 100 # 提交最新的一个链接</span><br><span class="line"> host: www.iosprogrammer.tech # 在百度站长平台中注册的域名</span><br><span class="line"> token: xxxxx # 请注意这是您的秘钥， 所以请不要把博客源代码发布在公众仓库里!</span><br><span class="line"> path: baidu_urls.txt # 文本文档的地址， 新链接会保存在此文本文档里</span><br></pre></td></tr></table></figure></li><li>在博客的根目录中加入新的deploy<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">deploy:</span><br><span class="line">- type:baidu_url_submitter</span><br></pre></td></tr></table></figure></li><li>验证一下public/baidu_url.txt文件中的链接域名是不是正确。 </li><li>执行<code>hexo deploy</code>的时候，新的链接就会被推送了</li></ol></li><li>自动推送<ol><li>在博客的主题配置中（如thmes/next/_config.ymml）将baidu_push设置为true<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"># Enable baidu push so that the blog will push the url to baidu automatically which is very helpful for SEO</span><br><span class="line">baidu_push: true</span><br></pre></td></tr></table></figure></li><li>查看thems/next/layout_scripts/baidu_push.swig文件是否存在，如果不存在就创建<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">&#123;% if theme.baidu_push %&#125;</span><br><span class="line">&lt;script&gt;</span><br><span class="line">(function()&#123;</span><br><span class="line">   var bp &#x3D; document.createElement(&#39;script&#39;);</span><br><span class="line">   var curProtocol &#x3D; window.location.protocol.split(&#39;:&#39;)[0];</span><br><span class="line">   if (curProtocol &#x3D;&#x3D;&#x3D; &#39;https&#39;) &#123;</span><br><span class="line">       bp.src &#x3D; &#39;https:&#x2F;&#x2F;zz.bdstatic.com&#x2F;linksubmit&#x2F;push.js&#39;;</span><br><span class="line">   &#125;</span><br><span class="line">   else &#123;</span><br><span class="line">       bp.src &#x3D; &#39;http:&#x2F;&#x2F;push.zhanzhang.baidu.com&#x2F;push.js&#39;;</span><br><span class="line">   &#125;</span><br><span class="line">   var s &#x3D; document.getElementsByTagName(&quot;script&quot;)[0];</span><br><span class="line">   s.parentNode.insertBefore(bp, s);</span><br><span class="line">&#125;)();</span><br><span class="line">&lt;&#x2F;script&gt;</span><br><span class="line">&#123;% endif %&#125;</span><br></pre></td></tr></table></figure></li><li>如果有人打开了页面就会把相应的链接推给百度。</li></ol></li></ol><h3 id="执行一次hexo-deploy。链接提交到百度以后需要等几天才能被收录。可以通过site-你提交到百度的链接查看是否被收录，也可以到百度资源平台查看"><a href="#执行一次hexo-deploy。链接提交到百度以后需要等几天才能被收录。可以通过site-你提交到百度的链接查看是否被收录，也可以到百度资源平台查看" class="headerlink" title="执行一次hexo deploy。链接提交到百度以后需要等几天才能被收录。可以通过site:你提交到百度的链接查看是否被收录，也可以到百度资源平台查看"></a>执行一次<code>hexo deploy</code>。链接提交到百度以后需要等几天才能被收录。可以通过<code>site:你提交到百度的链接</code>查看是否被收录，也可以到<a href="http://ziyuan.baidu.com/">百度资源平台</a>查看</h3><h3 id="参考链接"><a href="#参考链接" class="headerlink" title="参考链接"></a>参考链接</h3><p><a href="https://blog.csdn.net/sunshine940326/article/details/70936988">hexo高阶教程：想让你的博客被更多的人在搜索引擎中搜到吗？</a></p><div><h1>推荐文章<span style="font-size:0.45em; color:gray"></span></h1><ul><li><a href="http://www.iosprogrammer.tech/relation-cmake-gcc-ninja/">一图搞懂Cmake、GCC、Make、Ninja是什么以及他们的关系</a></li><li><a href="http://www.iosprogrammer.tech/Read-Effective-Objective-C-2-0-2/">读《Effective Objective-C 2.0》（二）</a></li><li><a href="http://www.iosprogrammer.tech/Read-Effective-Objective-C-2-0-1/">读《Effective Objective-C 2.0》（一）</a></li></ul></div>]]></content>
      
      
      
        <tags>
            
            <tag> 其他 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>部署hexo到gitlab并自定义域名</title>
      <link href="deploy-hexo-to-gitlab/"/>
      <url>deploy-hexo-to-gitlab/</url>
      
        <content type="html"><![CDATA[<h1 id="部署Hexo到Gitlab"><a href="#部署Hexo到Gitlab" class="headerlink" title="部署Hexo到Gitlab"></a>部署Hexo到Gitlab</h1><ul><li>Hexo + GtHub：起初想要把这个博客放到Github上，但是由于Github不让百度爬取。</li><li>Hexo + Coding.net：后来又尝试了 coding.net，在使用coding.net的过程中遇到了一些坑。<ul><li>普通会员不能自定义域名 -&gt; 申请成为白银会员（使用腾讯云授权）</li><li>微信等方式登录腾讯云后，授权失败（不知原因） -&gt; 使用腾讯云直接登录 -&gt; 授权成功，成为白银会员，可以自定义域名</li><li>首次打开会显示5s的coding.net广告，后跳转到博客，据说这样的话无法被百度收录 -&gt; 充值199/年 成为黄金会员（我没有充）</li></ul></li></ul><h3 id="Hexo-Gitlab"><a href="#Hexo-Gitlab" class="headerlink" title="Hexo + Gitlab"></a>Hexo + Gitlab</h3><ol><li><p>在原来的博客根目录中新建一个<code>.gitlab-ci.yml</code>：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">before_script:</span><br><span class="line">  - apt-get update -qq &amp;&amp; apt-get install -y -qq pandoc</span><br><span class="line">image: node:9.8.0</span><br><span class="line">pages:</span><br><span class="line">  cache:</span><br><span class="line">    paths:</span><br><span class="line">    - node_modules&#x2F;</span><br><span class="line">  script:</span><br><span class="line">  - npm install hexo-cli -g</span><br><span class="line">  - npm install</span><br><span class="line">  - hexo deploy</span><br><span class="line">  artifacts:</span><br><span class="line">    paths:</span><br><span class="line">    - public</span><br><span class="line">  only:</span><br><span class="line">  - master</span><br></pre></td></tr></table></figure><blockquote><p>这里需要注意，<strong>image: node:9.8.0</strong> node的版本 <strong><em>不是2.2.0</em></strong>，9.8.0这个版本是我当前安装的版本，其他的版本我没有试过。</p></blockquote></li><li><p>在博客的根目录的配置文件<code>_config.yml</code>中，把deploy下推送到github的相关内容删掉。这是因为在gitlab的自动部署过程中会执行推送github的操作，为了不用配置用户名和密码相关配置，建议删除。</p></li><li><p>在gitlab中新建仓库，过程省略。</p></li><li><p>把博客内容push到上一步新建的仓库中，过程省略。</p></li><li><p>查看gitlab中项目的CI/CD -&gt; Piplines，这时候应该处于Padding状态，等几分钟，状态变成了Success。<br><img src="http://image.iosprogrammer.hongbility.com/deploy-hexo-to-gitlab-CI:CD.png"></p></li><li><p>查看Setting -&gt; Pages可以看到gitlab给我们分配的链接，访问链接可以看到我们的博客。</p></li></ol><p>部署到gitlab成功 🎉🎉🎉</p><h3 id="自定义域名"><a href="#自定义域名" class="headerlink" title="自定义域名"></a>自定义域名</h3><p>Setting -&gt; Pages页面中可以通过NewDomain来自定义域名<br><img src="http://image.iosprogrammer.hongbility.com/deploy-hexo-to-gitlab/pages.png" alt="pages"><br>如果你的域名不支持HTTPS请不要勾选<code>Force domain with SSL...</code>点击<code>New domain</code>可以添加指定域名，添加域名后会看到如下页面：<br><img src="http://image.iosprogrammer.hongbility.com/deploy-hexo-to-gitlab/domain.png" alt="domain"><br>上图中绿色的<code>verified</code>是因为我已经验证完成了，如果没有验证完成应该是黄色的。验证过程为分别在云服务商处添加CNAME和TXT域名解析，因为我使用的是阿里云服务器，下面贴出来阿里云上的解析结果：<br><img src="http://image.iosprogrammer.hongbility.com/deploy-hexo-to-gitlab/DNS.png" alt="DNS"><br>其中TXT解析的内容就是<code>Verifycation status</code>的内容。<br>CNAME和TXT解析设置完成后需要等几分钟才会生效，生效后可以在本地电脑的终端中查看结果，正确的结果如下：<br><img src="http://image.iosprogrammer.hongbility.com/deploy-hexo-to-gitlab/dns-result.png" alt="dns-result"></p><p>自定义域名成功 🎉🎉🎉</p><h3 id="最终效果"><a href="#最终效果" class="headerlink" title="最终效果"></a>最终效果</h3><p><img src="http://image.iosprogrammer.hongbility.com/deploy-hexo-to-gitlab/success.png" alt="success"></p><h3 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h3><p><a href="https://www.youtube.com/watch?v=TWqh9MtT4Bg">gitlab官方youtube视频</a><br><a href="http://stevenshi.me/2017/06/26/hexo-insert-formula/">Steven Shi的博客</a></p><p>👍👍👍</p><div><h1>推荐文章<span style="font-size:0.45em; color:gray"></span></h1><ul><li><a href="http://www.iosprogrammer.tech/hexo-blog-logo-gzh-recommend/">3个快速提高Hexo博客访问量的方法</a></li><li><a href="http://www.iosprogrammer.tech/insert-math-formula-to-hexo/">向hexo博客中插入数学公式</a></li><li><a href="http://www.iosprogrammer.tech/Hexo%E5%9C%A8%E6%96%87%E7%AB%A0%E6%9C%AB%E5%B0%BE%E6%B7%BB%E5%8A%A0%E8%87%AA%E5%AE%9A%E4%B9%89%E5%86%85%E5%AE%B9/">Hexo在文章末尾添加自定义内容</a></li></ul></div>]]></content>
      
      
      
        <tags>
            
            <tag> Hexo博客 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>iOS直播APP的开发——拉流</title>
      <link href="iOS-Pull-Live-Stream/"/>
      <url>iOS-Pull-Live-Stream/</url>
      
        <content type="html"><![CDATA[<h3 id="播放器：IJKPlayer"><a href="#播放器：IJKPlayer" class="headerlink" title="播放器：IJKPlayer"></a>播放器：IJKPlayer</h3><ul><li>github地址：<a href="https://github.com/Bilibili/ijkplayer">https://github.com/Bilibili/ijkplayer</a></li><li>下载、编译过程<ul><li> git clone <a href="https://github.com/Bilibili/ijkplayer.git">https://github.com/Bilibili/ijkplayer.git</a> ijkplayer-ios</li><li>cd ijkplayer-ios</li><li>git checkout -B latest k0.8.8</li><li>./init-ios.sh</li><li>cd ios</li><li>./compile-ffmpeg.sh clean</li><li>./compile-ffmpeg.sh all</li></ul></li><li>编译过程中遇到的问题：<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">.&#x2F;libavutil&#x2F;arm&#x2F;asm.S:50:9: error: unknown directive</span><br><span class="line">        .arch armv7-a</span><br><span class="line">        ^</span><br><span class="line">make: *** [libavcodec&#x2F;arm&#x2F;aacpsdsp_neon.o] Error 1</span><br></pre></td></tr></table></figure></li><li>解决：<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">最新的 Xcode 已经弱化了对 32 位的支持, 解决方法: 在 compile-ffmpeg.sh 中删除 armv7 , 修改:FF_ALL_ARCHS_IOS8_SDK&#x3D;&quot;arm64 i386 x86_64&quot; 再重新执行出现错误的命令: .&#x2F;compile-ffmpeg.sh all</span><br></pre></td></tr></table></figure><h3 id="获取-framework"><a href="#获取-framework" class="headerlink" title="获取.framework"></a>获取.framework</h3></li></ul><ol><li>打开<code>IJKMediaPlayer.xcodeproj</code></li><li>选择真机</li><li>切换到Release模式</li><li>cmd+B 编译项目</li><li>获取/Product目录下的<code>IJKMediaFramework.framework</code>，并拷贝</li></ol><h3 id="获取rtmp直播流"><a href="#获取rtmp直播流" class="headerlink" title="获取rtmp直播流"></a>获取rtmp直播流</h3><p>我使用charles抓包到《鱼水直播》的推荐列表链接：<a href="http://api.chujianapp.com/live/get_hot_list?app_version=6.3.0&amp;bundle_id=fish.livezb.wte&amp;device=ios&amp;device_id=7ED19CAE-E21F-44BF-98DC-F5346E64E502&amp;device_idfa=51C0FC66-54C0-4F69-91E4-4C168698D1F5&amp;device_model=iPhone%206s&amp;device_version=iOS11.3.1&amp;pkg_channel=ys19&amp;secure_key=bd54628575ff36bd7695519218f6934f&amp;server_upgrade=1&amp;time_stamp=1525858044919&amp;token=18231046%7C227842b7058bc5dad052bc6d8834e68f%7C1525858019&amp;uid=18231046">http://api.chujianapp.com/live/get_hot_list?app_version=6.3.0&amp;bundle_id=fish.livezb.wte&amp;device=ios&amp;device_id=7ED19CAE-E21F-44BF-98DC-F5346E64E502&amp;device_idfa=51C0FC66-54C0-4F69-91E4-4C168698D1F5&amp;device_model=iPhone%206s&amp;device_version=iOS11.3.1&amp;pkg_channel=ys19&amp;secure_key=bd54628575ff36bd7695519218f6934f&amp;server_upgrade=1&amp;time_stamp=1525858044919&amp;token=18231046%7C227842b7058bc5dad052bc6d8834e68f%7C1525858019&amp;uid=18231046</a><br>从这个链接中可以得到rtmp流</p><h3 id="新建一个OC-Demo项目"><a href="#新建一个OC-Demo项目" class="headerlink" title="新建一个OC Demo项目"></a>新建一个OC Demo项目</h3><p>1. 把<code>IJKMediaFramework.framework</code>拷贝到项目目录中<br>2. 在<code>ViewController.m</code>中<code>#import &lt;IJKMediaFramework/IJKFFMoviePlayerController.h&gt;</code>，并且在<code>viewDidLoad</code>中添加如下代码：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">NSURL *playerURL &#x3D; [NSURL URLWithString:@&quot;rtmp:\&#x2F;\&#x2F;pili-live-rtmp.chujianapp.com\&#x2F;ragingfire\&#x2F;1663091115258475730&quot;];</span><br><span class="line">    IJKFFMoviePlayerController *playerVC &#x3D; [[IJKFFMoviePlayerController alloc] initWithContentURL:playerURL withOptions:nil];</span><br><span class="line">    [playerVC prepareToPlay];</span><br><span class="line">    playerVC.view.frame &#x3D; CGRectMake(30, 20, [UIScreen mainScreen].bounds.size.width * 2 &#x2F; 3, [UIScreen mainScreen].bounds.size.height * 2 &#x2F; 3);</span><br><span class="line">    playerVC.view.backgroundColor &#x3D; [UIColor grayColor];</span><br><span class="line">    [self.view insertSubview:playerVC.view atIndex:1];</span><br></pre></td></tr></table></figure><h3 id="运行项目"><a href="#运行项目" class="headerlink" title="运行项目"></a>运行项目</h3><p>(o゜▽゜)o☆[BINGO!]</p><h3 id="参考链接"><a href="#参考链接" class="headerlink" title="参考链接"></a>参考链接</h3><p><a href="https://www.jianshu.com/p/9743a68c2939">https://www.jianshu.com/p/9743a68c2939</a></p><p>👍👍👍</p><div><h1>推荐文章<span style="font-size:0.45em; color:gray"></span></h1><ul><li><a href="http://www.iosprogrammer.tech/Android-FFmpeg-Cannot-find-a-valid-font-for-the-family-Sans/">Android FFmpeg Cannot find a valid font for the family Sans</a></li></ul></div>]]></content>
      
      
      
        <tags>
            
            <tag> 音视频 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>日期Date和时间Time（三）- 一个简单的日历</title>
      <link href="Date-And-Time-Three/"/>
      <url>Date-And-Time-Three/</url>
      
        <content type="html"><![CDATA[<p>在前面两篇中讲到了日期和时间的基础知识，现在让我们来利用学到的基础知识创建一个简单的日历。</p><h3 id="最终效果"><a href="#最终效果" class="headerlink" title="最终效果"></a>最终效果</h3><p><img src="http://image.iosprogrammer.hongbility.com/Date-And-Time-Three/%E6%9C%80%E7%BB%88%E6%95%88%E6%9E%9C.png"><br>输入指定的年份和月份后可以得到对应月份的日历。</p><h3 id="主要代码"><a href="#主要代码" class="headerlink" title="主要代码"></a>主要代码</h3><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/// 某个月的所有天</span></span><br><span class="line"><span class="comment">///</span></span><br><span class="line"><span class="comment">/// - Parameter year: 年份</span></span><br><span class="line"><span class="comment">/// - Parameter month: 月份</span></span><br><span class="line"><span class="comment">/// - Returns: 天的数组</span></span><br><span class="line"><span class="keyword">private</span> <span class="function"><span class="keyword">func</span> <span class="title">daysInSomeMonth</span><span class="params">(year: Int, month: Int)</span></span> -&gt; [<span class="type">Weekday</span>] &#123;</span><br><span class="line">    <span class="keyword">let</span> calendar <span class="operator">=</span> <span class="type">Calendar</span>(identifier: .gregorian)</span><br><span class="line">    <span class="keyword">var</span> components <span class="operator">=</span> <span class="type">DateComponents</span>()</span><br><span class="line">    components.year <span class="operator">=</span> year</span><br><span class="line">    components.month <span class="operator">=</span> month</span><br><span class="line">    components.day <span class="operator">=</span> <span class="number">1</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">let</span> date <span class="operator">=</span> calendar.date(from: components)<span class="operator">!</span></span><br><span class="line">    <span class="keyword">let</span> localDate <span class="operator">=</span> localData(<span class="type">GMT</span>: date) <span class="comment">// 本地时间</span></span><br><span class="line">    <span class="keyword">var</span> monthStartDate <span class="operator">=</span> <span class="type">Date</span>()</span><br><span class="line">    <span class="keyword">var</span> interval: <span class="type">TimeInterval</span> <span class="operator">=</span> <span class="number">0</span></span><br><span class="line">    <span class="keyword">let</span> <span class="keyword">_</span> <span class="operator">=</span> calendar.dateInterval(of: <span class="type">Calendar</span>.<span class="type">Component</span>.month, start: monthStartDate, interval: <span class="operator">&amp;</span>interval, <span class="keyword">for</span>: localDate)</span><br><span class="line">    <span class="keyword">let</span> endDate <span class="operator">=</span> <span class="type">Date</span>(timeInterval: interval <span class="operator">-</span> <span class="number">60</span><span class="operator">*</span><span class="number">60</span><span class="operator">*</span><span class="number">24</span>, since: localDate)</span><br><span class="line">    <span class="keyword">let</span> endComponents <span class="operator">=</span> calendar.dateComponents([.month, .day], from:endDate)</span><br><span class="line">    <span class="keyword">let</span> endDay <span class="operator">=</span> endComponents.day<span class="operator">!</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">var</span> weekDays <span class="operator">=</span> [<span class="type">Weekday</span>]()</span><br><span class="line">    <span class="keyword">for</span> dayOfMonth <span class="keyword">in</span> <span class="number">1</span><span class="operator">...</span>endDay &#123;</span><br><span class="line">        <span class="keyword">var</span> dayComponents <span class="operator">=</span> <span class="type">DateComponents</span>()</span><br><span class="line">        dayComponents.year <span class="operator">=</span> year</span><br><span class="line">        dayComponents.month <span class="operator">=</span> month</span><br><span class="line">        dayComponents.day <span class="operator">=</span> dayOfMonth</span><br><span class="line">        <span class="keyword">let</span> _date <span class="operator">=</span> calendar.date(from: dayComponents)<span class="operator">!</span></span><br><span class="line">        <span class="keyword">let</span> _components <span class="operator">=</span> calendar.dateComponents([.weekday], from: _date)</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">let</span> weekDay <span class="operator">=</span> <span class="type">Weekday</span>(day: dayOfMonth, weekday:_components.weekday<span class="operator">!</span>)</span><br><span class="line">        weekDays.append(weekDay)</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> weekDays</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>先利用当月第一天的DateComponent获得对应的Date，然后转换成本地时间（北京时间），然后利用<code>public func dateInterval(of component: Calendar.Component, start: inout Date, interval: inout TimeInterval, for date: Date) -&gt; Bool</code>获得当月的天数，之后遍历当月的天数并得到每一天对应的是周几。其中<code>Date(timeInterval: interval - 60*60*24, since: localDate)</code>来保证得到的是当月的最后一天，如果没有<code>- 60*60*24</code>得到的是下月第一天。<br>将GMT时间转换成本地时间的方法是：</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="function"><span class="keyword">func</span> <span class="title">localData</span><span class="params">(GMT date: Date)</span></span> -&gt; <span class="type">Date</span> &#123;</span><br><span class="line">    <span class="keyword">let</span> timeZone <span class="operator">=</span> <span class="type">TimeZone</span>.current</span><br><span class="line">    <span class="keyword">let</span> interval <span class="operator">=</span> timeZone.secondsFromGMT()</span><br><span class="line">    <span class="keyword">return</span> <span class="type">Date</span>(timeInterval: <span class="type">TimeInterval</span>(interval), since: date)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="待完善"><a href="#待完善" class="headerlink" title="待完善"></a>待完善</h3><p>目前得到的是某个月的日期，如果是完整的日历还需要可以左右滑动。</p><h3 id="github源码"><a href="#github源码" class="headerlink" title="github源码"></a>github源码</h3><p><a href="https://github.com/shizhiang/CalendarTutorial">https://github.com/shizhiang/CalendarTutorial</a></p><p>👍👍👍</p><div><h1>推荐文章<span style="font-size:0.45em; color:gray"></span></h1><ul><li><a href="http://www.iosprogrammer.tech/how-to-make-view-get-intrinsic-content-size/">最佳实践：iOS开发在xib/storyboard中自定义view</a></li><li><a href="http://www.iosprogrammer.tech/What-is-Content-Hugging-Priorities-Content-Compression-Resistance-Priorities/">什么是Content Hugging Priorities/Content Compression Resistance Priorities</a></li><li><a href="http://www.iosprogrammer.tech/UIStackView-Advanced-Knowledge/">UIStackView的正确使用姿势（最新最全、配视频教程）</a></li></ul></div>]]></content>
      
      
      
        <tags>
            
            <tag> iOS </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>日期Date和时间Time（二）- 日历计算</title>
      <link href="Date-And-Time-Two/"/>
      <url>Date-And-Time-Two/</url>
      
        <content type="html"><![CDATA[<p>在iOS开发过程中关于日历计算的需求都应该使用NSDate提供的方法，因为这些方法里面考虑了夏时制开始或者结束以及闰年等极端情况。</p><h3 id="将组件添加到Date"><a href="#将组件添加到Date" class="headerlink" title="将组件添加到Date"></a>将组件添加到Date</h3><p>使用<code>public func date(byAdding components: DateComponents, to date: Date, wrappingComponents: Bool = default) -&gt; Date?</code>方法给一个日期添加组件并得到一个新的日期。</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> gregorian <span class="operator">=</span> <span class="type">Calendar</span>(identifier: .chinese)</span><br><span class="line"><span class="keyword">var</span> addingComponents <span class="operator">=</span> <span class="type">DateComponents</span>()</span><br><span class="line">addingComponents.day <span class="operator">=</span> <span class="number">1</span></span><br><span class="line">addingComponents.second <span class="operator">=</span> <span class="operator">-</span><span class="number">10</span></span><br><span class="line">gregorian.date(byAdding: addingComponents, to: <span class="type">Date</span>())</span><br></pre></td></tr></table></figure><p>如上例，添加到日期的组件可以是负数。</p><p>获取本周的周日：</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> gregorian <span class="operator">=</span> <span class="type">Calendar</span>(identifier: .chinese)</span><br><span class="line"><span class="keyword">let</span> weekdayComponents <span class="operator">=</span> gregorian.dateComponents([.weekday], from: <span class="type">Date</span>())</span><br><span class="line"><span class="built_in">print</span>(weekdayComponents.weekday<span class="operator">!</span>)</span><br><span class="line">    </span><br><span class="line"><span class="keyword">var</span> componentsToSubtract <span class="operator">=</span> <span class="type">DateComponents</span>()</span><br><span class="line">componentsToSubtract.day <span class="operator">=</span> <span class="number">0</span> <span class="operator">-</span> (weekdayComponents.weekday<span class="operator">!</span> <span class="operator">-</span> <span class="number">1</span>)</span><br><span class="line"><span class="built_in">print</span>(componentsToSubtract.day<span class="operator">!</span>)</span><br><span class="line">    </span><br><span class="line"><span class="keyword">let</span> beggingOfWeek <span class="operator">=</span> gregorian.date(byAdding: componentsToSubtract, to: <span class="type">Date</span>())</span><br><span class="line"><span class="built_in">print</span>(beggingOfWeek<span class="operator">!</span>)</span><br></pre></td></tr></table></figure><p>注意：上例的日历中每周是从周日开始的，有些日历不是这样。</p><h3 id="计算两个日期之间的间隔-网络时间协议NTP"><a href="#计算两个日期之间的间隔-网络时间协议NTP" class="headerlink" title="计算两个日期之间的间隔 网络时间协议NTP"></a>计算两个日期之间的间隔 <a href="https://baike.baidu.com/item/NTP/1100433">网络时间协议NTP</a></h3><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> gregorian <span class="operator">=</span> <span class="type">Calendar</span>(identifier: .gregorian)</span><br><span class="line"><span class="keyword">let</span> startDate <span class="operator">=</span> <span class="type">Date</span>()</span><br><span class="line"><span class="keyword">let</span> endDate <span class="operator">=</span> <span class="type">Date</span>(timeIntervalSinceNow: <span class="number">1000000</span>)</span><br><span class="line"><span class="keyword">let</span> dayComponents <span class="operator">=</span> gregorian.dateComponents([.day], from: startDate, to: endDate)</span><br><span class="line"><span class="built_in">print</span>(dayComponents.day<span class="operator">!</span>) <span class="comment">// 231</span></span><br><span class="line">    </span><br><span class="line"><span class="keyword">let</span> monthAndDayComponents <span class="operator">=</span> gregorian.dateComponents([.month, .day], from: startDate, to: endDate)</span><br><span class="line"><span class="built_in">print</span>(monthAndDayComponents.month<span class="operator">!</span>, monthAndDayComponents.day<span class="operator">!</span>) <span class="comment">// 7 17</span></span><br><span class="line">    </span><br><span class="line"><span class="keyword">let</span> monthComponents <span class="operator">=</span> gregorian.dateComponents([.month], from: startDate, to: endDate)</span><br><span class="line"><span class="built_in">print</span>(monthComponents.month<span class="operator">!</span>) <span class="comment">// 7</span></span><br></pre></td></tr></table></figure><p>从上例中可以看出，日期间隔的溢出被自动处理了（在dayComponents中，得到的是7个月零17天的天数）。<br>但是这个方法也会把计算结果截断为所提供的最小单位（monthComponents得到的只有7个月）。这个截断结果在某些情况下是我们所不希望得到的，如果说在即时通讯软件中，我们需要显示“一天前的聊天”，也就是当天的0点以后要把前一天的聊天显示为“一天前”，如果按照上面的方法，我们将会得到两个时间的间隔为0天，为了解决这个问题和得到我们想要的结果，可以使用下面的方法：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">let gregorian &#x3D; Calendar(identifier: .chinese)</span><br><span class="line">let startDate &#x3D; Date() &#x2F;&#x2F; 20:41</span><br><span class="line">let endDate &#x3D; Date(timeIntervalSinceNow: 3600 * 5)</span><br><span class="line">let dayComponents &#x3D; gregorian.dateComponents([.day], from: startDate, to: endDate)</span><br><span class="line">print(dayComponents.day!) &#x2F;&#x2F; 0</span><br><span class="line">    </span><br><span class="line">let startDay &#x3D; gregorian.ordinality(of: .day, in: .month, for: startDate)</span><br><span class="line">let endDay &#x3D; gregorian.ordinality(of: .day, in: .month, for: endDate)</span><br><span class="line">print(endDay! - startDay!) &#x2F;&#x2F; 1</span><br></pre></td></tr></table></figure><p>上面是分别用两个方法获取到的时间间隔，当前时间是20：41，结束时间是5小时后。至于哪个结果是我们想要的，要根据具体需求分析。其中，方法<code>open func ordinality(of smaller: NSCalendar.Unit, in larger: NSCalendar.Unit, for date: Date) -&gt; Int</code>是在一个较大的日期组件中获取指定日期的较小组件的数值。如果<code>larger &lt; smaller</code>将返回nil。</p><p>判断某个日期是否是本周</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">let calendar &#x3D; Calendar(identifier: .chinese)</span><br><span class="line">let today &#x3D; Date()</span><br><span class="line">var startDate &#x3D; Date()</span><br><span class="line">var extends: TimeInterval &#x3D; 0</span><br><span class="line">let success &#x3D; calendar.dateInterval(of: .weekOfYear, start: &amp;startDate,interval: &amp;extends, for: today)</span><br><span class="line">if !success &#123;</span><br><span class="line">    print(&quot;失败&quot;)</span><br><span class="line">&#125;</span><br><span class="line">let testDate &#x3D; Date(timeIntervalSinceNow: 100000)</span><br><span class="line">let dateInSecs &#x3D; testDate.timeIntervalSinceReferenceDate</span><br><span class="line">let dayStartInSecs &#x3D; startDate.timeIntervalSinceReferenceDate</span><br><span class="line">let dateInThisWeek &#x3D; dayStartInSecs &lt; dateInSecs &amp;&amp; (dateInSecs &lt;(dayStartInSecs + extends))</span><br><span class="line">print(dateInThisWeek)</span><br></pre></td></tr></table></figure><p>先使用<code>dateInterval(of: .weekOfYear, start: &amp;startDate,interval: &amp;extends, for: today)</code>获取到本周的<code>startDate</code>和<code>weekOfYear</code>（一周）的<code>extends</code>（时长），然后根据要判断的日期距离指定日期的秒数是否大于本周开始日期距离指定日期的秒数，并且小于本周结束时日期距离指定日期的秒数。</p><div><h1>推荐文章<span style="font-size:0.45em; color:gray"></span></h1><ul><li><a href="http://www.iosprogrammer.tech/how-to-make-view-get-intrinsic-content-size/">最佳实践：iOS开发在xib/storyboard中自定义view</a></li><li><a href="http://www.iosprogrammer.tech/What-is-Content-Hugging-Priorities-Content-Compression-Resistance-Priorities/">什么是Content Hugging Priorities/Content Compression Resistance Priorities</a></li><li><a href="http://www.iosprogrammer.tech/UIStackView-Advanced-Knowledge/">UIStackView的正确使用姿势（最新最全、配视频教程）</a></li></ul></div>]]></content>
      
      
      
        <tags>
            
            <tag> iOS </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>日期Date和时间Time（一）</title>
      <link href="Date-And-Time-One/"/>
      <url>Date-And-Time-One/</url>
      
        <content type="html"><![CDATA[<h3 id="相关概念"><a href="#相关概念" class="headerlink" title="相关概念"></a>相关概念</h3><ol><li>UTC - <a href="https://baike.baidu.com/item/%E5%8D%8F%E8%B0%83%E4%B8%96%E7%95%8C%E6%97%B6/787659?fr=aladdin&fromid=5899996&fromtitle=UTC">协调时间时，世界统一时间</a></li><li>历法 - <a href="https://baike.baidu.com/item/%E6%97%A5%E5%8E%86/84469?fr=aladdin">公历、农历、阳历、阴历</a></li></ol><h3 id="Date"><a href="#Date" class="headerlink" title="Date"></a>Date</h3><h4 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h4><ul><li>NSDate是Cocoa框架中的一个基本的值对象。它表示了一个不变的时间点。其中包含了时钟时间和日期。</li><li>NSDate的单位是用浮点数（NSTimeInterval）表示的秒。因此，NSDate可以提供10000年内毫秒级精度的时间</li><li>NSDate将时间计算为相对于绝对参考时间（2001年1月1日0点0分0秒：UTC时间）的秒数。国内获取到的是2001年1月1日08点00分00秒。</li><li>正数表示参考日期后的某个日期，负数表示参考日期之前。<h4 id="使用"><a href="#使用" class="headerlink" title="使用"></a>使用</h4></li><li>获取当前时间。<code>NSDat()</code></li><li>获取相对某个日期前/后的时间。<code>init(timeIntervalSince... sec: TimeInterval)</code></li></ul><h3 id="Calendar"><a href="#Calendar" class="headerlink" title="Calendar"></a>Calendar</h3><h4 id="介绍-1"><a href="#介绍-1" class="headerlink" title="介绍"></a>介绍</h4><ol><li><code>Calendar</code>提供多种日历的实现。<h4 id="使用-1"><a href="#使用-1" class="headerlink" title="使用"></a>使用</h4></li><li>获取当前日历<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> currentCalendar <span class="operator">=</span> <span class="type">Calendar</span>.currentCalendar</span><br><span class="line"><span class="keyword">let</span> chinesCalendar <span class="operator">=</span> <span class="type">Calendar</span>(identifier: .chinese)</span><br><span class="line"><span class="keyword">let</span> usersCalendar <span class="operator">=</span> <span class="type">Locale</span>.current.calendar</span><br></pre></td></tr></table></figure><h3 id="DateComponent"><a href="#DateComponent" class="headerlink" title="DateComponent"></a>DateComponent</h3><h4 id="介绍-2"><a href="#介绍-2" class="headerlink" title="介绍"></a>介绍</h4></li><li><code>CalendarComponent</code>是日历组建，通过它可以获取到某一个日期的年、月、日、时、分、秒等信息<h4 id="使用-2"><a href="#使用-2" class="headerlink" title="使用"></a>使用</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">var components &#x3D; DateComponents()</span><br><span class="line">components.day &#x3D; 6</span><br><span class="line">components.month &#x3D; -1</span><br><span class="line">components.year &#x3D; 2014</span><br></pre></td></tr></table></figure><h3 id="Date和DateComponent之间的转换"><a href="#Date和DateComponent之间的转换" class="headerlink" title="Date和DateComponent之间的转换"></a>Date和DateComponent之间的转换</h3><h4 id="获取Date的components"><a href="#获取Date的components" class="headerlink" title="获取Date的components"></a>获取Date的components</h4><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> now <span class="operator">=</span> <span class="type">Date</span>()</span><br><span class="line"><span class="keyword">let</span> calendar <span class="operator">=</span> <span class="type">Calendar</span>.current</span><br><span class="line"><span class="keyword">let</span> dateComponents <span class="operator">=</span> calendar.dateComponents([.year, .month, .day .hour, .minute, .second], from: now)</span><br><span class="line"><span class="built_in">print</span>(dateComponents.year, dateComponents.month, dateComponents.day, dateComponents.hour, dateComponents.minute, dateComponents.second) <span class="comment">// Optional(2018) Optional(4) Optional(12) Optional(23) Optional(9) Optional(47)</span></span><br></pre></td></tr></table></figure><h4 id="使用components生成date"><a href="#使用components生成date" class="headerlink" title="使用components生成date"></a>使用components生成date</h4><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> components <span class="operator">=</span> <span class="type">DateComponents</span>()</span><br><span class="line">components.day <span class="operator">=</span> <span class="number">6</span></span><br><span class="line">components.month <span class="operator">=</span> <span class="operator">-</span><span class="number">1</span></span><br><span class="line">components.year <span class="operator">=</span> <span class="number">2014</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> date <span class="operator">=</span> <span class="type">Calendar</span>.current.date(from: components)</span><br><span class="line"><span class="built_in">print</span>(date) <span class="comment">// Optional(2013-11-05 16:00:00 +0000)</span></span><br></pre></td></tr></table></figure>请注意：这里的<strong>month = -1</strong>，如果指定的参数不在合理范围内会进行进位/退位。并且，因为Date必须是完整的日期和时钟的组合，如果components对象存在没有明确指定的参数，在生成date时会使用默认值，并且默认值会根据历法的不同各异。</li></ol><h3 id="日历间转换"><a href="#日历间转换" class="headerlink" title="日历间转换"></a>日历间转换</h3><h4 id="介绍-3"><a href="#介绍-3" class="headerlink" title="介绍"></a>介绍</h4><p>要把一个日历中的某一个日期转换成一个日历中的日期，首先要使用第一个日历把components转换成date，再用第二个日历把这个date分解成components</p><h4 id="使用-3"><a href="#使用-3" class="headerlink" title="使用"></a>使用</h4><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> chineseCalendar <span class="operator">=</span> <span class="type">Calendar</span>(identifier: .chinese)</span><br><span class="line"><span class="keyword">var</span> chineseComponents <span class="operator">=</span> <span class="type">DateComponents</span>()</span><br><span class="line">chineseComponents.year <span class="operator">=</span> <span class="number">2018</span></span><br><span class="line">chineseComponents.month <span class="operator">=</span> <span class="number">1</span></span><br><span class="line">chineseComponents.day <span class="operator">=</span> <span class="number">1</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> chineseDate <span class="operator">=</span> chineseCalendar.date(from: chineseComponents)</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> indianCalendar <span class="operator">=</span> <span class="type">Calendar</span>(identifier: .indian)</span><br><span class="line"><span class="keyword">let</span> indianComponents <span class="operator">=</span> indianCalendar.dateComponents([.year,.month, .day], from: chineseDate<span class="operator">!</span>)</span><br><span class="line"><span class="built_in">print</span>(indianComponents.year<span class="operator">!</span>, indianComponents.month<span class="operator">!</span>,indianComponents.day<span class="operator">!</span>) <span class="comment">// 3922 11 18</span></span><br></pre></td></tr></table></figure><div><h1>推荐文章<span style="font-size:0.45em; color:gray"></span></h1><ul><li><a href="http://www.iosprogrammer.tech/how-to-make-view-get-intrinsic-content-size/">最佳实践：iOS开发在xib/storyboard中自定义view</a></li><li><a href="http://www.iosprogrammer.tech/What-is-Content-Hugging-Priorities-Content-Compression-Resistance-Priorities/">什么是Content Hugging Priorities/Content Compression Resistance Priorities</a></li><li><a href="http://www.iosprogrammer.tech/UIStackView-Advanced-Knowledge/">UIStackView的正确使用姿势（最新最全、配视频教程）</a></li></ul></div>]]></content>
      
      
      
        <tags>
            
            <tag> iOS </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>从零开始到提交一个开源项目到Cocopods</title>
      <link href="Create-Cocoapods-Repo/"/>
      <url>Create-Cocoapods-Repo/</url>
      
        <content type="html"><![CDATA[<h3 id="开发过程"><a href="#开发过程" class="headerlink" title="开发过程"></a>开发过程</h3><ol><li><p>执行<code>pod lib create [ProjectName]</code>创建项目。过程中需要回答几个问题，根据自己的需要设置设置就可以了。我的设置是：</p><ul><li><p>What platform do you want to use?? [ iOS / macOS ]</p><blockquote><p>iOS</p></blockquote></li><li><p>What language do you want to use?? [ Swift / ObjC ]</p><blockquote><p>Swift</p></blockquote></li><li><p>Would you like to include a demo application with your library? [ Yes / No ]</p><blockquote><p>Yes</p></blockquote></li><li><p>Which testing frameworks will you use? [ Quick / None ]</p><blockquote><p>None</p></blockquote></li><li><p>Would you like to do view based testing? [ Yes / No ]</p><blockquote><p>No</p></blockquote><p>紧接着会自动执行<code>pod install</code>，我们只需要静静的等着完成就可以了。</p></li></ul></li><li><p>项目结构。 <code>pod install</code>之后，Cocoapods会直接打开Xcode project。项目结构如下：<br><img src="http://image.iosprogrammer.hongbility.com/Create-Cocoapods-Repo/project-struct.png" alt="project-struct"></p><ol><li>Podspec Metadata<ul><li>.podpsec - 项目相关的pod信息。包括了版本号、github主页、对其他项目的依赖、作者信息和指定资源文件</li><li>README.md - 对当前项目的介绍和使用方法。也就是github中项目主页的介绍内容。</li><li>LICENSE - 指定使用的开源协议  </li></ul></li><li>Example for DemoProj - 对开源代码的使用实例。其他人从github下载了开源项目后可以通过这个来查看使用方法。如果在<code>Would you like to include a demo application with your library?</code>中选择了No，这个项目就不会创建。因此强烈建议这个问题回答YES。对自己调试和别人使用都非常有利。</li><li>Tests - 单元测试。</li><li>Development Pods - 开源库代码就放在这里。</li><li>Frameworks - 当前开源项目的依赖库</li></ol></li><li><p>.podspec文件详解</p><ul><li>s.name - 名称，<code>pod search</code>搜索的关键词,注意这里一定要和.podspec的名称一样,否则报错</li><li>s.version - 版本号，这个版本号要和tag版本一致，否则报错</li><li>s.summary - 项目简介，<code>pod search</code>的结果中会展示</li><li>s.homepage - 项目主页地址，也就是github地址</li><li>s.source - <code>git clone</code>的项目地址。 </li><li>s.ios.deployment_target - 支持到的iOS版本</li><li>s.source_files - 资源文件路径。请确保把项目相关的源文件放在这个文件夹下面，否则报错。</li><li>s.dependency - 项目依赖的其他三方库。</li></ul></li><li><p>在github上创建仓库</p></li><li><p>开发项目。。。</p></li><li><p>开发结束，把项目提交到github。</p></li><li><p>打tag并把tag提交。tag号要和.podspec中的s.server一致。</p></li><li><p>验证.podspec</p><ol><li><code>pod lib lint</code>本地验证</li><li><code>pod spec lint</code>和github上的内容进行对比</li></ol></li><li><p>把项目发布到Cocopods的master上。<code>pod trunk push [ProjectName].podspec</code>。注意，这个过程较(chao ji)慢。</p></li></ol><h3 id="可能遇到的问题"><a href="#可能遇到的问题" class="headerlink" title="可能遇到的问题"></a>可能遇到的问题</h3><ol><li><code>pod lib lint</code>通过，但是<code>pod spec lint</code>报错：<code>use of unresolved identifier</code>。遇到这个问题后，分为两步：<ol><li><code>pod spec lint --no-clean --verbose</code>查看错误原因，这是会看到临时文件，到临时文件里查看会发现缺少文件</li><li>使用<code>pod cache clean</code></li><li>重新执行一次<code>pod spec lint</code></li></ol></li><li>项目提交后执行<code>pod search</code>找不到的话，执行<code>pod setup</code>。</li><li>验证的时候出现<code>.swift-version</code>错误。解决办法是在项目目录下创建一个执行<code>echo &quot;4.0&quot; &gt; .swift-version</code>。注意，这里的4.0是我开发项目时使用的Swift版本。</li><li><strong>注意权限控制和Swift与OC的混编问题</strong></li></ol><h3 id="赠送一个提交开源库的shell脚本"><a href="#赠送一个提交开源库的shell脚本" class="headerlink" title="赠送一个提交开源库的shell脚本"></a>赠送一个提交开源库的shell脚本</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> bin/sh</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> 验证本地 pod lib lint</span></span><br><span class="line">echo &#x27;pod lib lint...\n&#x27;</span><br><span class="line">pod lib lint</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 下拉git  git pull</span></span><br><span class="line">echo &#x27;\ngit pull...\n&#x27;</span><br><span class="line">git pull</span><br><span class="line">echo `git pull`</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 上传git git add git commit git push</span></span><br><span class="line">echo &quot;git add . \n&quot;</span><br><span class="line">git add .</span><br><span class="line">echo &quot;Enter a commit message: \c&quot;</span><br><span class="line">read commitMsg</span><br><span class="line">echo &quot;git commit -m $commitMsg&quot;</span><br><span class="line">git commit -m &#x27;$commitMsg&#x27;</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> tag git tag  git push --tags</span></span><br><span class="line">echo &quot;\ngit push ...\n&quot;</span><br><span class="line">git push</span><br><span class="line"></span><br><span class="line">echo &quot;\nEnter tag version: \c&quot;</span><br><span class="line">read tagVersion</span><br><span class="line">git tag $tagVersion</span><br><span class="line">echo &quot;\n git push --tags ...&quot;</span><br><span class="line">git push --tags</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 远程验证 pod spec lint</span></span><br><span class="line">echo &quot;\npod spec lint ...\n&quot;</span><br><span class="line">pod spec lint</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 提交代码 pod trunk</span></span><br><span class="line">echo &quot;\npod trunk push ...\n&quot;</span><br><span class="line">pod trunk push [yourprojectname].podspec</span><br></pre></td></tr></table></figure><p>👍👍👍</p><div><h1>推荐文章<span style="font-size:0.45em; color:gray"></span></h1><ul><li><a href="http://www.iosprogrammer.tech/how-to-make-view-get-intrinsic-content-size/">最佳实践：iOS开发在xib/storyboard中自定义view</a></li><li><a href="http://www.iosprogrammer.tech/What-is-Content-Hugging-Priorities-Content-Compression-Resistance-Priorities/">什么是Content Hugging Priorities/Content Compression Resistance Priorities</a></li><li><a href="http://www.iosprogrammer.tech/UIStackView-Advanced-Knowledge/">UIStackView的正确使用姿势（最新最全、配视频教程）</a></li></ul></div>]]></content>
      
      
      
        <tags>
            
            <tag> iOS </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>LLDB调试iOS程序（二）—— 高级用法</title>
      <link href="LLDB-Advanced-Usage/"/>
      <url>LLDB-Advanced-Usage/</url>
      
        <content type="html"><![CDATA[<h3 id="巧用help命令"><a href="#巧用help命令" class="headerlink" title="巧用help命令"></a>巧用<code>help</code>命令</h3><p>LLDB中的命令非常多，虽然有一些算是常用的，但是要完全记住也很难，为了解决这个问题，我们可以充分利用<code>help</code>命令。比如要查看<code>breakPoint</code>的用法，可以先查看它的自命令：<br>![help breakpoint](<a href="http://image.iosprogrammer.hongbility.com/LLDB-Advanced-Usage/help">http://image.iosprogrammer.hongbility.com/LLDB-Advanced-Usage/help</a> breakpoint.png)<br>图中列举出了所有的<code>breakpoint</code>的子命令。</p><p>请看最后一行<code>For more help on any particular subcommand, type &#39;help &lt;command&gt; &lt;subcommand&gt;&#39;</code>。根据这条提示，我们来查看其中一条子命令的详细用法。<br>![help breakpoint](<a href="http://image.iosprogrammer.hongbility.com/LLDB-Advanced-Usage/help">http://image.iosprogrammer.hongbility.com/LLDB-Advanced-Usage/help</a> breakpoint set.png)<br>图中只是截取了部分内容。</p><p>由此可见LLDB给我们提供的<code>help</code>命令还是很强大的。我们在平时的调试过程中，如果遇到了不确定命令是什么了，可以使用<code>help</code>命令来查看，也可以使用<strong>自动提示</strong>功能来帮助我们。</p><h3 id="流程控制"><a href="#流程控制" class="headerlink" title="流程控制"></a>流程控制</h3><p>执行流程控制的命令包括<code>process</code>、<code>breakpoint</code>、<code>thread</code>，具体可以查看<a href="http://www.cocoachina.com/swift/20171013/20789.html">这篇文章</a>。</p><p>这里只讨论设置命中断点后执行的命令<code>breakpoint command add &lt;#断点#&gt;</code>。</p><p>首先使用<code>breakpoint list</code>来查看所有的断点。<br>![breakpoint list](<a href="http://image.iosprogrammer.hongbility.com/LLDB-Advanced-Usage/breakpoint">http://image.iosprogrammer.hongbility.com/LLDB-Advanced-Usage/breakpoint</a> list.png)<br>其中，前面的数字是断点的序号，可以唯一标识一个断点。图中的1/2都是全局断点，3是我自己加的断点。下面我们给3.1断点增加执行后的指令：<br>![breakpoint command add](<a href="http://image.iosprogrammer.hongbility.com/LLDB-Advanced-Usage/breakpoint">http://image.iosprogrammer.hongbility.com/LLDB-Advanced-Usage/breakpoint</a> command add.png)<br>如图，我们在断点出分别执行<code>po self</code>、<code>po self.view</code>、<code>continue</code>。其中<code>continue</code><strong>表示到此断点后继续执行，这在循环等场景特别有用</strong>。命令的执行结果为：<br>![breakpoint command add result](<a href="http://image.iosprogrammer.hongbility.com/LLDB-Advanced-Usage/breakpoint">http://image.iosprogrammer.hongbility.com/LLDB-Advanced-Usage/breakpoint</a> command add result.png)</p><p>这种方法在需要多次执行的场景中特别有用，完全可以代替使用<code>print()</code>来查看变量值的方案。</p><h3 id="给断点增加触发条件"><a href="#给断点增加触发条件" class="headerlink" title="给断点增加触发条件"></a><strong><em>给断点增加触发条件</em></strong></h3><p>有这样一种场景：在一个循环中，我们只要在某些条件下才需要触发断点。可以这样设置：<br>![breakpoint condition](<a href="http://image.iosprogrammer.hongbility.com/LLDB-Advanced-Usage/breakpoint">http://image.iosprogrammer.hongbility.com/LLDB-Advanced-Usage/breakpoint</a> condition.png)</p><h4 id="参考文章"><a href="#参考文章" class="headerlink" title="参考文章"></a>参考文章</h4><p><a href="http://www.cocoachina.com/swift/20171013/20789.html">使用LLDB调试Swift</a></p><div><h1>推荐文章<span style="font-size:0.45em; color:gray"></span></h1><ul><li><a href="http://www.iosprogrammer.tech/how-to-make-view-get-intrinsic-content-size/">最佳实践：iOS开发在xib/storyboard中自定义view</a></li><li><a href="http://www.iosprogrammer.tech/What-is-Content-Hugging-Priorities-Content-Compression-Resistance-Priorities/">什么是Content Hugging Priorities/Content Compression Resistance Priorities</a></li><li><a href="http://www.iosprogrammer.tech/UIStackView-Advanced-Knowledge/">UIStackView的正确使用姿势（最新最全、配视频教程）</a></li></ul></div>]]></content>
      
      
      
        <tags>
            
            <tag> iOS </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>LLDB调试iOS（一）—— 初识LLDB</title>
      <link href="Get-To-Know-LLDB/"/>
      <url>Get-To-Know-LLDB/</url>
      
        <content type="html"><![CDATA[<h3 id="什么是LLDB"><a href="#什么是LLDB" class="headerlink" title="什么是LLDB"></a><strong>什么是LLDB</strong></h3><p>LLDB是下一代、高性能的调试器。它是作为一组可重用组件构建的，它可以高度利用较大<strong>LLVM</strong>项目中的现有库，例如<strong>Clang</strong>表达式解析器和LLVM反汇编器。</p><p>LLDB是Mac OS X上Xcode的默认调试器，支持在桌面和iOS设备、模拟器上调试C/Objective-C/C++/Swift。</p><h3 id="LLDB的进步"><a href="#LLDB的进步" class="headerlink" title="LLDB的进步"></a>LLDB的进步</h3><ol><li>支持现代化的多线程程序</li><li>以高效的方式处理调试符号</li><li>使用基于编码器（LLVM）的代码知识</li><li>支持插件扩展</li></ol><h3 id="与LLVM集成的优势"><a href="#与LLVM集成的优势" class="headerlink" title="与LLVM集成的优势"></a>与LLVM集成的优势</h3><p>LLDB当前将调试信息转换为clang类型，以便它可以利用clang编译器基础结构。 这允许LLDB在表达式中支持最新的C，C ++，Objective C和Objective C ++语言功能和运行时，而无需重新实现这些功能。 在进行表达式的函数调用，分解指令和提取指令细节时，它还利用编译器处理所有ABI细节，等等。</p><p>主要好处包括:</p><ul><li>C，C ++，Objective C的最新语言支持</li><li>可以声明局部变量和类型的多行表达式</li><li>支持时使用JIT表达式</li><li>在无法使用JIT时评估表达式Intermediate Intermediateation（IR）</li></ul><h3 id="LLDB与GDB的不同"><a href="#LLDB与GDB的不同" class="headerlink" title="LLDB与GDB的不同"></a>LLDB与GDB的不同</h3><pre><code>1. GDB是GNU项目中的一部分，是为了和GNU编译器协同工作而创建的2. LLDB是LLVM项目中的一部分，是为了和LLVM编译器协同工作而创建的3. GDB和LLDB的命令有一些不同。LLDB命令就像OC语法一样，要有形参名，而GDB则不需要，这一点上孰优孰劣就见仁见智了。</code></pre><h3 id="LLDB命令结构"><a href="#LLDB命令结构" class="headerlink" title="LLDB命令结构"></a>LLDB命令结构</h3><p>为了更好的使用和了解LLDB，所有学习LLDB的用户都应该了解LLDB的命令结构<br>LLDB的命令都是这样的形式：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;command&gt; [&lt;subcommand&gt; [&lt;subcommand&gt;...]] &lt;action&gt; [-options [option-value]] [argument [argument...]]</span><br></pre></td></tr></table></figure><p><code>command</code>和<code>subcommand</code>都是LLDB调试器对象的名称。命令和子命令按照层次结构排列：特定的命令对象为其后的子命令对象创建上下文，该对象再次为下一个子命令提供上下文，依此类推。<br><code>action</code>是你想要在调试器对象（前面提到的命令和子命令）组成的上下文中执行的一些操作。<br><code>options</code>：行为修改器(action modifiers)。通常带有一些值。<br><code>argument</code>：根据使用的命令的上下文来表示各种不同的东西。</p><p>LLBD命令行的解析操作在执行命令之前完成。上面的这些元素之间通过空格来分割，如果某一元素自身含有空格，则可以使用双引用。而如果元素中又包含双引号，则可以使用反斜杠；或者元素使用单引号。如下所示：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">(lldb) command [subcommand] -option &quot;some \&quot;quoted\&quot; string&quot;</span><br></pre></td></tr></table></figure><p>也可以这样表示：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">(lldb) command [subcommand] -option &quot;some \&quot;quoted\&quot; string&quot;</span><br></pre></td></tr></table></figure><p>这种命令解析设计规范了LLDB命令语法，并对所有命令做了个统一。</p><h3 id="使用举例"><a href="#使用举例" class="headerlink" title="使用举例"></a>使用举例</h3><p>调试快捷键：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">command+shift+Y 打开调试窗口</span><br><span class="line">command+Y 调试运行程序</span><br><span class="line">command+option+P 继续</span><br><span class="line">command+shift+O 跳过</span><br><span class="line">command+shift+I 进入</span><br><span class="line">command+shift+T 跳出</span><br></pre></td></tr></table></figure><ul><li><code>p/po</code> 这两个命令都是用来做输出调用的，其中p用来打印常量，po用来打印对象<br><img src="http://image.iosprogrammer.hongbility.com/Get-To-Know-LLDB/p%E5%92%8Cpo.png" alt="p/po"></li><li><code>call</code>：一般只在不需要显示输出，或是方法无返回值时使用call。想要在debug阶段修改view的背景色、试一下label显示更多文字的效果、调用一个忘记调用的函数。。。都可以使用call命令</li><li><code>e</code>：可以在调试时动态执行指定表达式，并将结果打印出来。常用于在调试过程中修改变量的值。<img src="http://image.iosprogrammer.hongbility.com/Get-To-Know-LLDB/e.png" alt="e"></li></ul><h3 id="参考链接"><a href="#参考链接" class="headerlink" title="参考链接"></a>参考链接</h3><ul><li><a href="http://blog.csdn.net/talentedlas/article/details/51945569">LLVM与Clang的概述及关系</a></li><li><a href="http://lldb.llvm.org/">LLDB Homepage</a></li><li><a href="https://developer.apple.com/library/content/documentation/IDEs/Conceptual/gdb_to_lldb_transition_guide/document/lldb-basics.html#//apple_ref/doc/uid/TP40012917-CH2-SW1">LLDB Quick Start Guide</a></li><li><a href="http://www.cocoachina.com/swift/20171013/20789.html">使用LLDB调试Swift</a></li><li><a href="https://mp.weixin.qq.com/s/us5aXQAwSSoxkUMOVzofkg">什么是LLVM？Swift，Rust，Clang等语言背后的原力</a></li></ul><div><h1>推荐文章<span style="font-size:0.45em; color:gray"></span></h1><ul><li><a href="http://www.iosprogrammer.tech/how-to-make-view-get-intrinsic-content-size/">最佳实践：iOS开发在xib/storyboard中自定义view</a></li><li><a href="http://www.iosprogrammer.tech/What-is-Content-Hugging-Priorities-Content-Compression-Resistance-Priorities/">什么是Content Hugging Priorities/Content Compression Resistance Priorities</a></li><li><a href="http://www.iosprogrammer.tech/UIStackView-Advanced-Knowledge/">UIStackView的正确使用姿势（最新最全、配视频教程）</a></li></ul></div>]]></content>
      
      
      
        <tags>
            
            <tag> iOS </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Xcode持续集成简介</title>
      <link href="XCode-Server-CI/"/>
      <url>XCode-Server-CI/</url>
      
        <content type="html"><![CDATA[<h3 id="环境"><a href="#环境" class="headerlink" title="环境"></a>环境</h3><ul><li>Xcode 9.2</li><li>macOS High Sierra 10.13.2</li></ul><h3 id="本文的目的"><a href="#本文的目的" class="headerlink" title="本文的目的"></a>本文的目的</h3><ul><li>介绍Xcode CI和Xcode Server</li><li>手把手教你从头开始创建一个Xcode Server来进行自动集成</li></ul><h3 id="Xcode-CI和Xcode-Server"><a href="#Xcode-CI和Xcode-Server" class="headerlink" title="Xcode CI和Xcode Server"></a>Xcode CI和Xcode Server</h3><p>正如<a href="https://developer.apple.com/library/content/documentation/IDEs/Conceptual/xcode_guide-continuous_integration/index.html#//apple_ref/doc/uid/TP40013292-CH1-SW1">苹果开发者网站</a>所描述的</p><blockquote><p>In Xcode, continuous integration is the process of automating and streamlining the building, analyzing, testing, and archiving of your Mac and iOS apps, in order to ensure that they are always in a releasable state.</p></blockquote><p>Xcode CI是一种为了确保你的APP始终处于可发布状态而存在的自动的、流式的过程，整个过程包括了编译、解析、测试和打包。<br>Xcode Server是用来远程进行这个过程的服务器。</p><p>整个过程类似下图<br><img src="http://image.iosprogrammer.hongbility.com/XCode-Server-CI/Xcode-CI-Intro.png"></p><ul><li>使用这个过程的目的就是为了集成开发APP的整个过程，让这个过程完全自动化进行。通过Xcode CI可以在每次提交代码后自动进行编译到打包的过程，并且可以查看代码的测试覆盖率。因为它可以自动执行单元测试，可以更方便的查看测试报告。</li></ul><h3 id="集成"><a href="#集成" class="headerlink" title="集成"></a>集成</h3><ol><li><p>打开Xcode Server</p><ol><li>点击Xcode菜单栏中的Xcode选项卡的Xcode Server…</li><li>将右上角的开关调到On</li></ol></li><li><p>配置Xcode Server</p><ol><li><p>点击Product选项卡中的Create Bot…</p></li><li><p>配置bot的Name。Server一般不需要<img src="http://image.iosprogrammer.hongbility.com/XCode-Server-CI/Create-a-new-bot.png"></p></li><li><p>配置代码库<img src="http://image.iosprogrammer.hongbility.com/XCode-Server-CI/Configure-source-control-for-this-bot.png"><br><img src="http://image.iosprogrammer.hongbility.com/XCode-Server-CI/Configrure-souce-code-2.png"></p><blockquote><p>这里选择的是使用.ssh的公钥来配置，当然也可以使用UserName And Password或者Bot Specific SSh Keys。</p></blockquote></li><li><p>选择分支</p></li><li><p>配置Bot的环境<br><img src="http://image.iosprogrammer.hongbility.com/XCode-Server-CI/Configure-build-configuration.png"></p><blockquote><p>这里可以选择在集成的时候是否进行静态分析、测试和打包</p></blockquote></li><li><p>配置集成周期<img src="http://image.iosprogrammer.hongbility.com/XCode-Server-CI/Schedule-bot-integrations.png"></p><blockquote><p>其中，Ingegrate选项中Periodically表示按周期集成，包括小时、天、周；Clean选项表示对项目进行Clean的周期，包括Always/Once a day/Once a week/Never。</p></blockquote></li><li><p>选择集成的目标设备。可以设置模拟器和真机、所有的模拟器、所有的真机、指定的模拟器和指定的真机。</p></li><li><p>配置项目证书</p></li><li><p>集成完成<img src="http://image.iosprogrammer.hongbility.com/XCode-Server-CI/create-ci-success.png"></p></li></ol></li></ol><h3 id="可能遇到的问题和解决方案"><a href="#可能遇到的问题和解决方案" class="headerlink" title="可能遇到的问题和解决方案"></a>可能遇到的问题和解决方案</h3><ol><li>The sandbox is not in sync with the Podfile.lock.Run ‘pod install’ or update your CocoaPods installation.</li><li>Invalid byte sequence in US_ASCII(Argument Error)</li></ol><blockquote><p>其中第一个问题需要在每次integrate之前执行<code>pod install</code>；第二个问题是由于Ruby的编码问题导致的，这两个问题的统一解决方案是给Bot添加一个prebuild script，步骤如下： 1. Edit Bot…  2. Triggers 3. Click ‘+’, select ‘Pre-Integraation Script’<br>具体的脚本内容为：<img src="http://image.iosprogrammer.hongbility.com/XCode-Server-CI/pre-script.jpg"><br>下面对这个脚本做一个解释说明:<br>(1). 第2行是用来查看脚本（也就是Server）当前的环境<img src="http://image.iosprogrammer.hongbility.com/XCode-Server-CI/set.jpg"><br>(2). 第4行是切换到项目所在目录，目录地址可以从环境的PWD变量获得<br>(3). 6-8行是用来解决第2个问题的<br>(4). 第10行来执行<code>pod install</code></p></blockquote><h3 id="脚本上传到蒲公英"><a href="#脚本上传到蒲公英" class="headerlink" title="脚本上传到蒲公英"></a>脚本上传到蒲公英</h3><p>   增加一个Post-Integration Scripts<img src="http://image.iosprogrammer.hongbility.com/XCode-Server-CI/post_integration_scripy.jpg" alt="post_integration_script"></p><div><h1>推荐文章<span style="font-size:0.45em; color:gray"></span></h1><ul><li><a href="http://www.iosprogrammer.tech/how-to-make-view-get-intrinsic-content-size/">最佳实践：iOS开发在xib/storyboard中自定义view</a></li><li><a href="http://www.iosprogrammer.tech/What-is-Content-Hugging-Priorities-Content-Compression-Resistance-Priorities/">什么是Content Hugging Priorities/Content Compression Resistance Priorities</a></li><li><a href="http://www.iosprogrammer.tech/UIStackView-Advanced-Knowledge/">UIStackView的正确使用姿势（最新最全、配视频教程）</a></li></ul></div>]]></content>
      
      
      
        <tags>
            
            <tag> iOS </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>使用Instruments工具测试CPU与常见对CPU占用过高的操作</title>
      <link href="Using-Instruments-To-Oprimize-CPU-Performance/"/>
      <url>Using-Instruments-To-Oprimize-CPU-Performance/</url>
      
        <content type="html"><![CDATA[<h1 id="使用Xcode自带的Instruments工具，检测CPU"><a href="#使用Xcode自带的Instruments工具，检测CPU" class="headerlink" title="使用Xcode自带的Instruments工具，检测CPU"></a>使用Xcode自带的Instruments工具，检测CPU</h1><h2 id="Instruments"><a href="#Instruments" class="headerlink" title="Instruments"></a>Instruments</h2><p>打开Instruments：Xcode -&gt; Product -&gt; Profile 或者 cmd + i<br>启动后如下：<br><img src="http://upload-images.jianshu.io/upload_images/424855-8c5d278b6d7b35c0.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="Instruments.png"><br>其中常用的有用来检测内存泄露的Leaks和查看CPU消耗情况的Time Profiler。下面介绍查看CPU使用情况的Time Profiler</p><h3 id="Time-Profier"><a href="#Time-Profier" class="headerlink" title="Time Profier"></a>Time Profier</h3><ol><li>打开Time Profier</li></ol><p><img src="https://upload-images.jianshu.io/upload_images/424855-4322b66e910ec9ae.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="Timer profile 9.0.png"></p><blockquote><p>要查看每个函数的CPU性能，直接双击函数就可以定位到代码了。<br>函数前面的数值是所用时间，可以根据这个时间判断是是否需要优化。</p></blockquote><p>有了上面的基础知识就可以对App的CPU消耗情况进行实时检测了。</p><h3 id="常见的对CPU消耗过高的操作"><a href="#常见的对CPU消耗过高的操作" class="headerlink" title="常见的对CPU消耗过高的操作"></a>常见的对CPU消耗过高的操作</h3><ul><li>加载图片<br>两种不同方式在相同时间内的CPU消耗情况对比：<br><img src="http://upload-images.jianshu.io/upload_images/424855-70124a2646fe806a.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="Paste_Image.png"><br><img src="http://upload-images.jianshu.io/upload_images/424855-0f98cb8f0b9d974b.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="屏幕快照 2016-03-13 下午6.25.34.png"><br>并且，使用5s真机测试以下代码40s后Memory过高造成闪退，但是使用<code>imageWithContentOfFile</code>数分钟后没有出现闪退现象<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">while (1)</span><br><span class="line">    &#123;</span><br><span class="line">        [UIImage imageNamed:@&quot;58_58&quot;];</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure></li><li>初始化对象<ul><li>正则表达式</li><li>时间戳<br><img src="http://upload-images.jianshu.io/upload_images/424855-612ee50bf16040c3.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="屏幕快照 2016-03-13 下午6.37.50.png"></li></ul></li></ul><p>在需要多次使用的地方尽量只初始化一次，然后多次使用</p><ul><li>视图布局<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;-(void)layoutSubviews</span><br><span class="line">&#123;</span><br><span class="line">    &#x2F;&#x2F; do something</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">[view setNeedsLayout];</span><br><span class="line">[view layoutIfNeeded];</span><br></pre></td></tr></table></figure>这些函数尽量不要使用。每对view进行一次重新布局就会对CPU增加很多消耗。</li><li>绘制图层<br>需要用到<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[layout rendInContext:]</span><br></pre></td></tr></table></figure>的地方尽量换成iOS7以后新增的方法：<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[view drawViewHierachyInRect:]</span><br></pre></td></tr></table></figure>性能同样可以获得很大的提升</li></ul><h4 id="上面的内容如有错误，还请在评论区指出。如果对您有帮助请给个赞，谢谢。"><a href="#上面的内容如有错误，还请在评论区指出。如果对您有帮助请给个赞，谢谢。" class="headerlink" title="上面的内容如有错误，还请在评论区指出。如果对您有帮助请给个赞，谢谢。"></a>上面的内容如有错误，还请在评论区指出。如果对您有帮助请给个赞，谢谢。</h4><div><h1>推荐文章<span style="font-size:0.45em; color:gray"></span></h1><ul><li><a href="http://www.iosprogrammer.tech/how-to-make-view-get-intrinsic-content-size/">最佳实践：iOS开发在xib/storyboard中自定义view</a></li><li><a href="http://www.iosprogrammer.tech/What-is-Content-Hugging-Priorities-Content-Compression-Resistance-Priorities/">什么是Content Hugging Priorities/Content Compression Resistance Priorities</a></li><li><a href="http://www.iosprogrammer.tech/UIStackView-Advanced-Knowledge/">UIStackView的正确使用姿势（最新最全、配视频教程）</a></li></ul></div>]]></content>
      
      
      
        <tags>
            
            <tag> iOS </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>SocketRocket使用</title>
      <link href="iOS-SocketRocket/"/>
      <url>iOS-SocketRocket/</url>
      
        <content type="html"><![CDATA[<p>SocketRocket是Facebook开源的一个用于 iOS, macOS and tvOS客户端的websocket框架。<br></p><p>WebSocket的协议分析和SocketRocket框架源码分析在<a href="http://www.iosprogrammer.tech/WebSocket-And-SocketRocket-Source-Analysis/">这里</a></p><h2 id="1-集成"><a href="#1-集成" class="headerlink" title="1. 集成"></a>1. 集成</h2><ul><li><p>使用cocoapods<br>  只需要在podfile文件中加入<code>pod &#39;SocketRocket&#39;</code>，然后执行<code>pod install</code>就可以了</p></li><li><p>不使用cocoapods</p><ol><li><p>添加文件<br>把下面的三个文件拖入项目中<br><img src="http://upload-images.jianshu.io/upload_images/424855-07d19159ebcaf127.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="Paste_Image.png"><br>其中，SocketRocket.h文件是用来引入框架的所有类的文件，就像&lt;UIKit/UIkit.h&gt;。目前，这个文件只引入了一个类，所以只有一行代码 <code>&lt;SocketRocket/SRWebSocket.h&gt;</code>，这样的话，编译会报错，因为并没有一个SocketRocket的framework，需要把这一行代码改为 <code>#import &quot;SRWebSocket.h&quot;</code>。</p></li><li><p>添加依赖库<br>在Build Phases -&gt; Link Binary With Libraries里加入如下frameworks：</p><ul><li>libicucore.dylib</li><li>CFNetwork.framework</li><li>Security.framework</li><li>Foundation.framework</li></ul></li></ol></li></ul><h2 id="2-使用"><a href="#2-使用" class="headerlink" title="2. 使用"></a>2. 使用</h2><ol><li>初始化   初始化方法分为两类：<ul><li>通过传入NSURLRequest的对象进行初始化<figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">-(<span class="keyword">id</span>)initWithURLRequest:(<span class="built_in">NSURLRequest</span> *)request protocols:(<span class="built_in">NSArray</span> *)protocols allowsUntrustedSSLCertificates:(<span class="built_in">BOOL</span>)allowsUntrustedSSLCertificates;</span><br><span class="line">-(<span class="keyword">id</span>)initWithURLRequest:(<span class="built_in">NSURLRequest</span> *)request protocols:(<span class="built_in">NSArray</span> *)protocols;</span><br><span class="line">-(<span class="keyword">id</span>)initWithURLRequest:(<span class="built_in">NSURLRequest</span> *)request;</span><br></pre></td></tr></table></figure></li><li>通过传入NSURL的对象进行初始化<figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">-(<span class="keyword">id</span>)initWithURL:(<span class="built_in">NSURL</span> *)url protocols:(<span class="built_in">NSArray</span> *)protocols allowsUntrustedSSLCertificates:(<span class="built_in">BOOL</span>)allowsUntrustedSSLCertificates;</span><br><span class="line">-(<span class="keyword">id</span>)initWithURL:(<span class="built_in">NSURL</span> *)url protocols:(<span class="built_in">NSArray</span> *)protocols;</span><br><span class="line">-(<span class="keyword">id</span>)initWithURL:(<span class="built_in">NSURL</span> *)url;</span><br></pre></td></tr></table></figure>其中，使用NSURLRequest进行初始化可以自定义请求超时时间<figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[<span class="built_in">NSURLRequest</span> requestWithURL:url cachePolicy:<span class="built_in">NSURLRequestUseProtocolCachePolicy</span> timeoutInterval:timeoutInterval]</span><br></pre></td></tr></table></figure></li></ul></li><li>打开连接<br>使用第一步创建出来的SRWebSocket对象（以下简称‘对象’）调用<code>- (void)open</code>来与服务器建立连接。这里需要注意<code>// SRWebSockets are intended for one-time-use only.  Open should be called once and only once.</code>一个对象只能调用一次<code>- (void)open</code>调用过open后，对象的readyState就为SR_CONNECTING，如果再调用open，就会<code>NSAssert(_readyState == SR_CONNECTING, @&quot;Cannot call -(void)open on SRWebSocket more than once&quot;);</code></li><li>发送数据<br>使用对象调用<code>- (void)send:(id)data</code>这个data可以是一个UTF8的字符串或者NSData对象</li><li>关闭连接<br>使用对象调用<code>- (void)close</code>来关闭一个连接。</li><li>回调<br> 以delegate的方式进行回调，包括下面几个回调函数<figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">@protocol</span> <span class="title">SRWebSocketDelegate</span> &lt;<span class="title">NSObject</span>&gt;</span></span><br><span class="line">-(<span class="keyword">void</span>)webSocket:(SRWebSocket *)webSocket didReceiveMessage:(<span class="keyword">id</span>)message;</span><br><span class="line"><span class="keyword">@optional</span></span><br><span class="line">-(<span class="keyword">void</span>)webSocketDidOpen:(SRWebSocket *)webSocket;</span><br><span class="line">-(<span class="keyword">void</span>)webSocket:(SRWebSocket *)webSocket didFailWithError:(<span class="built_in">NSError</span> *)error;</span><br><span class="line">-(<span class="keyword">void</span>)webSocket:(SRWebSocket *)webSocket didCloseWithCode:(<span class="built_in">NSInteger</span>)code reason:(<span class="built_in">NSString</span> *)reason wasClean:(<span class="built_in">BOOL</span>)wasClean;</span><br><span class="line">-(<span class="keyword">void</span>)webSocket:(SRWebSocket *)webSocket didReceivePong:(<span class="built_in">NSData</span> *)pongPayload;</span><br><span class="line">-(<span class="built_in">BOOL</span>)webSocketShouldConvertTextFrameToString:(SRWebSocket *)webSocket;</span><br><span class="line"><span class="keyword">@end</span></span><br></pre></td></tr></table></figure>其中，<ul><li><code>webSocketDidOpen</code>表示与服务器的连接建立成功，这时就可以与服务器进行交互了。</li><li><code>didFailWithError</code>表示连接出现错误，包括连接没有成功建立的错误、网络错误等。如果需要进行重连，应该在这里进行，可以采用Demo里面的方式进行重连：把以后的对象置空-&gt;重新初始化-&gt;调用open。应用切到后台2分钟以后才会出现连接错误的回调。</li></ul></li><li>SocketRocket已经对消息的收发进行了处理。我们收到和发出的消息都是根据socket头进行分隔的，所以不会出现消息不完整或者多条消息同时收发的问题。</li></ol><p>上面是在使用SocketRocket的过程中的总结，通过这些应该可以把这个框架使用起来，以后有时间会继续钻研这个框架的源码。SocketRocket还是挺好用的。</p><div><h1>推荐文章<span style="font-size:0.45em; color:gray"></span></h1><ul><li><a href="http://www.iosprogrammer.tech/how-to-make-view-get-intrinsic-content-size/">最佳实践：iOS开发在xib/storyboard中自定义view</a></li><li><a href="http://www.iosprogrammer.tech/What-is-Content-Hugging-Priorities-Content-Compression-Resistance-Priorities/">什么是Content Hugging Priorities/Content Compression Resistance Priorities</a></li><li><a href="http://www.iosprogrammer.tech/UIStackView-Advanced-Knowledge/">UIStackView的正确使用姿势（最新最全、配视频教程）</a></li></ul></div>]]></content>
      
      
      
        <tags>
            
            <tag> iOS </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Array().addObject(ViewController())造成控制器不释放</title>
      <link href="Array-addObject-ViewController-cause-viewcontroller-not-release/"/>
      <url>Array-addObject-ViewController-cause-viewcontroller-not-release/</url>
      
        <content type="html"><![CDATA[<h2 id="场景"><a href="#场景" class="headerlink" title="场景"></a>场景</h2><p>项目中有一个单例<code>Singleton</code>。有多个<code>UIViewController</code>需要向Singleton中注册观察者来接受<code>Singleton</code>的消息。<br> 这种情况下，使用<code>NSNotificationCenter</code>的方案有些松散，因此不作考虑；<br>  还有一种是使用<code>delegate</code>的方式。为了让<code>delegate</code>可以实现一对多的功能，可以在<code>Singleton</code>的里面增加一个<code>mutableArray</code>的变量和一个<code>addDelegate:</code>的方法。然后在需要接受这个<code>Singleton</code>通知的地方<code>Singleton().addDelegate(self)</code>，这样可以达到目的，但是你会发现这个控制器再也不会调用<code>dealloc</code>。</p><h2 id="问题1"><a href="#问题1" class="headerlink" title="问题1"></a>问题1</h2><p>那个调用了<code>Singleton().addDelegate(self)</code>的控制器为什么不会<code>dealloc()</code>了呢？</p><h2 id="分析1"><a href="#分析1" class="headerlink" title="分析1"></a>分析1</h2><ol><li><code>Singleton()</code>作为单例是不会释放的；</li><li><code>mutableArray</code>被<code>Singleton()</code>强引用着，因此也是不会释放的；</li><li>接受消息的控制器被添加到了<code>mutableArray()</code>中，就会被<code>mutableArray()</code>强引用，因此也不会释放；<h2 id="结论1"><a href="#结论1" class="headerlink" title="结论1"></a>结论1</h2>控制器会一直被强引用，因此不会调用<code>dealloc()</code><h2 id="问题2"><a href="#问题2" class="headerlink" title="问题2"></a>问题2</h2>那么，如果把<code>Singleton().addDelegate(self)</code>中的self改成__weak呢？<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">__weak UIViewController *weakself &#x3D; self;</span><br><span class="line">Singleton().addDelegate(weakself);</span><br></pre></td></tr></table></figure><h2 id="分析2"><a href="#分析2" class="headerlink" title="分析2"></a>分析2</h2>先来看一段代码：<figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">_arr = [<span class="built_in">NSMutableArray</span> array];</span><br><span class="line">Dog *dog1 = [[Dog alloc] init];</span><br><span class="line"><span class="built_in">NSLog</span>(<span class="string">@&quot;-- retain count: %ld&quot;</span>, <span class="built_in">CFGetRetainCount</span>((__bridge <span class="built_in">CFTypeRef</span>)(dog1)));</span><br><span class="line">__<span class="keyword">weak</span> Dog *weakDog = dog1;</span><br><span class="line"><span class="built_in">NSLog</span>(<span class="string">@&quot;-- retain count: %ld&quot;</span>, <span class="built_in">CFGetRetainCount</span>((__bridge <span class="built_in">CFTypeRef</span>)(dog1)));</span><br><span class="line"><span class="built_in">NSLog</span>(<span class="string">@&quot;-- retain count: %ld&quot;</span>, <span class="built_in">CFGetRetainCount</span>((__bridge <span class="built_in">CFTypeRef</span>)(weakDog)));</span><br><span class="line">[<span class="keyword">self</span>.arr addObject:weakDog];</span><br><span class="line"><span class="built_in">NSLog</span>(<span class="string">@&quot;-- retain count: %ld&quot;</span>, <span class="built_in">CFGetRetainCount</span>((__bridge <span class="built_in">CFTypeRef</span>)(dog1)));</span><br><span class="line"><span class="built_in">NSLog</span>(<span class="string">@&quot;-- retain count: %ld&quot;</span>, <span class="built_in">CFGetRetainCount</span>((__bridge <span class="built_in">CFTypeRef</span>)(weakDog)));</span><br><span class="line"></span><br><span class="line">Dog *dog2 = dog1;    </span><br><span class="line"></span><br><span class="line"><span class="built_in">NSLog</span>(<span class="string">@&quot;dog1 = %p&quot;</span>, dog1);</span><br><span class="line"><span class="built_in">NSLog</span>(<span class="string">@&quot;weakdog1 = %p&quot;</span>, weakDog);</span><br><span class="line"><span class="built_in">NSLog</span>(<span class="string">@&quot;weakdog1 = %p&quot;</span>, <span class="keyword">self</span>.arr.firstObject);</span><br><span class="line"><span class="built_in">NSLog</span>(<span class="string">@&quot;dog2 = %p&quot;</span>, dog2);</span><br><span class="line"><span class="built_in">NSLog</span>(<span class="string">@&quot;retain count: %ld&quot;</span>, <span class="built_in">CFGetRetainCount</span>((__bridge <span class="built_in">CFTypeRef</span>)(dog1)));</span><br></pre></td></tr></table></figure>打印结果是：<figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">retain</span> count: <span class="number">1</span></span><br><span class="line"><span class="keyword">retain</span> count: <span class="number">1</span></span><br><span class="line"><span class="keyword">retain</span> count: <span class="number">2</span></span><br><span class="line"><span class="keyword">retain</span> count: <span class="number">2</span></span><br><span class="line"><span class="keyword">retain</span> count: <span class="number">3</span></span><br><span class="line">dog1 = <span class="number">0x60400000b600</span></span><br><span class="line">weakdog1 = <span class="number">0x60400000b600</span></span><br><span class="line">weakdog1 = <span class="number">0x60400000b600</span></span><br><span class="line">dog2 = <span class="number">0x60400000b600</span></span><br><span class="line"><span class="keyword">retain</span> count: <span class="number">3</span></span><br></pre></td></tr></table></figure>可以验证：<ol><li><strong><em>__weak的作用是在不增加对象引用计数的前提下持有对象的引用</em></strong> </li><li><strong><em>mutableArray会增加所持有指针所指对象的引用计数（不论是不是强指针）</em></strong></li><li><strong><em>指针赋值可以使新的指针指向相同的地址（与本问题无关）</em></strong><h2 id="结论2"><a href="#结论2" class="headerlink" title="结论2"></a>结论2</h2>使用__weak的弱指针同样会使当前控制器被数组强引用，同样会造成当前控制器不释放<h1 id="结论3"><a href="#结论3" class="headerlink" title="结论3"></a>结论3</h1>通过以上分析可以看出，想要控制器得到释放，就不能让数组持有控制器的强引用，下面有三个方案可以达到这个目的：<h2 id="方法1-NSValue-不要使用这个了，最近发现会造成野指针，具体原因不明。"><a href="#方法1-NSValue-不要使用这个了，最近发现会造成野指针，具体原因不明。" class="headerlink" title="方法1 NSValue 不要使用这个了，最近发现会造成野指针，具体原因不明。"></a>方法1 <del>NSValue</del> 不要使用这个了，最近发现会造成野指针，具体原因不明。</h2><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">NSValue</span> *value = [<span class="built_in">NSValue</span> valueWithNonretainedObject:myObj];</span><br><span class="line">[array addObject:value];</span><br><span class="line"></span><br><span class="line">value.nonretainedObjectValue</span><br></pre></td></tr></table></figure><h2 id="方法2-NSPointerArray"><a href="#方法2-NSPointerArray" class="headerlink" title="方法2 NSPointerArray"></a>方法2 NSPointerArray</h2>参见：<a href="http://blog.csdn.net/jeffasd/article/details/60774974">http://blog.csdn.net/jeffasd/article/details/60774974</a><h2 id="方法3-Bridge"><a href="#方法3-Bridge" class="headerlink" title="方法3 Bridge"></a>方法3 Bridge</h2>增加一个中间层<figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">@interface</span> <span class="title">DelegateBridge</span>: <span class="title">NSObject</span> &lt;<span class="title">aDelegate</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">@property</span> (<span class="keyword">nonatomic</span>, <span class="keyword">assign</span>) <span class="keyword">id</span> &lt;aDelegate&gt;delegate;</span><br><span class="line"></span><br><span class="line">- (<span class="keyword">instancetype</span>)initWithDelegate:(<span class="keyword">id</span>&lt;aDelegate&gt;)delegate;</span><br><span class="line"></span><br><span class="line"><span class="keyword">@end</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">@implementation</span> <span class="title">DelegateBridge</span></span></span><br><span class="line"></span><br><span class="line">- (<span class="keyword">instancetype</span>)initWithDelegate:(<span class="keyword">id</span>&lt;aDelegate&gt;)delegate;</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">self</span> = [<span class="keyword">super</span> init];</span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">self</span>) &#123;</span><br><span class="line">        <span class="keyword">self</span>.delegate = delegate;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">self</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (<span class="keyword">void</span>)delegateMethod &#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">self</span>.delegate &amp;&amp; [<span class="keyword">self</span>.delegate respondsToSelector:<span class="keyword">@selector</span>(delegateMethod:)]) &#123;</span><br><span class="line">        [<span class="keyword">self</span>.delegate delegateMethod:aMessages];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">@end</span></span><br></pre></td></tr></table></figure><code>addDelegate()</code>的方法改为：<figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">- (<span class="keyword">void</span>)addDelegate:(<span class="keyword">id</span>&lt;aDelegate&gt;)delegate</span><br><span class="line">&#123;</span><br><span class="line">    DelegateBridge *bridge = [[DelegateBridge alloc] initWithDelegate:delegate];</span><br><span class="line">    [_delegates addObject:bridge];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ol></li></ol><div><h1>推荐文章<span style="font-size:0.45em; color:gray"></span></h1><ul><li><a href="http://www.iosprogrammer.tech/how-to-make-view-get-intrinsic-content-size/">最佳实践：iOS开发在xib/storyboard中自定义view</a></li><li><a href="http://www.iosprogrammer.tech/What-is-Content-Hugging-Priorities-Content-Compression-Resistance-Priorities/">什么是Content Hugging Priorities/Content Compression Resistance Priorities</a></li><li><a href="http://www.iosprogrammer.tech/UIStackView-Advanced-Knowledge/">UIStackView的正确使用姿势（最新最全、配视频教程）</a></li></ul></div>]]></content>
      
      
      
        <tags>
            
            <tag> iOS </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Scheme以及微信、支付宝等第三方功能的实现</title>
      <link href="iOS-Scheme-Theory-And-Practice/"/>
      <url>iOS-Scheme-Theory-And-Practice/</url>
      
        <content type="html"><![CDATA[<h2 id="理论"><a href="#理论" class="headerlink" title="理论"></a>理论</h2><p>在Apple的文档中，scheme在URL相关的内容中出现过，比如：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">This property contains the scheme. Any percent-encoded characters are not unescaped. For example, in the URL &#96;http:&#x2F;&#x2F;www.example.com&#x2F;index.html&#96; , the scheme is &#96;http&#96; .</span><br><span class="line">The full URL is the concatenation of the scheme, a colon ( &#96;:&#96; ), and the value of &#96;resourceSpecifier&#96; .</span><br></pre></td></tr></table></figure><p>紧接着这一段，有如下说明：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Note</span><br><span class="line">The term “protocol” is also sometimes used when talking about network-based URL schemes. However, not all URL schemes are networking protocols—data:&#x2F;&#x2F; URLs, for example.</span><br></pre></td></tr></table></figure><p>详情点击<a href="https://developer.apple.com/documentation/foundation/nsurl/1413437-scheme">这里</a>。可以看出，scheme是URL中 <strong>:</strong> 之前的部分。<br>在iOS/macOS/WatchOS 2中，可以利用scheme来标记APP并且通过它进行一些简单的通信。</p><h4 id="scheme的使用"><a href="#scheme的使用" class="headerlink" title="scheme的使用"></a>scheme的使用</h4><ol><li>设置scheme<br>Xcode项目的info.plist中增加URL types，这是一个数组，里面的每一项都是一个字典，默认只有URL Identifier——标记URL types中的某一个item，在这里可以添加URL Schemes。比如添加一个”test”</li><li>使用scheme，添加了scheme以后，重新run项目。<ol><li>可以在Safari中输入添加的scheme，然后就可以跳转到刚才的APP中了。</li><li>通过<code>UIApplication.shared.openURL</code>来进行APP间的跳转。如果是iOS9.0之后，需要先在info.plist中添加<a href="https://developer.apple.com/library/content/documentation/General/Reference/InfoPlistKeyReference/Articles/LaunchServicesKeys.html#//apple_ref/doc/uid/TP40009250-SW14">LSApplicationQueriesSchemes</a>，然后把要打开的scheme添加到里面。<br><img src="http://upload-images.jianshu.io/upload_images/424855-690eea9c590127f6.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240"></li></ol></li></ol><h2 id="高级用法"><a href="#高级用法" class="headerlink" title="高级用法"></a>高级用法</h2><ol><li>当APP被其他APP通过scheme调起的时候，可以通过<code>func application(_ app: UIApplication, open url: URL, options: [UIApplicationOpenURLOptionsKey : Any] = [:]) -&gt; Bool</code>方法从url参数中获取到当前启动这个APP的完整URL，还可以通过options获取到其他APP的**<em>Bundle Identifier**</em></li><li>在Safari中输入URL或者通过openURL来调起APP的时候，除了输入[scheme]://之外，还可以在后面带上一些内容，比如：<code>[scheme]://aaa=1?bbb=52</code></li></ol><h2 id="实战"><a href="#实战" class="headerlink" title="实战"></a>实战</h2><p>微信、支付宝、微博等应用的第三方登录、支付、分享功能，都是通过scheme来实现的。下面我们用微信的登录为例，来讲解一下scheme的使用过程。<br>要使用微信的授权登录功能，首先要去微信开放平台创建一个应用，需要我们填写应用名称、icon和Bundle Identifier，之后微信会把应用的AppId和AppSecret给我们。然后根据AppID集成微信的SDK，并且在URL types里面添加一个以appid为scheme的item。到这里，微信的分享功能就集成完成了。那么，每一步都在做什么呢？<br><img src="http://upload-images.jianshu.io/upload_images/424855-c63aa2111fe7ca58.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="微信授权过程.jpg"><br>其中，第3步中是否到服务器验证应该可以通过抓包来看到，但是我懒了，没有做。也不影响整体的流程。</p><h2 id="结语"><a href="#结语" class="headerlink" title="结语"></a>结语</h2><p>因为本人并不是微信的开发人员，以上内容可能会有出入，微信在安全方面做的应该更好。但是，大致的流程应该就是这样。其他平台、功能应该差别也不大。如有错误或者疑问可以在下面留言。</p><div><h1>推荐文章<span style="font-size:0.45em; color:gray"></span></h1><ul><li><a href="http://www.iosprogrammer.tech/how-to-make-view-get-intrinsic-content-size/">最佳实践：iOS开发在xib/storyboard中自定义view</a></li><li><a href="http://www.iosprogrammer.tech/What-is-Content-Hugging-Priorities-Content-Compression-Resistance-Priorities/">什么是Content Hugging Priorities/Content Compression Resistance Priorities</a></li><li><a href="http://www.iosprogrammer.tech/UIStackView-Advanced-Knowledge/">UIStackView的正确使用姿势（最新最全、配视频教程）</a></li></ul></div>]]></content>
      
      
      
        <tags>
            
            <tag> iOS </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>

<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>告诉你3个容易被忽略的可能造成循环引用的情况和2种不会造成循环引用的情况</title>
      <link href="ios/retain-cycle-problems/"/>
      <url>ios/retain-cycle-problems/</url>
      
        <content type="html"><![CDATA[<p>循环引用是iOS开发种十分常见的一个问题，也是面试中出现频率很高的一类问题，有些经验的开发者对循环引用都有所了解，也能在开发过程中尽量避免此类问题，但是随着项目的扩大和开发时间有限有时会不经意见给引用循环引用的问题。</p><p>这类问题虽然很多时候不会出现严重的影响，但是在其他一些条件下可能会带来很蹊跷的现象，本人就深受其害。所以在这里记录一下关于循环引用的一些常用知识，也希望对你有所帮助。</p><a id="more"></a><div class="note info"><p>到公众号【iOS开发栈】学习更多SwiftUI、iOS开发相关内容。</p></div><h1 id="什么是循环引用"><a href="#什么是循环引用" class="headerlink" title="什么是循环引用"></a>什么是循环引用</h1><p>造成循环引用问题的根本原因是iOS的引用计数机制，而在引用计数机制下如果有引用不能得到即时的释放就会造成了内存泄漏，这就是循环引用。</p><p>并且为了维持App的高性能，苹果并不没有也不打算引入类似Android中的垃圾回收机制。这就造成了如果我们导致了循环引用，那么这块内存就无法得到回收。</p><p>泄漏的内存多了会造成系统强制kill掉我们的应用程序，虽然这种现象我还没有见到过不过原理上来说会出现这种情况的。</p><p>一旦有没有得到即时回收的对象内存，还可能造成一些无可预期的问题。比方说我遇到的一个问题：由于一个VC没有得到即时释放，导致里面的一个定时任务不停执行，最终导致了营收不及预期。</p><p>所以循环引用的问题，我们在开发的过程中一定要重视起来。</p><h1 id="下面3种情况会造成循环引用"><a href="#下面3种情况会造成循环引用" class="headerlink" title="下面3种情况会造成循环引用"></a>下面3种情况会造成循环引用</h1><p>会造成循环引用问题的情形很多，下面我列举了3种情况，其中有一些是老生长谈，有些是需要特别注意的，有些真的是手滑造成的。</p><p>在编码过程中时刻谨记这些情况真的可以避免很多错误发生。</p><h3 id="block"><a href="#block" class="headerlink" title="block"></a>block</h3><p>这里的block指的是view对vc的回调、model对vc的回调或者子view对父view的回调。</p><p>不论是子view还是vc中的model，我们都习惯于用strong来修饰它们，这时候在它们的block回调里面用到<code>self</code>的时候一定要用<code>weak self</code>。</p><p>并且，切记成员变量<code>_xxx</code>如果在这种block中使用也会造成循环引用。使用弱指针来指向成员变量是一种解决方案，就像这样<code>self-&gt;_redView.backgroundColor = [UIColor greenColor];</code></p><h3 id="strong修饰的delegate"><a href="#strong修饰的delegate" class="headerlink" title="strong修饰的delegate"></a>strong修饰的delegate</h3><p>我们都知道delegate要使用weak来修饰，不过在编码过程中由于疏忽可能会误用strong来修饰delegate，所以如果当你遇到循环引用可是怎么也找不到原因时，不妨从这个思路找找。我就遇到过这种情况😭 。</p><h3 id="一些异步回调"><a href="#一些异步回调" class="headerlink" title="一些异步回调"></a>一些异步回调</h3><p>有一些异步回调是使用block的形式来处理的，这就可能引起循环引用。</p><p>有一些系统的功能比方说NSTimer的定时任务就会对self造成强引用。</p><p>还有一些是我们自己的功能比方说网络请求.</p><h1 id="下面2种情况不会造成循环引用"><a href="#下面2种情况不会造成循环引用" class="headerlink" title="下面2种情况不会造成循环引用"></a>下面2种情况不会造成循环引用</h1><h3 id="用Masonry给view添加约束"><a href="#用Masonry给view添加约束" class="headerlink" title="用Masonry给view添加约束"></a>用Masonry给view添加约束</h3><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">[<span class="keyword">self</span>.redView mas_makeConstraints:^(MASConstraintMaker *make) &#123;</span><br><span class="line">    make.top.equalTo(@<span class="number">130</span>);</span><br><span class="line">    make.left.equalTo(<span class="keyword">self</span>.view.mas_left).offset(<span class="number">10</span>);</span><br><span class="line">    make.width.equalTo(@<span class="number">60</span>);</span><br><span class="line">    make.height.equalTo(@<span class="number">40</span>);</span><br><span class="line">&#125;];</span><br></pre></td></tr></table></figure><p>这种用法是不会造成循环引用的，可以放心使用。</p><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">- (<span class="built_in">NSArray</span> *)mas_makeConstraints:(<span class="keyword">void</span>(^)(MASConstraintMaker *))block &#123;</span><br><span class="line">    <span class="keyword">self</span>.translatesAutoresizingMaskIntoConstraints = <span class="literal">NO</span>;</span><br><span class="line">    MASConstraintMaker *constraintMaker = [[MASConstraintMaker alloc] initWithView:<span class="keyword">self</span>];</span><br><span class="line">    block(constraintMaker);</span><br><span class="line">    <span class="keyword">return</span> [constraintMaker install];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>从源码来看，这里的block其实是一个同步的方法，所以这里是不会造成循环引用的。</p><h3 id="使用UIView静态方法实现动画"><a href="#使用UIView静态方法实现动画" class="headerlink" title="使用UIView静态方法实现动画"></a>使用UIView静态方法实现动画</h3><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">[<span class="built_in">UIView</span> animateWithDuration:<span class="number">3</span> animations:^&#123;</span><br><span class="line">    <span class="keyword">self</span>.redView.backgroundColor = [<span class="built_in">UIColor</span> greenColor];</span><br><span class="line">&#125;];</span><br></pre></td></tr></table></figure><p>这种情况虽然在block里面引用到了self，但是不会造成循环引用。因为<code>animateWithDuration:</code>是一个类方法。</p><h1 id="开发中怎么解决循环引用问题"><a href="#开发中怎么解决循环引用问题" class="headerlink" title="开发中怎么解决循环引用问题"></a>开发中怎么解决循环引用问题</h1><p>首先这里的方法并不是什么工程级别的高深方法，只是我在开发过程中总结到的一些实用、便捷的小技巧。</p><p>当怀疑某个控制器没有得到即时的释放时，可以在这个控制器里面重写<code>dealloc</code>函数然后打印一行文字，再在这行文字上加一个断点。这样我们就可以通过进出这个控制器来看到它的<code>dealloc</code>方法是不是即时被调用了。如果没有即时调用那就是有循环引用产生，相反则没有。</p><p>确定了某个控制器内确实出现了循环引用之后，就需要定位是哪里导致的循环引用了。</p><p>我个人习惯先看是不是block导致的，要想快速的搜索到一个文件里面所有的block可以通过搜索<code>^&#123;</code>来定位，之后就是检查每个block里面是不是按规范使用了<code>self</code>。检查过程一定要仔细，不然你很可能还得重来一遍😭 。</p><p>检查完所有的block后有99%的可能已经解决了循环引用的问题，不然的话就再去检查一下delegate和是不是使用了<code>NSTimer</code>。</p><p>这个过程下来100%可以解决掉循环引用的问题，否则你来公众号找我。</p><div class="note info"><p>到公众号【iOS开发栈】学习更多SwiftUI、iOS开发相关内容。</p></div>]]></content>
      
      
      
        <tags>
            
            <tag> iOS </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>SwiftUI怎么实现UISearchBar</title>
      <link href="swiftui/swiftui-searchbar/"/>
      <url>swiftui/swiftui-searchbar/</url>
      
        <content type="html"><![CDATA[<p>SwiftUI没有提供UISearchBar，虽然我们可以通过使用TextField来自己实现SeachBar的效果，不过要想实现一个和UISearchBar同样的控件并不容易，尤其是清除按钮和搜索图标。</p><p>这里推荐直接使用UISearchBar和UIViewRepresentable协议来一个SearchBar。</p><a id="more"></a><div class="note info"><p>到公众号【iOS开发栈】学习更多SwiftUI、iOS开发相关内容。</p></div><p><img src="../../images/first/swiftui-uisearchbar.png"></p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">SearchBar</span>: <span class="title">UIViewRepresentable</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Binding</span> <span class="keyword">var</span> text: <span class="type">String</span></span><br><span class="line">    <span class="keyword">var</span> placeholder: <span class="type">String</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">var</span> onCommit: ((<span class="keyword">_</span> text: <span class="type">String</span>) -&gt; <span class="type">Void</span>)<span class="operator">?</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">func</span> <span class="title">makeUIView</span><span class="params">(context: UIViewRepresentableContext&lt;SearchBar&gt;)</span></span> -&gt; <span class="type">UISearchBar</span> &#123;</span><br><span class="line">        <span class="keyword">let</span> searchBar <span class="operator">=</span> <span class="type">UISearchBar</span>(frame: .zero)</span><br><span class="line">        searchBar.delegate <span class="operator">=</span> context.coordinator</span><br><span class="line"></span><br><span class="line">        searchBar.placeholder <span class="operator">=</span> placeholder</span><br><span class="line">        searchBar.autocapitalizationType <span class="operator">=</span> .none</span><br><span class="line">        searchBar.searchBarStyle <span class="operator">=</span> .minimal</span><br><span class="line">        <span class="keyword">return</span> searchBar</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">func</span> <span class="title">updateUIView</span><span class="params">(<span class="keyword">_</span> uiView: UISearchBar, context: UIViewRepresentableContext&lt;SearchBar&gt;)</span></span> &#123;</span><br><span class="line">        uiView.text <span class="operator">=</span> text</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">func</span> <span class="title">makeCoordinator</span><span class="params">()</span></span> -&gt; <span class="type">SearchBar</span>.<span class="type">Coordinator</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="type">Coordinator</span>(text: <span class="variable">$text</span>, onCommit: <span class="keyword">self</span>.onCommit)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="class"><span class="keyword">class</span> <span class="title">Coordinator</span>: <span class="title">NSObject</span>, <span class="title">UISearchBarDelegate</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="meta">@Binding</span> <span class="keyword">var</span> text: <span class="type">String</span></span><br><span class="line">        <span class="keyword">var</span> onCommit: ((<span class="keyword">_</span> text: <span class="type">String</span>) -&gt; <span class="type">Void</span>)<span class="operator">?</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">init</span>(text: <span class="type">Binding</span>&lt;<span class="type">String</span>&gt;, onCommit: ((<span class="keyword">_</span> text: <span class="type">String</span>) -&gt; <span class="type">Void</span>)<span class="operator">?</span>) &#123;</span><br><span class="line">            _text <span class="operator">=</span> text</span><br><span class="line">            <span class="keyword">self</span>.onCommit <span class="operator">=</span> onCommit</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">func</span> <span class="title">searchBar</span><span class="params">(<span class="keyword">_</span> searchBar: UISearchBar, textDidChange searchText: String)</span></span> &#123;</span><br><span class="line">            text <span class="operator">=</span> searchText</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="function"><span class="keyword">func</span> <span class="title">searchBarSearchButtonClicked</span><span class="params">(<span class="keyword">_</span> searchBar: UISearchBar)</span></span> &#123;</span><br><span class="line">            <span class="keyword">if</span> <span class="keyword">let</span> onCommit <span class="operator">=</span> <span class="keyword">self</span>.onCommit &#123;</span><br><span class="line">                onCommit(searchBar.text <span class="operator">??</span> <span class="string">&quot;&quot;</span>)</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>UIViewRepresentable</code>是SwiftUI框架中提供的用于将UIView转换成SwiftUI中View的协议。</p><p><code>func makeUIView(context: Self.Context) -&gt; Self.UIViewType</code>用来创建View的方法，遵守UIViewRepresentable协议的类必须要实现这个方法。它的返回值是一个UIView类的实例。这个方法只会在创建View时调用一次，当View需要更新时会调用下面的这个方法。</p><p><code>func updateUIView(_ uiView: Self.UIViewType, context: Self.Context)</code>当UIView发生任何需要更新状态的事件时，这个方法就会被调用来更新View的状态。</p><p><code>func makeCoordinator() -&gt; Self.Coordinator</code>需要一个<code>Coordinator</code>的实例作为返回值。它通常用来处理一些事件（点击、时间、delegate、通知）引起了UIView的状态变化后，能够将新的状态反映到View上。</p><div class="note info"><p>到公众号【iOS开发栈】学习更多SwiftUI、iOS开发相关内容。</p></div>]]></content>
      
      
      
        <tags>
            
            <tag> SwiftUI </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>iOS设置渐变色，给border设置渐变色</title>
      <link href="ios/ios-gradient-color/"/>
      <url>ios/ios-gradient-color/</url>
      
        <content type="html"><![CDATA[<p>本文将从4行代码出发给一个view设置渐变色，分别会谈到几个重要的渐变色相关属性，在使用过程中有几个需要特别关注的点。</p><p>给一个view的border设置渐变色是比较高阶的用法，希望本文可以在这个方面帮助到你。</p><a id="more"></a><p><img src="../../images/first/ios-gradient-color-border.png" alt="ios渐变色"></p><div class="note info"><p>到公众号【iOS开发栈】学习更多SwiftUI、iOS开发相关内容。</p></div><h1 id="给view设置渐变色"><a href="#给view设置渐变色" class="headerlink" title="给view设置渐变色"></a>给view设置渐变色</h1><p>通过4行代码就可以给一个view设置渐变色：</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> view <span class="operator">=</span> <span class="type">UIView</span>(frame: <span class="type">CGRect</span>(x: <span class="number">100</span>, y: <span class="number">100</span>, width: <span class="number">100</span>, height: <span class="number">100</span>))</span><br><span class="line"><span class="keyword">let</span> gradientLayer <span class="operator">=</span> <span class="type">CAGradientLayer</span>()</span><br><span class="line">gradientLayer.frame <span class="operator">=</span> view.bounds</span><br><span class="line"><span class="comment">// @[(__bridge id)[UIColor redColor].CGColor, (__bridge id)[UIColor yellowColor].CGColor]</span></span><br><span class="line">gradientLayer.colors <span class="operator">=</span> [<span class="type">UIColor</span>.red.cgColor, <span class="type">UIColor</span>.yellow.cgColor]</span><br><span class="line">view.layer.addSublayer(gradientLayer)</span><br></pre></td></tr></table></figure><p>在创建<code>CAGradientLayer</code>以后需要设置<code>frame</code>才能展示出来，否则它的大小会使用默认的0。</p><p>渐变色会根据<code>colors</code>数组来展示，这个数组的类型是<code>CGColorRef</code>，所以需要用<code>.cgColor</code>强制转换；如果使用的OC语法，必须加上<code>(__bridge id)</code>，否则渐变色会显示不出来。</p><p>默认情况下渐变会从上至下，可是通过设置<code>startPoint</code>和<code>endPoint</code>来改变这个顺序：</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">gradientLayer.startPoint <span class="operator">=</span> <span class="type">CGPoint</span>(x: <span class="number">0</span>, y: <span class="number">0</span>)</span><br><span class="line">gradientLayer.endPoint <span class="operator">=</span> <span class="type">CGPoint</span>(x: <span class="number">1</span>, y: <span class="number">1</span>)</span><br></pre></td></tr></table></figure><p>这两个点的范围是从0到1，也就是说最左边和最上边是0，最下和最右是1。这个例子中渐变会变成从左上角到右下角。</p><p>渐变色还有一个重要的属性是<code>locations</code>，这个属性是用来指定<code>colors</code>中设置的每个颜色的终点的。</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">gradientLayer.locations <span class="operator">=</span> [<span class="number">0.2</span>, <span class="number">0.8</span>]</span><br></pre></td></tr></table></figure><p>locations中元素的范围是从0到1。在这里，数组中的第一个元素<em>0.2</em>指定了colors数组中第一个元素<em>红色</em>的终点是0.2，也就是说把整个渐变色范围分成10份，从开始到<em>2/10</em>处都是纯红色，从<em>2/10</em>到<em>8/10</em>处是纯红色到纯黄色的渐变，而从<em>8/10</em>到<em>10/10</em>是纯黄色。</p><h1 id="给view的border设置渐变色"><a href="#给view的border设置渐变色" class="headerlink" title="给view的border设置渐变色"></a>给view的border设置渐变色</h1><p>使用<code>UIBezierPath</code>来创建一个带圆角的<code>CAShapeLayer</code>，并且把它的圆角设置成view的圆角，就可以把一个view的border设置为渐变色。</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="operator">...</span> <span class="comment">// 同上给view设置gradientLayer</span></span><br><span class="line">        </span><br><span class="line"><span class="keyword">let</span> shapeLayer <span class="operator">=</span> <span class="type">CAShapeLayer</span>()</span><br><span class="line">shapeLayer.borderWidth <span class="operator">=</span> <span class="number">1</span></span><br><span class="line">shapeLayer.path <span class="operator">=</span> <span class="type">UIBezierPath</span>(roundedRect: gradientLayer.bounds, cornerRadius: <span class="number">10</span>).cgPath</span><br><span class="line">shapeLayer.fillColor <span class="operator">=</span> <span class="type">UIColor</span>.clear.cgColor <span class="comment">// 必须要设置成clearColor或者nil，默认是黑色</span></span><br><span class="line">shapeLayer.strokeColor <span class="operator">=</span> <span class="type">UIColor</span>.white.cgColor <span class="comment">// 随便设置一个非clearColor的颜色</span></span><br><span class="line">        </span><br><span class="line">gradientLayer.mask <span class="operator">=</span> shapeLayer</span><br><span class="line"></span><br><span class="line">view.layer.addSublayer(gradientLayer)</span><br></pre></td></tr></table></figure><ol><li><em>borderWidth</em> shapeLayer的border宽度和view的相同，可以根据设计图来设置。</li><li><em>cornerRadius</em> UIBezierPath的圆角和view的圆角相同；<em>roundedRect</em>和<em>CAGradientLayer</em>的大小相同。</li><li><em>fillColor</em> 是shapeLayer的填充色，默认是黑色，建议设置成nil或者是透明色<code>clearColor</code></li><li><em>strokeColor</em> 是border的描边色，如果设置成clearColor的话就不会绘制出来border了，这里随便一个颜色就是让其能够绘制出来，实际使用的是渐变色</li><li><em>mask</em> 用shapeLayer作为gradientLayer的mask，可以让gradientLayer内部挖空，只保留边缘border的渐变颜色</li><li>最终把渐变色layer添加到view.layer上，shapeLayer只是用来修饰gradientlayer的，目的是把gradientlayer的内部挖空，并且把border和圆角做出来。</li></ol><div class="note info"><p>到公众号【iOS开发栈】学习更多SwiftUI、iOS开发相关内容。</p></div><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>通过这篇文章我们了解了怎么给一个view设置渐变色，并详细阐述了渐变色的几个重要属性。关于给border设置渐变色是一个进阶的知识点。</p><p>希望本篇文章能够帮助到你，也欢迎你把文章分享到朋友圈或微博。</p><p>有任何问题都可以到公众号给我发信息。</p>]]></content>
      
      
      
        <tags>
            
            <tag> iOS </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>environment和environmentObject的区别及适用场景</title>
      <link href="swiftui/environment-vs-environmentObject/"/>
      <url>swiftui/environment-vs-environmentObject/</url>
      
        <content type="html"><![CDATA[<p>SwiftUI中传递环境变量时会发现两个相似的方法：<code>environment&lt;V&gt;(_ keyPath:, _ value:)</code>和<code>environmentObject&lt;T&gt;(_ object:)</code>，这篇文章我们来看一下这两个方法的不同之处和分别的适用场景。</p><a id="more"></a><p><img src="../../images/first/swiftui-environmentobject-environment.png" alt="Swift环境变量对比"></p><div class="note info"><p>到公众号【iOS开发栈】学习更多SwiftUI、iOS开发相关内容。回复“博客”免费获取各大互联网公司面试题。</p></div><p>首先要明确的一点是，这两个方法都是用来设置环境变量的，而环境变量会影响到被设置变量的视图以及它的所有子视图，并且这个传递过程不需要明确指出。</p><p>也就是说，假设有三个视图，view1、view2、view3，其中view2和view3是view1的子视图，要想在view2和view3中使用view1设置的环境变量的话，只需要直接在view中使用<code>@EnvironmentObject</code>或者<code>@Environment</code>而不需要在创建view2和view3的时候显式传参。</p><h1 id="EnvironmentObject"><a href="#EnvironmentObject" class="headerlink" title="@EnvironmentObject"></a>@EnvironmentObject</h1><p>下面以<code>@EnvironmentObject</code>举例说明上面的这段话：</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 公众号——iOS开发栈</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">OfficalAccount</span>: <span class="title">ObservableObject</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Published</span> <span class="keyword">var</span> amount <span class="operator">=</span> <span class="number">3000</span> <span class="comment">// 订阅人数</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">DetailView</span>: <span class="title">View</span> </span>&#123;</span><br><span class="line">    <span class="meta">@EnvironmentObject</span> <span class="keyword">var</span> account: <span class="type">OfficalAccount</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">var</span> body: <span class="keyword">some</span> <span class="type">View</span> &#123;</span><br><span class="line">        <span class="type">VStack</span> &#123;</span><br><span class="line">            <span class="type">Button</span>(<span class="string">&quot;Increase Score in detailView&quot;</span>) &#123;</span><br><span class="line">                account.amount <span class="operator">+=</span> <span class="number">1</span></span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="type">Text</span>(<span class="string">&quot;account: <span class="subst">\(account.amount)</span>&quot;</span>)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">DetailView2</span>: <span class="title">View</span> </span>&#123;</span><br><span class="line">    <span class="meta">@EnvironmentObject</span> <span class="keyword">var</span> account: <span class="type">OfficalAccount</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">var</span> body: <span class="keyword">some</span> <span class="type">View</span> &#123;</span><br><span class="line">        <span class="type">Text</span>(<span class="string">&quot;Score: <span class="subst">\(account.amount)</span>&quot;</span>)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">ContentView</span>: <span class="title">View</span> </span>&#123;</span><br><span class="line">    <span class="meta">@StateObject</span> <span class="keyword">var</span> account <span class="operator">=</span> <span class="type">OfficalAccount</span>()</span><br><span class="line"></span><br><span class="line">    <span class="keyword">var</span> body: <span class="keyword">some</span> <span class="type">View</span> &#123;</span><br><span class="line">        <span class="type">VStack</span> &#123;</span><br><span class="line">            <span class="type">Button</span>(<span class="string">&quot;Increase Score&quot;</span>) &#123;</span><br><span class="line">                account.amount <span class="operator">+=</span> <span class="number">1</span></span><br><span class="line">            &#125;</span><br><span class="line">            </span><br><span class="line">            <span class="type">DetailView</span>()</span><br><span class="line">            <span class="type">DetailView2</span>()</span><br><span class="line">        &#125;</span><br><span class="line">        .environmentObject(account)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上面的例子是以我的公众号（”iOS开发栈“）的订阅人数做说明，可以看出<em>ContentView</em>创建<em>DetailView</em>和<em>DetailView2</em>时并没有直接传递变量<em>accout</em>，但是结果是这两个子视图中的数量显示会随着点击按钮而增加。</p><p>对上面使用<code>environmentObject</code>进行环境变量传递有几点需要注意：</p><ul><li>使用<code>@Environment</code>、<code>@StateObject</code>、<code>@ObservedObject</code>包装的类必须遵守<code>ObservableObject</code>协议，并且只能是类不能是结构体，否则会报错 <mark class="label danger">Non-class type OfficalAccount cannot conform to class protocol ObservableObject</mark></li><li><code>@Published</code>也只能在<em>class</em>中使用，如果放在了struct中，会报错<mark class="label danger">'wrappedValue' is unavailable: </mark></li><li>使用<code>@EnvironmentObject</code>包装的变量是不需要初始化的，编译器会从环境变量中获取这个对象的值</li><li>在子视图中可以修改了环境变量的值，并且这个改变会在当前的视图层级中传递</li></ul><h1 id="Environment"><a href="#Environment" class="headerlink" title="@Environment"></a>@Environment</h1><p>而对于<code>@Environment</code>来说，它主要是用来处理一些当前的系统设置的，比如说语言、时区、黑暗模式、CoreData的Context等。</p><p>在使用过程中一个很大的不同是，<code>@Environment(_ keyPath:)</code>需要指定一个类型为<code>KeyPath</code>的参数，而这个参数大多数情况下我们都是使用的<code>EnvironmentValues</code>中已经定义好的，比如<code>managedObjectContext</code>/<code>locale</code>等。</p><p>下面以使用<em>CoreData</em>为例说明使用方法：</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// App.swift</span></span><br><span class="line"><span class="operator">...</span></span><br><span class="line"><span class="keyword">let</span> persistenceController <span class="operator">=</span> <span class="type">PersistenceController</span>.shared</span><br><span class="line"><span class="operator">...</span></span><br><span class="line"><span class="keyword">var</span> body: <span class="keyword">some</span> <span class="type">Scene</span> &#123;</span><br><span class="line">    <span class="type">WindowGroup</span> &#123;</span><br><span class="line">        <span class="type">ContentView</span>()</span><br><span class="line">            .environment(\.managedObjectContext, persistenceController.container.viewContext)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="operator">...</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// ContentView.swift</span></span><br><span class="line"><span class="operator">...</span></span><br><span class="line"><span class="meta">@Environment</span>(\.managedObjectContext) <span class="keyword">private</span> <span class="keyword">var</span> viewContext</span><br><span class="line"><span class="operator">...</span></span><br><span class="line"><span class="keyword">let</span> newItem <span class="operator">=</span> <span class="type">Item</span>(context: viewContext)</span><br><span class="line">newItem.platform <span class="operator">=</span> <span class="number">1</span></span><br><span class="line"><span class="operator">...</span></span><br></pre></td></tr></table></figure><p>在这个例子中，我们在<em>App.swift</em>中创建了<code>persistenceController</code>并通过调用<code>.environment</code>把值传递给了<em>ContentView</em>。<em>ContentView</em>中使用<code>@Environment(\.managedObjectContext) private var viewContext</code>获取到了这个环境变量。</p><p>除了需要一个KeyPath和上面提到的主要用来处理系统自带的环境变量外，<code>@Environment</code>和<code>@EnvironmentObject</code>在用法上相差不大。</p><div class="note info"><p>到公众号【iOS开发栈】学习更多SwiftUI、iOS开发相关内容。回复“博客”免费获取各大互联网公司面试题。</p></div><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>通过灵活使用环境变量，可以让开发过程更加简单，页面之间可以写更少的值传递（正向、反相）相关代码。通过本文对<code>Environment</code>和<code>EnvironmentObject</code>的对比，我们更深入的了解了SwiftUI中环境变量的一些使用细节。</p><p>如果本文对你有帮助请帮忙分享到朋友圈或者微博。</p><p>如果有任何问题也可以到公众号联系我。</p>]]></content>
      
      
      
        <tags>
            
            <tag> SwiftUI </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>在SwiftUI中实现UISegmentControl</title>
      <link href="swiftui/swiftui-uisegmentcontrol/"/>
      <url>swiftui/swiftui-uisegmentcontrol/</url>
      
        <content type="html"><![CDATA[<p>在SwiftUI中官方把控件做了精简，造成有些在UIKit中使用的控件找不到了。这篇文章来看一下UIPickerView在SwiftUI中是怎么表示的。</p><a id="more"></a><p>了解了一些SwiftUI的基础知识以后，应该就知道有一个<code>Picker</code>控件，想要实现UISegmentControl的效果就要用到这个控件。</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@State</span> <span class="keyword">var</span> platform <span class="operator">=</span> <span class="number">1</span></span><br><span class="line">    </span><br><span class="line"><span class="keyword">var</span> body: <span class="keyword">some</span> <span class="type">View</span> &#123;</span><br><span class="line">    <span class="type">VStack</span> &#123;</span><br><span class="line">        <span class="type">Picker</span>(<span class="string">&quot;平台名称&quot;</span>, selection: <span class="variable">$platform</span>) &#123;</span><br><span class="line">            <span class="type">Text</span>(<span class="string">&quot;支付宝&quot;</span>).tag(<span class="number">1</span>).navigationTitle(<span class="string">&quot;选择平台&quot;</span>)</span><br><span class="line">            <span class="type">Text</span>(<span class="string">&quot;京东金融&quot;</span>).tag(<span class="number">2</span>)</span><br><span class="line">        &#125;</span><br><span class="line">        .pickerStyle(<span class="type">SegmentedPickerStyle</span>())</span><br><span class="line">        </span><br><span class="line">        <span class="type">Text</span>(<span class="string">&quot;<span class="subst">\(platform)</span>&quot;</span>)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>使用这段代码就可以得到一个UISegmentControl效果的Picker了。</p><p>其中关键部分是<code>.pickerStyle(SegmentedPickerStyle())</code>，pickerStyle是一个设置Picker样式的Modifier，<code>SegmentedPickerStyle</code>就是外型和UISegmentControl一摸一样的效果。</p><p>除了SegmentedPickerStyle以外，pickerStyle还有下面几种类型：</p><ul><li><code>DefaultPickerStyle</code> 在不同平台有不同的展现形式。iOS平台上和<em>InlinePickerStyle</em>相同都是滚轮样式；MacOS平台和<em>MenuPickerStyle</em>相同；tvOS平台上和<em>SegmentedPickerStyle</em>相同</li><li><code>InlinePickerStyle</code>/<code>WheelPickerStyle</code> 滚轮样式</li><li><code>MenuPickerStyle</code> 点击后Picker的text后弹出选项，有点类似于<code>MenuController</code></li><li><code>RadioGroupPickerStyle</code> MacOS上使用的，所有选项一字排开，每个前面都有一个复选框☑️</li><li><code>SegmentedPickerStyle</code> 上面说的模仿UISegmentControl的外形，使用这种style的时候，Picker的content只能是Text或者Image</li></ul><div class="note info"><p>到公众号【iOS开发栈】学习更多SwiftUI、iOS开发相关内容。</p></div>]]></content>
      
      
      
        <tags>
            
            <tag> SwiftUI </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>3个关于SwiftUI中TextField不得不看的知识点</title>
      <link href="swiftui/swiftui-textfield/"/>
      <url>swiftui/swiftui-textfield/</url>
      
        <content type="html"><![CDATA[<p>几乎每一个iOS App都需要处理用户交互，输入框作为获取用户输入内容的最常用控件之一是开发者经常用到的一个控件。这篇文章我们来看一下在iOS14中怎么使用全新的SwiftUI框架来处理TextField。</p><a id="more"></a><div class="note info"><p>到公众号【iOS开发栈】学习更多SwiftUI、iOS开发相关内容。</p></div><p><img src="../../images/first/swiftui-textfiled.png" alt="SwiftUI TextField知识点"></p><h1 id="SwiftUI创建一个基础的TextField"><a href="#SwiftUI创建一个基础的TextField" class="headerlink" title="SwiftUI创建一个基础的TextField"></a>SwiftUI创建一个基础的TextField</h1><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">ContentView</span>: <span class="title">View</span> </span>&#123;</span><br><span class="line">    <span class="meta">@State</span> <span class="keyword">private</span> <span class="keyword">var</span> aStr <span class="operator">=</span> <span class="string">&quot;&quot;</span></span><br><span class="line">    <span class="keyword">var</span> body: <span class="keyword">some</span> <span class="type">View</span> &#123;</span><br><span class="line">        <span class="type">VStack</span> &#123;</span><br><span class="line">            <span class="type">TextField</span>(<span class="string">&quot;公众号&lt;iOS开发栈&gt;&quot;</span>, text: <span class="variable">$aStr</span>)</span><br><span class="line">            </span><br><span class="line">            <span class="type">Text</span>(aStr)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>创建一个<code>TextField</code>需要两个参数，一个占位符和一个<a href="https://www.iosprogrammer.tech/swiftui/swiftui-data-flow.html"><code>Bind&lt;Binding&lt;String</code></a>。</p><h1 id="TextFieldStyle"><a href="#TextFieldStyle" class="headerlink" title="TextFieldStyle"></a>TextFieldStyle</h1><p>通过设置<code>textFieldStyle</code>可以修改<code>TextField</code>的展现样式，在SwiftUI中系统自带了UIKit框架中的几个样式：<code>DefaultTextFieldStyle</code>/<code>PlainTextFieldStyle</code>/<code>RoundedBorderTextFieldStyle</code>。</p><p>设置的方法是：</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">TextField</span>(<span class="string">&quot;公众号&lt;iOS开发栈&gt;&quot;</span>, text: <span class="variable">$aStr</span>)</span><br><span class="line">    .textFieldStyle(<span class="type">DefaultTextFieldStyle</span>())</span><br></pre></td></tr></table></figure><blockquote><p>如果系统自带的这三种样式都不能满足需求，也可以自定义TextField的样式</p></blockquote><h1 id="TextField文本对齐方式"><a href="#TextField文本对齐方式" class="headerlink" title="TextField文本对齐方式"></a>TextField文本对齐方式</h1><p>在SwiftUI中设置TextField的文本对齐方式使用的modifier是<code>multilineTextAlignment</code>，其中包含<code>leading</code>/<code>center</code>/<code>trailing</code>三种对齐方式。</p><p>使用这个modifier的方法如下：</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">TextField</span>(<span class="string">&quot;公众号&lt;iOS开发栈&gt;&quot;</span>, text: <span class="variable">$aStr</span>)</span><br><span class="line">    .multilineTextAlignment(.trailing)</span><br></pre></td></tr></table></figure><div class="note info"><p>到公众号【iOS开发栈】学习更多SwiftUI、iOS开发相关内容。</p></div><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>这篇文章对SwiftUI框架中的<code>TextFiled</code>控件进行了讲解，主要涉及了创建方法、修改展示样式和设置文本对齐方法三个方面，希望对你有所帮助。</p>]]></content>
      
      
      
        <tags>
            
            <tag> SwiftUI </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>SwiftUI给Color添加扩展支持十六进制字符串</title>
      <link href="swiftui/SwiftUI-Color-Hex/"/>
      <url>swiftui/SwiftUI-Color-Hex/</url>
      
        <content type="html"><![CDATA[<p>SwiftUI中使用<code>Color</code>表示颜色，为了能够尽量独立的使用SwiftUI特性，我们通过给Color添加一个简单的扩展来满足对十六进制颜色的使用。</p><a id="more"></a><p>下面是这个扩展的所有代码：</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">extension</span> <span class="title">Color</span> </span>&#123;</span><br><span class="line">    <span class="keyword">init</span>(hex: <span class="type">String</span>) &#123;</span><br><span class="line">        <span class="keyword">let</span> hex <span class="operator">=</span> hex.trimmingCharacters(<span class="keyword">in</span>: <span class="type">CharacterSet</span>.alphanumerics.inverted)</span><br><span class="line">        <span class="keyword">var</span> int: <span class="type">UInt64</span> <span class="operator">=</span> <span class="number">0</span></span><br><span class="line">        <span class="type">Scanner</span>(string: hex).scanHexInt64(<span class="operator">&amp;</span>int)</span><br><span class="line">        <span class="keyword">let</span> a, r, g, b: <span class="type">UInt64</span></span><br><span class="line">        <span class="keyword">switch</span> hex.count &#123;</span><br><span class="line">        <span class="keyword">case</span> <span class="number">3</span>: <span class="comment">// RGB (12-bit)</span></span><br><span class="line">            (a, r, g, b) <span class="operator">=</span> (<span class="number">255</span>, (int <span class="operator">&gt;&gt;</span> <span class="number">8</span>) <span class="operator">*</span> <span class="number">17</span>, (int <span class="operator">&gt;&gt;</span> <span class="number">4</span> <span class="operator">&amp;</span> <span class="number">0xF</span>) <span class="operator">*</span> <span class="number">17</span>, (int <span class="operator">&amp;</span> <span class="number">0xF</span>) <span class="operator">*</span> <span class="number">17</span>)</span><br><span class="line">        <span class="keyword">case</span> <span class="number">6</span>: <span class="comment">// RGB (24-bit)</span></span><br><span class="line">            (a, r, g, b) <span class="operator">=</span> (<span class="number">255</span>, int <span class="operator">&gt;&gt;</span> <span class="number">16</span>, int <span class="operator">&gt;&gt;</span> <span class="number">8</span> <span class="operator">&amp;</span> <span class="number">0xFF</span>, int <span class="operator">&amp;</span> <span class="number">0xFF</span>)</span><br><span class="line">        <span class="keyword">case</span> <span class="number">8</span>: <span class="comment">// ARGB (32-bit)</span></span><br><span class="line">            (a, r, g, b) <span class="operator">=</span> (int <span class="operator">&gt;&gt;</span> <span class="number">24</span>, int <span class="operator">&gt;&gt;</span> <span class="number">16</span> <span class="operator">&amp;</span> <span class="number">0xFF</span>, int <span class="operator">&gt;&gt;</span> <span class="number">8</span> <span class="operator">&amp;</span> <span class="number">0xFF</span>, int <span class="operator">&amp;</span> <span class="number">0xFF</span>)</span><br><span class="line">        <span class="keyword">default</span>:</span><br><span class="line">            (a, r, g, b) <span class="operator">=</span> (<span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">0</span>)</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">self</span>.<span class="keyword">init</span>(</span><br><span class="line">            .sRGB,</span><br><span class="line">            red: <span class="type">Double</span>(r) <span class="operator">/</span> <span class="number">255</span>,</span><br><span class="line">            green: <span class="type">Double</span>(g) <span class="operator">/</span> <span class="number">255</span>,</span><br><span class="line">            blue:  <span class="type">Double</span>(b) <span class="operator">/</span> <span class="number">255</span>,</span><br><span class="line">            opacity: <span class="type">Double</span>(a) <span class="operator">/</span> <span class="number">255</span></span><br><span class="line">        )</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>使用方法如下：</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">Color</span>(hex: <span class="string">&quot;#FF6D5D&quot;</span>)</span><br></pre></td></tr></table></figure><div class="note info"><p>到公众号【iOS开发栈】学习更多SwiftUI、iOS开发相关内容。</p></div>]]></content>
      
      
      
        <tags>
            
            <tag> SwiftUI </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>详解SwiftUI中Divider和Spacer的用法和区别（最新）</title>
      <link href="swiftui/swiftui-divide-spacer/"/>
      <url>swiftui/swiftui-divide-spacer/</url>
      
        <content type="html"><![CDATA[<p>Divider和Spacer都可以用到分割两个视图，但是它们也有一些区别。通过这篇文章我们将学到这两个控件的使用方式和它们之间的区别。</p><a id="more"></a><div class="note info"><p>到公众号【iOS开发栈】学习更多SwiftUI、iOS开发相关内容。</p></div><p><img src="../../images/first/SwiftUI-Divider-Spacer.jpg" alt="SwiftUI-Divider-vs-Spacer"></p><h1 id="Spacer"><a href="#Spacer" class="headerlink" title="Spacer"></a>Spacer</h1><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">ContentView</span>: <span class="title">View</span> </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> body: <span class="keyword">some</span> <span class="type">View</span> &#123;</span><br><span class="line">        <span class="type">VStack</span> &#123;</span><br><span class="line">            <span class="type">Text</span>(<span class="string">&quot;Top&quot;</span>).background(<span class="type">Color</span>.red)</span><br><span class="line">            <span class="type">Spacer</span>()</span><br><span class="line">            <span class="type">Text</span>(<span class="string">&quot;Bottom&quot;</span>).background(<span class="type">Color</span>.red)</span><br><span class="line">        &#125;</span><br><span class="line">        .frame(width: <span class="number">100</span>, height: <span class="number">400</span>, alignment: .center)</span><br><span class="line">        .background(<span class="type">Color</span>.yellow)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在“Top”和“Bottom”之间添加一个<code>Spacer</code>控件，会把这两个文字隔开，使这两个文字分别位于最上和最下面。</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">Spacer</span>(minLength: <span class="number">30</span>)</span><br></pre></td></tr></table></figure><p>通过设置<code>minLength</code>可以指定被分开的两个视图的最小距离，如果不指定的话，会有一个默认的距离。</p><h1 id="Divider"><a href="#Divider" class="headerlink" title="Divider"></a>Divider</h1><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">VStack</span> &#123;</span><br><span class="line">    <span class="type">Text</span>(<span class="string">&quot;Top&quot;</span>).background(<span class="type">Color</span>.red)</span><br><span class="line">    <span class="type">Divider</span>().background(<span class="type">Color</span>.red)</span><br><span class="line">    <span class="type">Text</span>(<span class="string">&quot;Bottom&quot;</span>).background(<span class="type">Color</span>.red)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Top和Bottom之间添加一个Divider控件可以在两个视图之间添加一个间隔，和上面的<code>Spacer</code>不同的是中间会出现一根线，<code>background</code>设置的颜色会影响到这根线的颜色。</p><p>并且，被Divider分割的两个视图中间的距离是固定的，它们不会移动到父视图的两端。</p><p>另外，把<code>Divider</code>的高度分别设置为0之后，被它分割的两个视图不会靠在一起。但是把<code>Spacer</code>的高度设置为0，被它分割的两个视图会靠在一起，就和没有被分割一样。</p><div class="note info"><p>到公众号【iOS开发栈】学习更多SwiftUI、iOS开发相关内容。回复“博客”免费获取各大互联网公司面试题。</p></div><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>这篇文章学习了SwiftUI中<code>Spacer</code>和<code>Divider</code>的用法以及它们之间的区别，这两个控件在SwiftUI中虽然简单但是非常的常用，我们一定要熟悉。如果你有任何的问题、建议都可以通过<a href="https://weibo.com/7414691003/profile">微博</a>或<a href="mailto:shizhiang@126.com">邮件</a>联系到我本人。</p>]]></content>
      
      
      
        <tags>
            
            <tag> SwiftUI </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>iOS完整集成admob教程（2021）</title>
      <link href="ios/ios-integrate-admob/"/>
      <url>ios/ios-integrate-admob/</url>
      
        <content type="html"><![CDATA[<p>Admob是谷歌推出的广告服务，其中包含的广告类型有：banner、插屏、激励、开屏（最近添加的）。利用Admob的中介组可以引入其他广告商的广告，比如FaceBook、unity等10多家平台。对于出海的App集成Admob是非常必要的变现手段。</p><a id="more"></a><div class="note info"><p>到公众号【iOS开发栈】学习更多SwiftUI、iOS开发相关内容。</p></div><p><img src="../../images/admob/admob.png" alt="Admob 集成"></p><h1 id="通过Cocoapods导入Admob-SDK"><a href="#通过Cocoapods导入Admob-SDK" class="headerlink" title="通过Cocoapods导入Admob SDK"></a>通过Cocoapods导入Admob SDK</h1><p>通过Cocoapods导入SDK是最简单的方法，如果不知道Cocoapods的使用方法可以看一下<a href="https://cocoapods.org/">官方文档</a>。在Podfile中添加一行代码：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">pod &#39;Google-Mobile-Ads-SDK&#39;</span><br></pre></td></tr></table></figure><p>之后在终端执行命令行：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">pod install --repo-update</span><br></pre></td></tr></table></figure><h1 id="修改主工程的info-plist文件"><a href="#修改主工程的info-plist文件" class="headerlink" title="修改主工程的info.plist文件"></a>修改主工程的info.plist文件</h1><p>在主工程的info.plist文件中添加两个键值对：</p><ol><li><code>GADApplicationIdentifier</code>对应的是你的app在Admob申请到的App ID。</li><li><code>SKAdNetworkItems</code>对应的是一个固定的<code>cstr6suwn9.skadnetwork</code>。</li></ol><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">&lt;key&gt;GADApplicationIdentifier&lt;&#x2F;key&gt;</span><br><span class="line">&lt;string&gt;ca-app-pub-3940256099942544~1458002511&lt;&#x2F;string&gt;</span><br><span class="line">&lt;key&gt;SKAdNetworkItems&lt;&#x2F;key&gt;</span><br><span class="line">  &lt;array&gt;</span><br><span class="line">    &lt;dict&gt;</span><br><span class="line">      &lt;key&gt;SKAdNetworkIdentifier&lt;&#x2F;key&gt;</span><br><span class="line">      &lt;string&gt;cstr6suwn9.skadnetwork&lt;&#x2F;string&gt;</span><br><span class="line">    &lt;&#x2F;dict&gt;</span><br><span class="line">  &lt;&#x2F;array&gt;</span><br></pre></td></tr></table></figure><p>添加之后的info.plist效果：<br><img src="../../images/admob/quick_start_skadnetwork.png" alt="info.plist添加Admob"></p><p>关于注册Admob账号和获取App ID的内容可以到<a href="https://apps.admob.com/v2/home">Admob的官方网站</a>查看。</p><h1 id="初始化Admob-SDK"><a href="#初始化Admob-SDK" class="headerlink" title="初始化Admob SDK"></a>初始化Admob SDK</h1><p>在<code>AppDelegate</code>中添加初始化Admob SDK的代码</p><div class="tabs" id="initialize-admob-sdk"><ul class="nav-tabs"><li class="tab active"><a href="#initialize-admob-sdk-1">Objective-C</a></li><li class="tab"><a href="#initialize-admob-sdk-2">Swift</a></li></ul><div class="tab-content"><div class="tab-pane active" id="initialize-admob-sdk-1"><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">@import</span> GoogleMobileAds;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">@implementation</span> <span class="title">AppDelegate</span></span></span><br><span class="line"></span><br><span class="line">- (<span class="built_in">BOOL</span>)application:(<span class="built_in">UIApplication</span> *)application</span><br><span class="line">    didFinishLaunchingWithOptions:(<span class="built_in">NSDictionary</span> *)launchOptions &#123;</span><br><span class="line"></span><br><span class="line">  [[GADMobileAds sharedInstance] startWithCompletionHandler:<span class="literal">nil</span>];</span><br><span class="line">  <span class="keyword">return</span> <span class="literal">YES</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">@end</span></span><br></pre></td></tr></table></figure></div><div class="tab-pane" id="initialize-admob-sdk-2"><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> GoogleMobileAds</span><br><span class="line"></span><br><span class="line"><span class="keyword">@UIApplicationMain</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">AppDelegate</span>: <span class="title">UIResponde</span>, <span class="title">UIApplicationDelegate</span> </span>&#123;</span><br><span class="line">  <span class="function"><span class="keyword">func</span> <span class="title">application</span><span class="params">(<span class="keyword">_</span> application: UIApplication,</span></span></span><br><span class="line"><span class="function"><span class="params">      didFinishLaunchingWithOptions launchOptions: [UIApplicationLaunchOptionsKey: <span class="keyword">Any</span>]?)</span></span> -&gt; <span class="type">Bool</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="type">GADMobileAds</span>.sharedInstance().start(completionHandler: <span class="literal">nil</span>)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div></div></div><p>到这里，我们就可以根据需要来在App的不同位置添加需要的广告类型了。</p><p>因为类型比较多，这里如果分别介绍的话篇幅就太长了。所以在这篇文章只说一下需要注意的地方，详细的集成方法可以到<a href="https://developers.google.com/admob/ios/quick-start">Admob开发官网</a>查看。</p><h1 id="各种Admob广告类型的最佳实践方案"><a href="#各种Admob广告类型的最佳实践方案" class="headerlink" title="各种Admob广告类型的最佳实践方案"></a>各种Admob广告类型的最佳实践方案</h1><p>不同类型的Admob广告适用于不同的场景，按照场景放广告不仅更能被用户接受，而且对广告营收有一定的益处。相反，如果不按照推荐方法来展示广告有可能会被广告商警告，严重的话可能会被禁止投放（我们就被Facebook警告了）。</p><ol><li>Banner广告是那种长条状的横幅形式，建议放在屏幕的边缘处，对于手机屏幕建议放在屏幕的最上面或者最下面。</li><li>插屏广告是一种全屏展示的广告，可能是一张图片或者一个视频，只有用户点击关闭按钮是才会关闭。这种广告对用户打扰非常大，建议放在界面切换的时候才展示这种广告，<strong>并且不能在push到一个新页面以后再展示</strong>，比如说不能在到一个新页面后网络请求服务端的过程中展示这个广告。</li><li>Native广告（原生广告）是一种比较特殊的广告形式，它通过SDK来实现广告加载，加载到的是广告的一些组件（文字、图片、视频），我们可以自定义组件的展示位置和大小。<strong>这种广告适合用在启动图或者列表（UITableView/UICollectionView）中。</strong></li><li>激励视频广告是一种可以让用户通过观看广告获取App内奖励的广告形式，在游戏类App中十分常见。在弹出这种广告前一定要让用户选择是否要通过看广告获取“更多奖励”。</li></ol><h1 id="使用Admob中介组聚合多个平台广告"><a href="#使用Admob中介组聚合多个平台广告" class="headerlink" title="使用Admob中介组聚合多个平台广告"></a>使用Admob中介组聚合多个平台广告</h1><p>谷歌广告平台不仅有自家的Admob广告还有很多其他广告平台的资源，我们在集成了<code>Google-Mobile-Ads-SDK</code>的基础上通过添加不同平台的中介组（Mediation）来快速获取不同平台的广告。</p><p>在这里我们仅以集成Facebook的广告为例做一下说明，其他平台的广告也都大同小异。如果在集成过程中有什么问题也可以到公众号“iOS开发栈”问我。</p><p>在<code>Podfile</code>文件中添加Admob SDK和Facebook的中介组：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">pod &#39;Google-Mobile-Ads-SDK&#39;,</span><br><span class="line">pod &#39;GoogleMobileAdsMediationFacebook&#39;</span><br></pre></td></tr></table></figure><p>之后在终端切换到项目所在目录，并执行</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">cd &lt;当前项目目录&gt;</span><br><span class="line">pod install --repo-update</span><br></pre></td></tr></table></figure><p>安装完Admob SDk和FB的广告中介组以后，就可以直接使用对应的广告形式了。对应广告形式的使用方式可以到上一节查看，这里不再赘述。</p><p>这里有一点需要强调的是在初始化不同的广告形式需要调用<code>initWithAdUnitID:</code>方法，这里的<em>UnitID</em>是广告但愿ID，可以在Admob的管理后台-&gt;广告单元页面查看。</p><p><img src="../../images/admob/UnitId.png" alt="Admob UnitID"></p><div class="note info"><p>到公众号【iOS开发栈】学习更多SwiftUI、iOS开发相关内容。回复“博客”免费获取各大互联网公司面试题。</p></div><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>谷歌的Admob服务和其他广告商相比文档更加全面（不过文档中也可能有错误），社区也非常活跃（我曾经提过一个问题，很快可以得到回复）。这篇文章是我在使用过程中的一些总结，里面除了基础的集成方法外，大都是使用过程中的注意事项，至于详细的集成过程推荐到<a href="https://developers.google.com/admob/ios/quick-start">官方文档</a>中查看。如果你有任何的问题、建议都可以通过<a href="https://weibo.com/7414691003/profile">微博</a>或<a href="mailto:shizhiang@126.com">邮件</a>联系到我本人。</p>]]></content>
      
      
      
        <tags>
            
            <tag> iOS </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>详解SwiftUI数据流是怎么在View间传递的</title>
      <link href="swiftui/swiftui-data-flow/"/>
      <url>swiftui/swiftui-data-flow/</url>
      
        <content type="html"><![CDATA[<p>作为一个声明式的UI框架，SwiftUI帮我们处理了几乎所有关于UI和数据之间的交互，这使我们不再需要关注数据变化时刷新UI和用户交互以后更新数据的逻辑。</p><p>为了实现数据和UI的绑定，我们需要利用Swift的一些关属性包装器来向SwiftUI描述它们之间的关系，那么让我们开始吧。</p><a id="more"></a><div class="note info"><p>到公众号【iOS开发栈】学习更多SwiftUI、iOS开发相关内容。</p></div><p><img src="../../image/../images/first/SwiftUI-Data-Flow.jpg"></p><h1 id="State-Properties-State"><a href="#State-Properties-State" class="headerlink" title="State Properties @State"></a>State Properties @State</h1><p>在<a href="https://www.iosprogrammer.tech/swiftui/what-is-the-different-between-foreach-and-list">前面的一篇文章</a>中当我们给数组添加或者删除元素时，<a href="https://www.iosprogrammer.tech/swiftui/swiftui-concept-essential.md">列表</a>会自动响应变化，正是因为使用了<code>@State</code>来标记View中的model。</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">ContentView</span>: <span class="title">View</span> </span>&#123;</span><br><span class="line">    <span class="meta">@State</span> <span class="keyword">private</span> <span class="keyword">var</span> title: <span class="type">String</span> <span class="operator">=</span> <span class="string">&quot;&quot;</span></span><br><span class="line">    <span class="keyword">var</span> body: <span class="keyword">some</span> <span class="type">View</span> &#123;</span><br><span class="line">        <span class="type">VStack</span> &#123;</span><br><span class="line">            <span class="type">Text</span>(<span class="string">&quot;<span class="subst">\(title)</span>&quot;</span>)</span><br><span class="line">            <span class="type">TextField</span>(<span class="string">&quot;Please Enter Title&quot;</span>, text: <span class="variable">$title</span>)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>使用<code>@State</code>包装的变量是可以被SwiftUI读取的值，这些值通常是一些字符串或数字等常量值。</p><p>当被State包装的属性改变时，SwiftUI会重新计算和绘制使用到该属性的视图所在的整个视图层级，通常是说变量所在View的Body会被重新绘制，在本例子中就是指<code>ContentView</code>的body。</p><blockquote><p>被<code>@State</code>包装的变量一定要用<code>private</code>修饰，并且这个变量只能在当前view以及其子View的body中使用。</p></blockquote><p>正如TextField中的<code>$title</code>一样，我们可以通过*$*前缀把变量和另一个view绑定起来，这样就可以在另一个view中对这个变量进行修改了。下面的代码使用一个Toggle来控制Wi-Fi的开关：</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">ContentView</span>: <span class="title">View</span> </span>&#123;</span><br><span class="line">    <span class="meta">@State</span> <span class="keyword">private</span> <span class="keyword">var</span> isOn <span class="operator">=</span> <span class="literal">false</span></span><br><span class="line">    <span class="keyword">var</span> body: <span class="keyword">some</span> <span class="type">View</span> &#123;</span><br><span class="line">        <span class="type">VStack</span> &#123;</span><br><span class="line">            <span class="type">Text</span>(<span class="string">&quot;Wi-Fi State: <span class="subst">\(isOn <span class="operator">?</span> <span class="string">&quot;On&quot;</span> : <span class="string">&quot;Off&quot;</span>)</span>&quot;</span>)</span><br><span class="line">            <span class="type">Image</span>(systemName: <span class="string">&quot;<span class="subst">\(isOn <span class="operator">?</span> <span class="string">&quot;wifi&quot;</span> : <span class="string">&quot;wifi.slash&quot;</span>)</span>&quot;</span>)</span><br><span class="line">            <span class="type">Toggle</span>(<span class="string">&quot;Wi-Fi State&quot;</span>, isOn: <span class="variable">$isOn</span>)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>正如上面的代码所示，我们在<code>isOn</code>属性和Toggle控件之间建立了一个绑定。Toggle可以修改isOn的值，另外当isOn改变的时候，Text和Image的内容都会发生变化。</p><h1 id="State-Binding-状态绑定"><a href="#State-Binding-状态绑定" class="headerlink" title="State Binding 状态绑定"></a>State Binding 状态绑定</h1><p>使用@state包装的属性只在它所属view的内部使用，那么当它的子视图要访问这个属性的时候就要用到<code>@binding</code>了。就像上面例子用到的<code>Toggle</code>，我们把Text和Image放到一个自定义的View中。</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">WiFiView</span>: <span class="title">View</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Binding</span> <span class="keyword">var</span> isOn: <span class="type">Bool</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">var</span> body: <span class="keyword">some</span> <span class="type">View</span> &#123;</span><br><span class="line">        <span class="type">Text</span>(<span class="string">&quot;Wi-Fi State: <span class="subst">\(isOn <span class="operator">?</span> <span class="string">&quot;On&quot;</span> : <span class="string">&quot;Off&quot;</span>)</span>&quot;</span>)</span><br><span class="line">        <span class="type">Image</span>(systemName: <span class="string">&quot;<span class="subst">\(isOn <span class="operator">?</span> <span class="string">&quot;wifi&quot;</span> : <span class="string">&quot;wifi.slash&quot;</span>)</span>&quot;</span>)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在这里我们使用了<code>@Binding</code>来创建数据和界面之间的依赖，它和<code>@State</code>不同的地方在于，binding的属性并不被当前的视图所持有，并且binding的值是可以被state的属性值导出的。</p><p>在这里如果把@Binding换成@State就会使WiFiView和它的父视图分别拥有各自的isOn属性，其中一个修改不会影响到另一个，而这显然不是我们想要的结果。</p><h1 id="使用Combine框架的Publisher"><a href="#使用Combine框架的Publisher" class="headerlink" title="使用Combine框架的Publisher"></a>使用<em>Combine</em>框架的<em>Publisher</em></h1><p>使用@State包装的属性只能在当前View内部或者它的子视图中使用，并且state属性时临时的——由于state包装的属性是隶属于它所在view的，当view被销毁时对应的state属性也会消失，这明显是不够的，另外我们在开发过程中还要处理一些非界面的信息，比如说<em>Timer</em>、<em>Notification</em>等，它们携带的信息通常也会有更新界面的需求。这种情况就要用到Combine中的Publisher了。</p><p><em>Combine</em>是在iOS13中被引入的，主要目的是为了处理App中的各种事件消息。如果你之前接触过<em>RxSwift</em>或者<em>ReactiveCocoa</em>那你对这个概念应该很容易理解，它的原理就是发布者和订阅者的模式。</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Contact</span>: <span class="title">ObservableObject</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Published</span> <span class="keyword">var</span> name: <span class="type">String</span></span><br><span class="line">    <span class="meta">@Published</span> <span class="keyword">var</span> age: <span class="type">Int</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">init</span>(name: <span class="type">String</span>, age: <span class="type">Int</span>) &#123;</span><br><span class="line">        <span class="keyword">self</span>.name <span class="operator">=</span> name</span><br><span class="line">        <span class="keyword">self</span>.age <span class="operator">=</span> age</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">ContentView</span>: <span class="title">View</span> </span>&#123;</span><br><span class="line">    <span class="meta">@ObservedObject</span> <span class="keyword">var</span> xiaowang <span class="operator">=</span> <span class="type">Contact</span>(name: <span class="string">&quot;xiaowang&quot;</span>, age: <span class="number">21</span>)</span><br><span class="line">    <span class="keyword">var</span> body: <span class="keyword">some</span> <span class="type">View</span> &#123;</span><br><span class="line">        <span class="type">VStack</span> &#123;</span><br><span class="line">            <span class="type">Text</span>(<span class="string">&quot;小王：<span class="subst">\(xiaowang.name)</span>&quot;</span>)</span><br><span class="line">            </span><br><span class="line">            <span class="comment">// 这里只是一个例子，通常不会在这里对Publisher进行修改</span></span><br><span class="line">            <span class="type">Button</span>(<span class="string">&quot;修改联系人&quot;</span>) &#123;</span><br><span class="line">                xiaowang.name <span class="operator">=</span> <span class="string">&quot;小王&quot;</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>我们先创建一个遵守<em>ObservableObject</em>协议的联系人类，然后在SwiftUI视图中添加一个被<em>ObservedObject</em>包装的变量，在body中使用这个变量，当被<em><em>@Published</em></em>包装的变量改变时，body会使用新值重新加载。</p><blockquote><p>如果你在看WWDC2019的<a href="https://developer.apple.com/wwdc19/226">Introducing Combile</a>视频的时候发现<em>BindableObject</em>/<em>didChange.send()</em>/<em>onReceive</em>，这些内容现在已经被<a href="https://developer.apple.com/forums/thread/127243">移除了</a>。</p></blockquote><blockquote><p>只有class可以遵守ObservableObject协议，否则会报错 <mark class="label danger">Non-class type Contact cannot conform to class protocol ObservableObject</mark></p></blockquote><p>在iOS14中，引入了一个新的<em><em>@StateObject</em></em>来丰富这种使用场景。它和ObservedObject的区别在于当view刷新时被ObservedObject包装的属性会重置到初始值，而被StateObject使用的不会。</p><blockquote><p>除非在某些必要的情况下需要使用ObservedObject之外，大多数情况都适用于StateObject。</p></blockquote><h1 id="环境变量-Evironment-Objects"><a href="#环境变量-Evironment-Objects" class="headerlink" title="环境变量 Evironment Objects"></a>环境变量 Evironment Objects</h1><p>除了以上列出的几个场景之外，假设我们的app需要从一个页面跳转到另一个页面，这是一个很常见的场景，并且在后一个页面要用到前面页面的一些属性。通常可以这样做：</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">NavigationLink</span>(destination: nextView(aModel: aModel)) &#123;</span><br><span class="line">    <span class="type">Text</span>(<span class="string">&quot;Detail&quot;</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上面用到了<strong><em>NavigationLink</em></strong>来做导航，destination是要弹出的页面，初始化时带着当前页面的一个属性。</p><p>这样处理没有什么大的问题，不过如果层级变多，后面层级又出现很多新层级，再有反向传值的话就会很复杂容易出错——就像使用UIKit的时候。而为了解决这个问题，SwiftUI引入了<strong><em>Evironment Objects</em></strong>。</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// DataSource.swift</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">DataSource</span>: <span class="title">ObservableObject</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Published</span> <span class="keyword">var</span> counter <span class="operator">=</span> <span class="number">0</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// ContentView.swift</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">ContentView</span>: <span class="title">View</span> </span>&#123;</span><br><span class="line">    <span class="keyword">let</span> dataSource <span class="operator">=</span> <span class="type">DataSource</span>()</span><br><span class="line">    <span class="keyword">var</span> body: <span class="keyword">some</span> <span class="type">View</span> &#123;</span><br><span class="line">        <span class="type">NavigationView</span> &#123;</span><br><span class="line">            <span class="type">VStack</span> &#123;</span><br><span class="line">                <span class="type">Button</span>(<span class="string">&quot;Click&quot;</span>) &#123;</span><br><span class="line">                    dataSource.counter <span class="operator">+=</span> <span class="number">1</span></span><br><span class="line">                &#125;</span><br><span class="line">                <span class="type">NavigationLink</span>(</span><br><span class="line">                    destination: <span class="type">ContactView</span>()) &#123;</span><br><span class="line">                    <span class="type">Text</span>(<span class="string">&quot;Enter Next Page&quot;</span>)</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        .environmentObject(dataSource)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// ContactView.swift</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">ContactView</span>: <span class="title">View</span> </span>&#123;</span><br><span class="line">    <span class="meta">@EnvironmentObject</span> <span class="keyword">var</span> dataSource: <span class="type">DataSource</span></span><br><span class="line">    <span class="keyword">var</span> body: <span class="keyword">some</span> <span class="type">View</span> &#123;</span><br><span class="line">        <span class="type">Text</span>(<span class="string">&quot;<span class="subst">\(dataSource.counter)</span>&quot;</span>)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Environment Object和ObservedObject/StateObject用法非常相似，首先DataSource遵守ObservableObject协议，要观察的属性counter使用Publisher包装。</p><p>被<em><em>@EnvironmentObject</em></em>包装的属性会随着Publised属性的改变而变化，所在的view也会重新加载。</p><p><em>.environmentObject</em>是一个<a href="https://www.iosprogrammer.tech/swiftui-concept-essential">Modifier</a>，它向环境变量中注入一个属性，如果不在使用@EnvironmentObject之前使用把属性注入到环境变量中，就会包错 <mark class="label danger">MissingEnvironmentObjectError: Missing EnvironmentObject</mark></p><div class="note info"><p>到公众号【iOS开发栈】回复“博客”免费获取各大互联网公司面试题。</p></div><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>在这篇文章中我们学习了SwiftUI框架中数据的流动相关知识，其中主要涉及了几个常用的属性包装器（property wrapper）：@State @Binding @ObservedObject @StateObject @EnvironmentObject用法和适用场景，希望对你所有帮助。如果你有任何的问题、建议都可以通过<a href="https://weibo.com/7414691003/profile">微博</a>或<a href="mailto:shizhiang@126.com">邮件</a>联系到我本人。</p>]]></content>
      
      
      
        <tags>
            
            <tag> SwiftUI </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>一文解决UIKeyboard的疑难杂症</title>
      <link href="UIScrollView-Keyboard/"/>
      <url>UIScrollView-Keyboard/</url>
      
        <content type="html"><![CDATA[<p>我们在iOS的开发过程中，经常要在包含UIScrollView的view中监听键盘的通知，有时候会出现一些bug，比方说<code>UIKeyboardWillShowNotification</code>可能会调用多次。</p><p>通过这篇文章我们来讨论几个经常出现的问题，并且了解一下对应的解决方案。</p><a id="more"></a><div class="note info"><p>到公众号【iOS开发栈】学习更多SwiftUI、iOS开发相关内容。回复“博客”免费获取各大互联网公司面试题。</p></div><p><img src="../../images/first/UIkeyBoard.jpg" alt="UIkeyboard的bugs"></p><h1 id="UIScrollView退出键盘"><a href="#UIScrollView退出键盘" class="headerlink" title="UIScrollView退出键盘"></a>UIScrollView退出键盘</h1><p>拖动UIScrollView退出键盘的方法：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">typedef NS_ENUM(NSInteger, UIScrollViewKeyboardDismissMode) &#123;</span><br><span class="line">    UIScrollViewKeyboardDismissModeNone,</span><br><span class="line">    UIScrollViewKeyboardDismissModeOnDrag,      &#x2F;&#x2F; dismisses the keyboard when a drag begins</span><br><span class="line">    UIScrollViewKeyboardDismissModeInteractive, &#x2F;&#x2F; the keyboard follows the dragging touch off screen, and may be pulled upward again to cancel the dismiss</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">@property(nonatomic) UIScrollViewKeyboardDismissMode keyboardDismissMode &#x2F;&#x2F; 默认是None，UIScrollView和Keyboar不会有任何交互效果</span><br></pre></td></tr></table></figure><ul><li><code>UIScrollViewKeyboardDismissModeOnDrag</code> 当开始拖动时，keyboard会退出屏幕。在iOS14的模拟器上动画有点不流畅。</li><li><code>UIScrollViewKeyboardDismissModeInteractive</code> <strong>当拖动手势进入键盘区域时</strong>，键盘会跟随拖动上升或者下降。</li></ul><h1 id="UIKeyboardWillShowNotification多次重复通知"><a href="#UIKeyboardWillShowNotification多次重复通知" class="headerlink" title="UIKeyboardWillShowNotification多次重复通知"></a><code>UIKeyboardWillShowNotification</code>多次重复通知</h1><p>多个TextField或者TextView之间切换时，<code>UIKeyboardWillShowNotification</code>、<code>UIKeyboardWillChangeFrameNotification</code>每次都会调用（但是<code>UIKeyboardWillHideNotification</code>却不会调用），当你使用上面提到的<code>UIScrollViewKeyboardDismissModeInteractive</code>时，通知甚至会在一个动画过程中频繁调用。</p><p>我们在处理一些业务逻辑的时候需要谨记这个特点，不要寄希望于只会调用一次。比方说要在<code>UIKeyboardWillShowNotification</code>的回调中把某个视图上移。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line">[[NSNotificationCenter defaultCenter] addObserver:self selector:@selector(willShow:) name:UIKeyboardWillShowNotification object:nil]; &#x2F;&#x2F; 订阅通知</span><br><span class="line"></span><br><span class="line">❌</span><br><span class="line">- (void)willShow:(NSNotification *)noti &#123;</span><br><span class="line">    NSLog(@&quot;willShow&quot;);</span><br><span class="line">    CGRect keyboarFrame &#x3D; [noti.userInfo[UIKeyboardFrameBeginUserInfoKey] CGRectValue];</span><br><span class="line">    CGRect bottomViewFrame &#x3D; _bottomView.frame;</span><br><span class="line">    bottomViewFrame.origin.y -&#x3D; keyboarFrame.size.height;</span><br><span class="line">    _bottomView.frame &#x3D; bottomViewFrame;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">✅</span><br><span class="line">&#x2F;&#x2F; 使用固定高度的方法</span><br><span class="line">- (void)willShow:(NSNotification *)noti &#123;</span><br><span class="line">    NSLog(@&quot;willShow&quot;);</span><br><span class="line">    CGRect keyboarFrame &#x3D; [noti.userInfo[UIKeyboardFrameEndUserInfoKey] CGRectValue];</span><br><span class="line">    CGRect bottomViewFrame &#x3D; _bottomView.frame;</span><br><span class="line">    bottomViewFrame.origin.y &#x3D; self.view.bounds.size.height - keyboarFrame.size.height - _bottomView.bounds.size.height;</span><br><span class="line">    _bottomView.frame &#x3D; bottomViewFrame;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">✅</span><br><span class="line">&#x2F;&#x2F; 使用全局变量的方法</span><br><span class="line">[[NSNotificationCenter defaultCenter] addObserver:self selector:@selector(didHide:) name:UIKeyboardDidHideNotification object:nil]; &#x2F;&#x2F; 订阅键盘消失的通知</span><br><span class="line"></span><br><span class="line">static BOOL keyboarShow &#x3D; NO;</span><br><span class="line"></span><br><span class="line">- (void)willShow:(NSNotification *)noti &#123;</span><br><span class="line">    NSLog(@&quot;willShow&quot;);</span><br><span class="line">    if (keyboarShow &#x3D;&#x3D; YES) &#123;</span><br><span class="line">        return;</span><br><span class="line">    &#125;</span><br><span class="line">    keyboarShow &#x3D; YES;</span><br><span class="line">    CGRect keyboarFrame &#x3D; [noti.userInfo[UIKeyboardFrameEndUserInfoKey] CGRectValue];</span><br><span class="line">    CGRect bottomViewFrame &#x3D; _bottomView.frame;</span><br><span class="line">    bottomViewFrame.origin.y &#x3D; self.view.bounds.size.height - keyboarFrame.size.height - _bottomView.bounds.size.height;</span><br><span class="line">    _bottomView.frame &#x3D; bottomViewFrame;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (void)didHide:(NSNotification *)noti &#123;</span><br><span class="line">    NSLog(@&quot;didHide&quot;);</span><br><span class="line">    keyboarShow &#x3D; NO;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h1 id="点击UIScrollView触发UIKeyboardWillShowNotification通知"><a href="#点击UIScrollView触发UIKeyboardWillShowNotification通知" class="headerlink" title="点击UIScrollView触发UIKeyboardWillShowNotification通知"></a>点击UIScrollView触发<code>UIKeyboardWillShowNotification</code>通知</h1><p>点击TextFiled或者TextView后，再点击UIScrollView，<code>UIKeyboardWillShowNotification</code>的回调会被触发，我不能确定造成这个现象的原因是什么，不过猜测是因为iOS的事件管理系统的内部bug导致的。解决这个问题的终极方法和我们上面⬆️用的方法是一样的。</p><div class="note info"><p>到公众号【iOS开发栈】学习更多SwiftUI、iOS开发相关内容。回复“博客”免费获取各大互联网公司面试题。</p></div><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>通过这篇文章我们讨论了在使用<code>UIScrollView</code>的时候会出现的一些关于键盘的问题，并且给出了具体的解决方案，以及用到了UIKeybaord的一些通知，希望对你有所帮助。</p><p>如果你有任何的问题、建议都可以通过<a href="https://weibo.com/7414691003/profile">微博</a>或<a href="mailto:shizhiang@126.com">邮件</a>联系到我本人。</p>]]></content>
      
      
      
        <tags>
            
            <tag> iOS </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>在SwiftUI中使用ForEach和List模仿UITableView、UICollectionView</title>
      <link href="swiftui/what-is-the-different-between-foreach-and-list/"/>
      <url>swiftui/what-is-the-different-between-foreach-and-list/</url>
      
        <content type="html"><![CDATA[<p>ForEach和List都可以创建列表，它们都是SwiftUI重要的组件，它们用来替代UIKit中的UITableView。通过这篇文章我们将学习到ForEach和List的相关用法。</p><p>这篇文章非常适合SwiftUI入门的同学。</p><a id="more"></a><div class="note info"><p>到公众号【iOS开发栈】学习更多SwiftUI、iOS开发相关内容。回复“博客”免费获取各大互联网公司面试题。</p></div><p><img src="../../images/swiftui-list/blog-main-picture.png"></p><h2 id="List的用法"><a href="#List的用法" class="headerlink" title="List的用法"></a>List的用法</h2><p>首先来看一下<code>List</code>。List最简单的用法</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">List</span>(<span class="number">0</span><span class="operator">..&gt;</span><span class="number">10</span>) &#123;</span><br><span class="line">    <span class="type">Text</span>(<span class="string">&quot;Hellow, SwiftUI&quot;</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这样只是简单的把一个文字迭代了10遍组成一个列表。下面假设有一个学生数组，数组是由20个字典组成，每个字典包含学生的id和姓名两个元素。</p><p><img src="../../images/swiftui-list/2.png" alt="SwiftUI List用法"></p><p>让我们来看一下<code>List</code>的创建方法：</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">List</span>(students, id: \.id) &#123; student <span class="keyword">in</span></span><br><span class="line">    <span class="type">Text</span>(<span class="string">&quot;student id:<span class="subst">\(student.id)</span> name:<span class="subst">\(student.name)</span>&quot;</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>List的初始化用到了3个参数：</p><ol><li>一个未命名的<code>data</code>，被迭代的数组。这里我们用的是<code>students</code>。</li><li>keypath类型的<code>id</code>参数，用来唯一区分当前迭代到的元素是数组中的哪一个。</li><li>最后一个参数是一个闭包，每一次迭代都会把闭包中的view组成一个新的view。因为这是最后一个参数，所以可以使用尾随闭包。</li></ol><h2 id="ForEach的用法"><a href="#ForEach的用法" class="headerlink" title="ForEach的用法"></a>ForEach的用法</h2><p><code>ForEach</code>和<code>List</code>一样都可以进行数组迭代来创建列表，把上面的例子用ForEach实现。</p><p><img src="../../images/swiftui-list/3.png" alt="SwiftUI ForEach用法"></p><p><code>ForEach</code>的参数和<code>List</code>几乎一样，这里不再赘述。</p><h2 id="List和ForEach的不同"><a href="#List和ForEach的不同" class="headerlink" title="List和ForEach的不同"></a>List和ForEach的不同</h2><p>从上图可以看出ForEach和List的语法非常的相似，不过ForEach在<em>Preview</em>中展示的效果却分成了好多个屏幕。</p><p>这个效果其实和下面的代码是一样的。</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">ContentView</span>: <span class="title">View</span> </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> students: [<span class="type">Student</span>]</span><br><span class="line">    <span class="keyword">var</span> body: <span class="keyword">some</span> <span class="type">View</span> &#123;</span><br><span class="line">        <span class="type">Text</span>(<span class="string">&quot;Student id:0 name:aaa&quot;</span>)</span><br><span class="line">        <span class="type">Text</span>(<span class="string">&quot;Student id:0 name:aaa&quot;</span>)</span><br><span class="line">        <span class="type">Text</span>(<span class="string">&quot;Student id:0 name:aaa&quot;</span>)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>之所以会是这样，是因为ForEach并不会生成一个容器来包装闭包里面的View，而List却正好相反，并且<strong>ForEach的列表是不能滚动的</strong>，也就是说当里面的view超出了ForEach的父视图的大小是不能滚动的。这也是咱们在使用List和ForEach的时候需要注意的点。</p><h2 id="List和ForEach的适用场景"><a href="#List和ForEach的适用场景" class="headerlink" title="List和ForEach的适用场景"></a>List和ForEach的适用场景</h2><p>因为List会默认生成一个容器来包装它里面的子view，所以它更适合单独使用来创建一个可以支持纵向滚动的列表，就像咱们上面的用法。</p><p>而ForEach不会生成一个容器，而且不能支持滚动，所以一般把它嵌套在其他容器里面使用。</p><h3 id="List嵌套ForEach"><a href="#List嵌套ForEach" class="headerlink" title="List嵌套ForEach"></a>List嵌套ForEach</h3><p>嵌套在<code>List</code>里面可以实现类似带header的UITableView的效果，这里同时展示了固定不动的Header和跟随滚动的Header。</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">ContentView</span>: <span class="title">View</span> </span>&#123;</span><br><span class="line">    <span class="meta">@State</span> <span class="keyword">var</span> students: [<span class="type">Student</span>]</span><br><span class="line">    <span class="keyword">var</span> body: <span class="keyword">some</span> <span class="type">View</span> &#123;</span><br><span class="line">        <span class="type">VStack</span> &#123;</span><br><span class="line">            <span class="type">Text</span>(<span class="string">&quot;这是固定不动的Header&quot;</span>)</span><br><span class="line">            <span class="type">List</span> &#123;</span><br><span class="line">                <span class="type">Text</span>(<span class="string">&quot;这是跟随滚动的Header&quot;</span>)</span><br><span class="line">                <span class="type">ForEach</span>(students, id: \.id) &#123; stu <span class="keyword">in</span></span><br><span class="line">                    <span class="type">Text</span>(<span class="string">&quot;student id:<span class="subst">\(stu.id)</span> name: <span class="subst">\(stu.name)</span>&quot;</span>).frame(width: <span class="number">200</span>, height: <span class="number">60</span>)</span><br><span class="line">                &#125;</span><br><span class="line">                .onDelete&#123; indexSet <span class="keyword">in</span></span><br><span class="line">                    <span class="keyword">for</span> index <span class="keyword">in</span> indexSet &#123;</span><br><span class="line">                        students.remove(at: index)</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="type">Text</span>(<span class="string">&quot;这是跟随滚动Footer&quot;</span>)</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="type">Text</span>(<span class="string">&quot;这是固定不动的Footer&quot;</span>)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="../../images/swiftui-list/4.png" alt="SwiftUI ForEach用法"></p><p>这里面有两点需要注意：</p><ol><li><code>@State</code> 通过添加<a href="./swiftui-concept-essential">数据绑定</a>使view的改变和数据联系起来，如果不添加这个会报错 <mark class="label danger">Cannot use mutating member on immutable value: self is immutable</mark></li><li><code>.onDelete</code> 添加了这个<a href="./swiftui-concept-essential">modifire</a>后出现左滑删除的效果</li></ol><h3 id="ScrollView嵌套ForEach"><a href="#ScrollView嵌套ForEach" class="headerlink" title="ScrollView嵌套ForEach"></a>ScrollView嵌套ForEach</h3><p>用横向滚动的<code>ScrollView</code>嵌套<code>ForEach</code>可以实现类似UIKit中横向滚动的<code>UICollectionView</code>。</p><p><img src="../../images/swiftui-list/5.png" alt="SwiftUI ForEach用法"></p><h3 id="Section嵌套ForEach"><a href="#Section嵌套ForEach" class="headerlink" title="Section嵌套ForEach"></a>Section嵌套ForEach</h3><p>使用List、Section、ForEach嵌套来实现类似于UITableView的分组效果。</p><p>还是使用上面的学生例子，现在我们来给学生分班。先来创建两个班级：</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">enum</span> <span class="title">StuCls</span>: <span class="title">String</span>, <span class="title">CaseIterable</span> </span>&#123;</span><br><span class="line">    <span class="keyword">case</span> <span class="type">ClsOne</span> <span class="operator">=</span> <span class="string">&quot;一班&quot;</span></span><br><span class="line">    <span class="keyword">case</span> <span class="type">ClsTwo</span> <span class="operator">=</span> <span class="string">&quot;二班&quot;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>把学生划分到班级里面</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Student</span>: <span class="title">Identifiable</span> </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> id: <span class="type">Int</span></span><br><span class="line">    <span class="keyword">var</span> name: <span class="type">String</span></span><br><span class="line">    <span class="keyword">var</span> classId: <span class="type">StuCls</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>接下来创建几个分好班的学生：</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> std1 <span class="operator">=</span> <span class="type">Student</span>(id: <span class="number">0</span>, name: <span class="string">&quot;学生1&quot;</span>, classId: <span class="type">StuCls</span>.<span class="type">ClsOne</span>)</span><br><span class="line"><span class="keyword">let</span> std2 <span class="operator">=</span> <span class="type">Student</span>(id: <span class="number">1</span>, name: <span class="string">&quot;学生2&quot;</span>, classId: <span class="type">StuCls</span>.<span class="type">ClsOne</span>)</span><br><span class="line"><span class="keyword">let</span> std3 <span class="operator">=</span> <span class="type">Student</span>(id: <span class="number">2</span>, name: <span class="string">&quot;学生3&quot;</span>, classId: <span class="type">StuCls</span>.<span class="type">ClsOne</span>)</span><br><span class="line"><span class="keyword">let</span> std4 <span class="operator">=</span> <span class="type">Student</span>(id: <span class="number">2</span>, name: <span class="string">&quot;学生4&quot;</span>, classId: <span class="type">StuCls</span>.<span class="type">ClsTwo</span>)</span><br><span class="line"><span class="keyword">let</span> std5 <span class="operator">=</span> <span class="type">Student</span>(id: <span class="number">2</span>, name: <span class="string">&quot;学生5&quot;</span>, classId: <span class="type">StuCls</span>.<span class="type">ClsTwo</span>)</span><br><span class="line"><span class="keyword">let</span> std6 <span class="operator">=</span> <span class="type">Student</span>(id: <span class="number">2</span>, name: <span class="string">&quot;学生6&quot;</span>, classId: <span class="type">StuCls</span>.<span class="type">ClsTwo</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> students <span class="operator">=</span> [std1, std2, std3, std4, std5, std6]</span><br></pre></td></tr></table></figure><p>最后，结合List、ForEach和Section创建可以分组的列表</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">List</span> &#123;</span><br><span class="line">    <span class="type">ForEach</span>(<span class="type">StuCls</span>.allCases, id: \.rawValue) &#123; cls <span class="keyword">in</span></span><br><span class="line">        <span class="type">Section</span>(header: <span class="type">Text</span>(cls.rawValue)) &#123;</span><br><span class="line">            <span class="type">ForEach</span>(students.filter &#123; <span class="variable">$0</span>.classId <span class="operator">==</span> cls &#125;, id: \.id) &#123; stu <span class="keyword">in</span></span><br><span class="line">                <span class="type">Text</span>(<span class="string">&quot;student id:<span class="subst">\(stu.id)</span> name: <span class="subst">\(stu.name)</span>&quot;</span>)</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="../../images/swiftui-list/6.png" alt="SwiftUI ForEach用法"></p><div class="note info"><p>到公众号【iOS开发栈】学习更多SwiftUI、iOS开发相关内容。回复“博客”免费获取各大互联网公司面试题。</p></div><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>在这篇文章中我们学习了SwiftUI中<code>List</code>/<code>ForEach</code>/<code>ScrollView</code>/<code>Section</code>的用法，并利用一个例子详细说明了前两个的不同和使用场景。你应该学到了：</p><ul><li><code>List</code>和<code>ForEach</code>的用法，它们之间的区别和使用场景</li><li>怎么创建一个像UICollectionView一样横向滚动的列表</li><li>类似UITableView的分组列表要怎样实现</li><li>头部固定不动和跟随滚动的列表的实现方案</li></ul>]]></content>
      
      
      
        <tags>
            
            <tag> SwiftUI </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>学习SwiftUI，必须掌握的3个知识点</title>
      <link href="swiftui/swiftui-concept-essential/"/>
      <url>swiftui/swiftui-concept-essential/</url>
      
        <content type="html"><![CDATA[<p>在WWDC2019中，iOS引入了一个全新的UI框架——SwiftUI。它的目的是通过全新的设计思想来解决iPhone、iPad、Mac的界面统一，以便开发者可以通过一次学习多处使用（Learn Once, Use anywhere）。从iOS13开始我们就可以使用这个全新的框架了，iOS开发者应该尽快掌握它。</p><a id="more"></a><div class="note info"><p>到公众号【iOS开发栈】学习更多SwiftUI、iOS开发相关内容。回复“博客”免费获取各大互联网公司面试题。</p></div><h2 id="View"><a href="#View" class="headerlink" title="View"></a>View</h2><p>SwiftUI中一切皆View，不论是我们熟悉的<code>Button</code>还是<code>backgroundColor</code>，甚至<code>Color.red</code>，它们都是<code>View</code>。</p><p>与UIKit中的<code>UIView</code>不同的是，在SwiftUI中<code>View</code>不再是一个类而是一个协议。`</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">protocol</span> <span class="title">View</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/// The type of view representing the body of this view.</span></span><br><span class="line">    <span class="comment">///</span></span><br><span class="line">    <span class="comment">/// When you create a custom view, Swift infers this type from your</span></span><br><span class="line">    <span class="comment">/// implementation of the required `body` property.</span></span><br><span class="line">    <span class="keyword">associatedtype</span> <span class="type">Body</span> : <span class="type">View</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">/// The content and behavior of the view.</span></span><br><span class="line">    <span class="meta">@ViewBuilder</span> <span class="keyword">var</span> body: <span class="keyword">Self</span>.<span class="type">Body</span> &#123; <span class="keyword">get</span> &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>SwiftUI中的View是不能直接使用的，否则会报错 <mark class="label danger">'View' cannot be constructed because it has no accessible initializers</mark>，当你遇到这个问题的时候请仔细思考一下你是不是真的要这么用，或许可以用一个其他的代替。</p><p>常用到的<code>View</code>有：<code>Text</code>/<code>Button</code>/<code>Toggle</code>/<code>Picker</code>/<code>V(Z)(H)Stack</code>/<code>Color</code>/<code>Spacer</code>/<code>Image</code>/<code>Shape</code>/<code>Divider</code>以及它们的<code>modifier</code>等。</p><p><code>@ViewBuilder</code>标记的<code>body</code>变量表示它是一个容器，里面可以包含任意多个其他的<code>View</code>。</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">Button</span>(action: btnClick) &#123;</span><br><span class="line">    <span class="type">VStack</span> &#123;</span><br><span class="line">        <span class="type">Image</span>(systemName: <span class="string">&quot;star&quot;</span>)</span><br><span class="line">        <span class="type">Text</span>(<span class="string">&quot;Placeholder&quot;</span>)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="Modifer"><a href="#Modifer" class="headerlink" title="Modifer"></a>Modifer</h2><p>我们分别看一下在UIKit和SwiftUI中修改一个Label的文字颜色</p><div class="tabs" id="modify-label-text-color"><ul class="nav-tabs"><li class="tab active"><a href="#modify-label-text-color-1">UIKit</a></li><li class="tab"><a href="#modify-label-text-color-2">SwiftUI</a></li></ul><div class="tab-content"><div class="tab-pane active" id="modify-label-text-color-1"><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> label <span class="operator">=</span> <span class="type">UILabel</span>()</span><br><span class="line">label.text <span class="operator">=</span> <span class="string">&quot;UIKit&quot;</span></span><br><span class="line">label.textColor <span class="operator">=</span> <span class="type">UIColor</span>.red</span><br></pre></td></tr></table></figure></div><div class="tab-pane" id="modify-label-text-color-2"><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">Text</span>(<span class="string">&quot;SwiftUI&quot;</span>).foregroundColor(.red)</span><br></pre></td></tr></table></figure></div></div></div><p>SwiftUI中的<code>.foregroundColor</code>和<code>textColor</code>有本质的不同，它是一种<strong>modifier</strong>，它返回的是令一个View。</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">@inlinable</span> <span class="keyword">public</span> <span class="function"><span class="keyword">func</span> <span class="title">foregroundColor</span><span class="params">(<span class="keyword">_</span> color: Color?)</span></span> -&gt; <span class="keyword">some</span> <span class="type">View</span></span><br></pre></td></tr></table></figure><p>当我们调用了<code>.foregroundColor</code>其实是创造了一个新的View，这也正是SwiftUI中万物皆View的例子。</p><h2 id="State和-——-Binding-Value"><a href="#State和-——-Binding-Value" class="headerlink" title="@State和$ —— Binding Value"></a>@State和$ —— Binding Value</h2><div class="tabs" id="toggle"><ul class="nav-tabs"><li class="tab active"><a href="#toggle-1">代码</a></li><li class="tab"><a href="#toggle-2">效果图</a></li></ul><div class="tab-content"><div class="tab-pane active" id="toggle-1"><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">ContentView</span>: <span class="title">View</span> </span>&#123;</span><br><span class="line">    <span class="meta">@State</span> <span class="keyword">var</span> isOn: <span class="type">Bool</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">var</span> body: <span class="keyword">some</span> <span class="type">View</span> &#123;</span><br><span class="line">        <span class="type">Toggle</span>(isOn: <span class="variable">$isOn</span>) &#123;</span><br><span class="line">            <span class="type">Text</span>(<span class="string">&quot;Toggle&quot;</span>)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div><div class="tab-pane" id="toggle-2"><p><img src="../images/swiftui-concept/1.png" alt="SwiftUI Toggle Binding"></p></div></div></div><blockquote><p>这是一个双向绑定</p></blockquote><p>绑定建立以后，不论是<code>isOn</code>的修改触发了Toggle状态的改变，还是用户点击了Toggle引起<code>isOn</code>变量值的改变我们都不需要关心，SwiftUI会帮我们完成。</p><div class="note info"><p>到公众号【iOS开发栈】学习更多SwiftUI、iOS开发相关内容。回复“博客”免费获取各大互联网公司面试题。</p></div><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>这篇文章聊了SwiftUI中最基础最重要的3个概念，如果你有任何的问题、建议都可以通过<a href="https://weibo.com/7414691003/profile">微博</a>或<a href="mailto:shizhiang@126.com">邮件</a>联系到我本人。</p>]]></content>
      
      
      
        <tags>
            
            <tag> SwiftUI </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>最佳实践：iOS开发在xib/storyboard中自定义view</title>
      <link href="how-to-make-view-get-intrinsic-content-size/"/>
      <url>how-to-make-view-get-intrinsic-content-size/</url>
      
        <content type="html"><![CDATA[<p>在xib或者storyboard嵌套另一个用xib布局的view是一个经常用到的技术点，要完全掌握好这个知识点不是那么容易，用常规的xib创建view的方法通常并不能满足我们的需求。</p><p>当我们使用Autolayout自动布局时，在xib中嵌套一个自定义的view可能就更麻烦了。通过这篇文章你将学习到嵌套xib布局的方法和怎么在xib中使用autolayout的一些高级用法来使view向label一样具有contrisic content size。</p><a id="more"></a><h3 id="从xib加载自定义view视图"><a href="#从xib加载自定义view视图" class="headerlink" title="从xib加载自定义view视图"></a>从xib加载自定义view视图</h3><p>新建项目:<br><img src="../images/xib-view/xib-1.png"></p><p>添加view和xib到项目中：</p><p><img src="../images/xib-view/xib-4.png"><br><img src="../images/xib-view/xib-2.png"><br><img src="../images/xib-view/xib-3.png"></p><p>设置xib的大小为freedom，并设置xib的大小为 200x100</p><p><img src="../images/xib-view/xib-6.png"><br><img src="../images/xib-view/xib-7.png"></p><p><strong>设置xib的 Fils’s Owner 为CustomView，不要设置view的class</strong></p><p><img src="../images/xib-view/xib-5.png"></p><h3 id="xib文件中添加view并设置约束"><a href="#xib文件中添加view并设置约束" class="headerlink" title="xib文件中添加view并设置约束"></a>xib文件中添加view并设置约束</h3><p><img src="../images/xib-view/xib-8.png"></p><p>设置约束后的xib是这样：</p><p><img src="../images/xib-view/xib-15.png"></p><h3 id="xib和-m建立链接"><a href="#xib和-m建立链接" class="headerlink" title=".xib和.m建立链接"></a>.xib和.m建立链接</h3><p><img src="../images/xib-view/xib-13.png"></p><h3 id="重写initWithCoder-方法把xib中的view添加进来"><a href="#重写initWithCoder-方法把xib中的view添加进来" class="headerlink" title="重写initWithCoder:方法把xib中的view添加进来"></a>重写<code>initWithCoder:</code>方法把xib中的view添加进来</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">- (instancetype)initWithCoder:(NSCoder *)coder</span><br><span class="line">&#123;</span><br><span class="line">    self &#x3D; [super initWithCoder:coder];</span><br><span class="line">    if (self) &#123;</span><br><span class="line">        &#x2F;&#x2F; 加载xib，注意owner: self</span><br><span class="line">        [[NSBundle mainBundle] loadNibNamed:NSStringFromClass([self class]) owner:self options:nil];</span><br><span class="line">        self.contentView.frame &#x3D; self.bounds;</span><br><span class="line">        [self addSubview:self.contentView];</span><br><span class="line">    &#125;</span><br><span class="line">    return self;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="在Main-storyboard中添加CustomView，并设置约束"><a href="#在Main-storyboard中添加CustomView，并设置约束" class="headerlink" title="在Main.storyboard中添加CustomView，并设置约束"></a>在Main.storyboard中添加CustomView，并设置约束</h3><img src="../images/xib-view/xib-9.png"/><img src="../images/xib-view/xib-10.png"  style="height:300px"/><p>这时候会报错，因为view的约束不足。</p><p><img src="../images/xib-view/xib-11.png"></p><h3 id="让UIView像UILabel一样拥有IntrinsicContentSize"><a href="#让UIView像UILabel一样拥有IntrinsicContentSize" class="headerlink" title="让UIView像UILabel一样拥有IntrinsicContentSize"></a>让UIView像UILabel一样拥有IntrinsicContentSize</h3><p>在UIKit中有一些视图具有intrinsicContentSize，比如UILabel、UIButotn、UIImageView等。这类视图可以根据自身的内容确定大小，在设置约束时只需要确定位置（x/y）就可以了。</p><p>但是UIView本身是不具备这个特性的，不过我们可以通过在xib或者storyboard中<strong>设置intrinsicSize来告诉编译器当前的视图是可以确定自身大小的</strong>。</p><p><img src="../images/xib-view/xib-12.png"></p><p>这样设置以后约束不足的警告就没有了。</p><p><img src="../images/xib-view/xib-16.png"></p><p>最终，view controller中customView的展示就是.xib中的样子了。</p><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>通过这篇文章我们可以学到：</p><ul><li>xib自定义view的方法</li><li>让UIView像UILabel一样拥有IntrinsicContentSize的方法</li><li>xib嵌套使用的方法</li></ul><p><strong>想了解更多内容关注公众号【iOS开发栈】。</strong></p>]]></content>
      
      
      
        <tags>
            
            <tag> iOS </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>什么是Content Hugging Priorities/Content Compression Resistance Priorities</title>
      <link href="What-is-Content-Hugging-Priorities-Content-Compression-Resistance-Priorities/"/>
      <url>What-is-Content-Hugging-Priorities-Content-Compression-Resistance-Priorities/</url>
      
        <content type="html"><![CDATA[<p>这两个优先级属性都是用在iOS开发时Auto Layout布局中的。</p><a id="more"></a><h3 id="Content-Hugging-Priorities"><a href="#Content-Hugging-Priorities" class="headerlink" title="Content Hugging Priorities"></a>Content Hugging Priorities</h3><p><strong>Content Hugging Priorities：在Auto Layout中，当子视图不足以填充满空间时，优先满足此属性值较大的子视图的内容展示，而拉伸属性值较低的子视图。</strong></p><p>假设有这样一种情况，两个水平排列的UILabel中分别显示“斜杠程序员”和“<a href="http://www.iosprogrammer.tech“,给它们加上5个约束,其中2、3、5是水平约束,假设这3个水平约束的值都是10/">www.iosprogrammer.tech“，给它们加上5个约束，其中2、3、5是水平约束，假设这3个水平约束的值都是10</a>.</p><p>现在两个UILabel里面文字内容所占大小加上3个水平约束的值仍然小于（&lt;）父视图的宽度。此时会发现storyboard中有报错，但是我们仍然可以正常运行项目并看到展示结果。<br><img src="../images/hugging-prority-1.png"><br><img src="../images/hugging-prority-2.png"><br><img src="../images/hugging-prority-3.png"></p><p>我们可以看到“<a href="http://www.iosprogrammer.tech“所在label所占的空间变大了.此时设置这个label的content/">www.iosprogrammer.tech“所在label所占的空间变大了。此时设置这个label的Content</a> Hugging Priorities为750。</p><p><img src="../images/hugging-prority-4.png"><br><img src="../images/hugging-prority-5.png"></p><p>“<a href="http://www.iosprogrammer.tech“所在label刚好满足展示内容,而“斜杠程序员”所在label所占空间变大了./">www.iosprogrammer.tech“所在label刚好满足展示内容，而“斜杠程序员”所在label所占空间变大了。</a></p><p>这也就是Content Hugging Priorities的作用，控制当内容不足以填充满空间时，优先满足此属性值较大的子view的内容展示，而拉伸属性值较低的子view。</p><h3 id="Content-Compression-Resistance-Priorities"><a href="#Content-Compression-Resistance-Priorities" class="headerlink" title="Content Compression Resistance Priorities"></a>Content Compression Resistance Priorities</h3><p><strong>Content Compression Resistance Priorities：在Auto Layout中，当子视图所需的内容超出父视图的空间时，优先展示此值较大的子视图，而省略压缩此值较小的子视图。</strong></p><p>假设有这样一种情况，两个水平排列的UILabel中分别显示“斜杠程序员专注于提高编程能力”和“斜杠程序员的官方网站是<a href="http://www.iosprogrammer.tech“,给它们加上5个约束,其中2、3、5是水平约束,假设这3个水平约束的值都是10/">www.iosprogrammer.tech“，给它们加上5个约束，其中2、3、5是水平约束，假设这3个水平约束的值都是10</a>.</p><p>现在两个UILabel里面文字内容所占大小超过了父视图的宽度。此时会发现storyboard中有报错，但是我们仍然可以正常运行项目并看到展示结果。<br><img src="../images/hugging-prority-6.png"><br><img src="../images/hugging-prority-7.png"><br><img src="../images/hugging-prority-8.png"></p><p>第一个Label被压缩了，里面的文字被省略了；第二个label正常展示了出来。此时我们把第一个label的Content Compression Resistance Priorities设置到大于第二个label。</p><p><img src="../images/hugging-prority-9.png"><br><img src="../images/hugging-prority-10.png"></p><p>可以看到第二个label被压缩了，第一个label正常展示了出来。</p><p><strong>Content Compression Resistance Priorities：在Auto Layout中，当子视图所需的内容超出父视图的空间时，优先展示此值较大的子视图，而省略压缩此值较小的子视图。</strong></p><p><a href="https://medium.com/@dineshk1389/content-hugging-and-compression-resistance-in-ios-35a0e8f19118">参考文章</a></p>]]></content>
      
      
      
        <tags>
            
            <tag> iOS </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>UIStackView的正确使用姿势（最新最全、配视频教程）</title>
      <link href="UIStackView-Advanced-Knowledge/"/>
      <url>UIStackView-Advanced-Knowledge/</url>
      
        <content type="html"><![CDATA[<p>UIStackView在iOS9之后开始使用，继承自UIView，用来管理在它内部的views，<text style="color:#1E90FF">但是并不会被渲染出来</text>，经过我在工作中的使用总结，它确实可以很大程度提高界面开发效率，每一个iOS开发者都应该熟练掌握UIStackView的使用。</p><a id="more"></a><div class="note info"><p>到公众号【iOS开发栈】学习更多SwiftUI、iOS开发相关内容。回复“博客”免费获取各大互联网公司面试题。</p></div><p>本文将分为基础和进阶两部分来讲解UIStackView，因此如果已经一定程度的使用过UIStackView，那么可以直接跳转到进阶部分。</p><h3 id="UIStackView基础入门知识"><a href="#UIStackView基础入门知识" class="headerlink" title="UIStackView基础入门知识"></a>UIStackView基础入门知识</h3><p>UIStackview的主要作用是管理<code>arrangedSubviews</code>数组中的view的布局，管理数组的有三个方法<br>    - addArrangedSubview:<br>    - removeArrangedSubview:<br>    - insertArrangedSubview:atIndex:</p><p>UIStackView中arrangedSubview的布局主要是使用<code>UILayoutConstraintAxis</code> <code>UIStackViewDistribution</code> <code>UIStackViewAlignment</code> <code>spacing</code> 几个属性。</p><ol><li><p><code>UILayoutConstraintAxis</code> - 确定arrangedSubviews的排列方向，分为Horizontal和Vertical</p></li><li><p><code>UIStackViewDistribution</code> - arrangedSubviews<strong>在排列方向</strong>的布局方式</p><ol><li>UIStackViewDistributionFill 把UIStackView的空间填充满，对于有intrinsic content size的UIView（UILabel、UIButton、UIImageView、UIControl）需要通过设置Size Inspector中的<a href="https://www.iosprogrammer.tech/What-is-Content-Hugging-Priorities-Content-Compression-Resistance-Priorities/">Content Hugging Property</a>来决定优先满足哪个view的contrinsicSize，如果property相同则会默认选择第一个。</li><li>UIStackViewDistributionFillEqually arrangedSubviews平分UIStackView 排列方向上除了spacing的空间</li><li>UIStackViewDistributionFillProportionally 按比例分配每个arrangedSubview所占大小，按照每个arrangedSubview的intrinsic content size的比例</li><li>UIStackViewDistributionEqualSpacing 当arrangedSubviews不能填满时，空白区域会平均分配，而不会自动拉伸Hugging Property较低的view；如果arrangedSubviews放不开时，会优先保证<a href="https://www.iosprogrammer.tech/What-is-Content-Hugging-Priorities-Content-Compression-Resistance-Priorities/">compression resistance priority</a>较高的view内容能够完全展示，priority相同时会默认保证第一个view。</li><li>UIStackViewDistributionEqualCentering view中心之间的spacing相等。当spacing值过大，无法满足所有view都能正常展示，会优先保证compression resistance priority较高的view内容能够完全展示，priority相同时会默认保证第一个view。</li></ol></li><li><p>UIStackViewAlignment - arrangedSubviews<strong>垂直于排列方向</strong>的布局方式</p><ol><li>UIStackViewAlignmentFill 完全填充</li><li>UIStackViewAlignmentLeading/UIStackViewAlignmentTop 靠上/右</li><li>UIStackViewAlignmentTrailing/UIStackViewAlignmentBottom 靠下/左</li><li>UIStackViewAlignmentFirstBaseline/UIStackViewAlignmentLastBaseline 文字基线 下/上</li></ol></li><li><p>spacing - arrangedSubview的间距。对于<code>UIStackViewDistributionFillxxx</code>就是准确的距离，对于UIStackViewDistributionEqualSpacing、UIStackViewDistributionEqualCentering 是最小距离，<strong>使用负数view会覆盖</strong></p></li></ol><p>掌握了上面的基础知识后基本就可以上手使用UIStackView了。</p><h3 id="UIStackView进阶知识"><a href="#UIStackView进阶知识" class="headerlink" title="UIStackView进阶知识"></a>UIStackView进阶知识</h3><p>Q1. 在UIStackView中可以对子view使用约束吗？<br>A1. UIStackView是基于约束来确定里面arrangedSubview的布局的，手动给某一个arrangedSubview指定约束时，会优先满足指定的约束，不过因为系统也会根据我们设置的属性添加约束，所以要当心会出现约束冲突。</p><p>Q2. UIStackView.arrangedViews 和 UIStackView.subViews的关系？<br>A2. arragedViews是subViews的子集 </p><ol><li>UIStackView addSubview 并不会添加到arrangedSubviews中；</li><li>当向arrangedSubviews中添加view时会自动添加到subviews中 </li><li>把一个只在subview而不在arrangedview中的view移除时也不会影响到arrangedview </li><li>一个view既在subviews中又在arrangedviews中时，当把它从subviews中移除，也会自动从arragedviews中移除，反之则不然</li></ol><p>Q3. UIStackView设置了背景色为什么显示不出来？<br>A3. UIStackView虽然是UIView的子类，但是它并不会被渲染，所以设置背景色并没有什么显示，但是设置圆角是有作用的。</p><p>Q4. UIStackView怎么设置某一个子view和后面view的距离？<br>A4. 在iOS11之后UIStackView新加了方法可以设置<code>setCustomSpacing:afterView</code></p><div class="note info"><p>到公众号【iOS开发栈】学习更多SwiftUI、iOS开发相关内容。回复“博客”免费获取各大互联网公司面试题。</p></div><iframe src="//player.bilibili.com/player.html?bvid=BV1wz4y1674t&page=1" scrolling="no" border="0" frameborder="no" framespacing="0" allowfullscreen="true" width="100%" height="300px"> </iframe>]]></content>
      
      
      
        <tags>
            
            <tag> iOS </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>iOS开发xib和代码设置颜色不同的解决方法及其原理（深度好文）</title>
      <link href="xib-color-different-with-hard-code/"/>
      <url>xib-color-different-with-hard-code/</url>
      
        <content type="html"><![CDATA[<p>本文主要包括两部分，其一是解决xib设置颜色有偏差的问题，其二是聊一下颜色的一些基础知识。</p><a id="more"></a><div class="note info"><p>到公众号【iOS开发栈】学习更多SwiftUI、iOS开发相关内容。回复“博客”免费获取各大互联网公司面试题。</p></div><h2 id="xib和代码设置颜色有偏差的原因"><a href="#xib和代码设置颜色有偏差的原因" class="headerlink" title="xib和代码设置颜色有偏差的原因"></a>xib和代码设置颜色有偏差的原因</h2><p>在开发iOS app的过程中我们都是按照设计同学给出的标注来做的，而UI同学在作图时使用到的工具就会有“<strong>颜色配置文件（Color Profile）</strong>”。（下面有颜色配置文件的说明）</p><p><img src="../images/ps-color-profile.png" alt="PS中的颜色配置文件"></p><p>从上图可以看出，ps默认的颜色配置文件是sRGB，因此设计给我们的图都是以sRGB为准的。</p><p>但是在Xcode的ib相关文件中设置颜色时，默认的颜色配置文件是Generic RGB的。</p><p><img src="../images/xcode-xib-colors.png" alt="Xcode-colors"></p><p>因此，如果我们直接按照sRGB标的色值在Generic RGB的配置下进行设置就会出现色差了。</p><p>通过下面的GIF可以更直观的看到这种差异</p><p><img src="../images/record.gif"></p><p>而代码设置颜色时默认是采用的和photoshop一样的sRGB，也是和xib的Generic RGB不相同的，所以代码设置的颜色和UI同学提供的是一样的，而xib中是和他们两个不一样的。</p><h2 id="xib设置颜色和代码有差异的问题解决方案"><a href="#xib设置颜色和代码有差异的问题解决方案" class="headerlink" title="xib设置颜色和代码有差异的问题解决方案"></a>xib设置颜色和代码有差异的问题解决方案</h2><p>解决方案有两种，一种是把sRGB的色值转化成Generic RGB之后再进行设置，另一种是把配置改成sRGB的再进行设置。</p><p>这里用到的不同颜色配置之间进行转换的工具可以用mac自带的ColorSync Utility</p><center class="half" style="display:flex;margin-left:10%">    <img src="../images/colorsyncutilityicon.png" width="200"/><img src="../images/colorsyncinterface.png" width="300"/></center><h2 id="xib和代码设置的颜色有差异的原理分析"><a href="#xib和代码设置的颜色有差异的原理分析" class="headerlink" title="xib和代码设置的颜色有差异的原理分析"></a>xib和代码设置的颜色有差异的原理分析</h2><p>上面说到了xib默认的颜色配置和ps、代码都是不同的，说到颜色配置（Color Profile）就不得不说颜色模型（Color Model）和颜色空间（Color Space）。</p><p>众所周知，计算机、摄像机、打印机等数字设备中只能认识0和1（不然它们也不会叫数字设备了🐶），因此为了把自然界中的五颜六色在数字设备中展示出来，<strong>颜色转换成数字的算法（公式）—— 颜色模型</strong> 就出现了。</p><p>现在被广泛使用的颜色模型有RGB、CMYK、CIELAB等，其中RGB主要用在摄像机、显示器等领域，CMYK主要用在打印机领域，具体内容可以查看<a href="https://www.dpbestflow.org/color/color-space-and-color-profiles">这篇文章</a></p><p>有了算法，就要有<strong>颜色模型具体的算法实现——颜色空间</strong>。之所以叫空间是因为每一个具体的颜色空间都有一个范围</p><p><img src="../image/../images/v2-374053ce809551b3eeef09046f48b074_1440w.jpg"></p><p>正如上图所示，颜色空间都是有不同的范围的，而不同范围的颜色空间进行转换的时候就会有损失，也就会造成<a href="https://zhuanlan.zhihu.com/p/72530732">色差</a>。</p><p><img src="../images/v2-53ebd97b57e169f8b395766d580a1ea9_1440w.jpg"></p><p>颜色模型可以理解为一个概念、理论，颜色空间是对颜色模型的一次具象描述，但是它还不能被计算机所理解。<strong>颜色配置正是能够直接被数字设备拿来用的具体文件</strong>。</p><p>在Mac电脑的ColorSync Utility应用中可以看到下面这些颜色配置</p><p><img src="../images/colorsyncprofiles.png"></p><div class="note info"><p>到公众号【iOS开发栈】学习更多SwiftUI、iOS开发相关内容。回复“博客”免费获取各大互联网公司面试题。</p></div><p>至此，我们把xib和代码设置颜色有偏差的现象彻底解决了，总结一句话就是：</p><blockquote><p>不同的颜色配置之间转换时会造成色差，而代码和xib进行颜色设置时使用了不同的颜色配置文件，才最终导致了同样的色值的最终表现不同。</p></blockquote>]]></content>
      
      
      
        <tags>
            
            <tag> iOS </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>OC编程基础</title>
      <link href="Programming-With-ObjC/"/>
      <url>Programming-With-ObjC/</url>
      
        <content type="html"><![CDATA[<p>OC编程基础</p><a id="more"></a><ul><li><code>+ (id)alloc</code>方法返回类型是<code>id</code>。这是Objective-C中的一个特殊的关键字，意味着“某种对象”。它是一个指向一个对象的指针（NSObject *），但它的特殊之处在于它不使用星号。</li><li><code>alloc</code>方法的另一个重要任务是通过把对象属性设置为0来清理为对象属性申请的内存。这避免了以前存储的包含垃圾内存的常见问题，但不足以完全初始化对象</li><li><code>- (id)init</code>方法也返回<code>id</code>。该方法被类用来确保它的属性在创建时具有合适的初始值。</li><li>创建对象时一定要把<code>alloc</code>嵌套在<code>init</code>中，就像<code>NSObject *newObject = [[NSObject alloc] init];</code>。因为<code>init</code>的返回对象可能和<code>alloc</code>返回的不相同</li><li><code>==</code>比较的是两个不同的指针是否指向相同的对象</li><li><code>isEqual:</code>是比较两个对象是否表示相同的数据</li><li>声明标量的时候指明一个初始值，<code>int number = 10;</code>，否则标量的初始值会包含之前栈内的垃圾内容</li><li>对象指针不需要设置初始值，因为会默认设置为nil。</li><li>nil是安全的，给nil发消息什么都不会发生。</li><li>实例变量的内存在对象首次创建时分配，并且当对象解除分配时释放。</li><li><code>@synthesize firstName;</code>的实例变量名称是<code>firstName</code>而不是<code>_firstName</code>。</li><li>你应该总是在initialization method中直接访问instance variable，因为在设置属性时，对象的其他部分可能还没有完全初始化。即时你确定没有提供自定义的访问器方法，并且你自己的类中没有任何副作用，但是你没办法保证将来的子类不会重写该方法。</li><li>当你要子类化一个带有多个<code>init</code>方法的类时，要么通过继承父类的指定初始化器来执行自己的初始化，要么加入自己的其他初始化器。无论哪种，你都应该在做自己的初始化前，调用父类的指定初始化器，来代替<code>[super init]</code>。</li><li>如果为一个readwrite的property实现了getter和setter，或者为readonly的property实现了getter，那么编译器就不会自动合成成员变量，如果需要成员变量，可以通过<code>@synthesize property = _property</code>来手动获取。</li><li>property默认是atomic。</li><li>atomic的属性要么同时自定义setter和getter，要么都由系统合成，如果只自定义一个会报编译器警告。</li><li><strong>Property atomicity is not synonymous with an object’s thread safety.</strong></li><li>__unsafe_unretained和weak类似都不会保持对象存活，但是__unsafe_unretained在目标对象释放后不会把它设置成nil。这就意味着被已释放对象占用的那块内存现在是一个悬挂指针，如果给这个悬挂指针发送消息会崩溃。</li><li>class extension中声明的一个readwrite的属性，会在这个类的所有对象中生成setter方法，虽然不能直接使用点语法或调用setxxx:，但是可以使用<code>performSelect...</code>或<code>objc_msgSend...</code>来调用。即使这个属性在类的public接口中是readonly的。</li><li>编译器不会自动合成采用的协议中声明的属性。</li><li>如果是跨api传递值，比如方法或函数中的参数，则最好是使用跨平台的类型（NSInteger/CGFloat…)；对于局部变量，例如循环中的计数器，则可以使用基本C类型（int/float…）</li><li>collection并不是以某种方式维护每个对象的单独副本，而是使用强引用来跟踪其内容。这意味着，<strong>只要colletion没有被销毁，它里面的任何对象都将保持活动状态</strong></li><li>使用<code>arrayWithObjects:</code>和<code>initWithObjects:</code>创建数组时，最后要带上<code>nil</code>。</li><li>使用字面量语法创建数组时，不能包含<code>nil</code>，可以使用<code>NSNull</code>来代替<code>nil</code>。</li><li><code>NSArray</code>是有序的collection，会包含重复元素；<code>NSSet</code>是无序的collection，不包含重复元素。</li><li>不要在for循环里修改collection</li><li>block会捕获上下文</li><li>在block捕获上下文之后再修改上下文的内容不会改变block捕获的值。如果被捕获的变量使用<code>__block</code>修饰，则会被修改。</li></ul>]]></content>
      
      
      
        <tags>
            
            <tag> iOS </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>KVC/KVO 总结</title>
      <link href="KVC-KVO/"/>
      <url>KVC-KVO/</url>
      
        <content type="html"><![CDATA[<p>通过这篇文章彻底掌握KVO、KVO的知识点。</p><a id="more"></a><h3 id="访问对象属性"><a href="#访问对象属性" class="headerlink" title="访问对象属性"></a>访问对象属性</h3><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">@interface</span> <span class="title">BankAccount</span>: <span class="title">NSobject</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">@property</span> (<span class="keyword">nonatomic</span>) <span class="built_in">NSNumber</span> *currentBalance; <span class="comment">// An attribute</span></span><br><span class="line"><span class="keyword">@property</span> (<span class="keyword">nonatomic</span>) Person *owner; <span class="comment">// A to-one relation</span></span><br><span class="line"><span class="keyword">@property</span> (<span class="keyword">nonatomic</span>) <span class="built_in">NSArray</span> &lt;Transaction *&gt;*transactions; <span class="comment">// A to-many relation</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">@end</span></span><br></pre></td></tr></table></figure><p><code>currentBalance</code>/<code>owner</code>/<code>transactions</code>都是<code>BankAccount</code>的属性。<code>owner</code>属性是一个对象，和<code>BankAccount</code>构成一对一的关系，owner对象中的属性改变后并不会影响到owner本身。</p><p>为了保持封装，对象通常为其接口上的属性提供访问器方法（accessor methods）。在使用访问器方法时必须在编译之前将属性名称写入代码中。访问器方法的名称成为使用它的代码的静态部分。例如：<br><code>[myAccount setCurrentBalance:@(100.0)];</code><br>这样缺乏灵活性，KVC提供了使用字符串标识符访问对象属性的更通用的机制。</p><h4 id="使用key和key-path-标识对象的属性"><a href="#使用key和key-path-标识对象的属性" class="headerlink" title="使用key和key path 标识对象的属性"></a>使用key和key path 标识对象的属性</h4><p>key: 标识特定属性的字符串。通常表示属性的key是代码中显示的属性本身的名称。<br>key必须使用ASCII编码，可能不包含空格，并且通常是以小写字母开头（URL除外）。<br>上面的赋值过程使用KVC表示:<br><code>[myAccount setValue:@(100.0) forKey:@&quot;currentBalance&quot;];</code></p><p>key path: 用来指定要遍历的对象属性序列的一串使用“.”分隔的key。序列中的第一个键的属性是相对于接受者的，并且每个后续键是相对于前一个属性的值的。当需要使用一个方法来向下逐级获取对象层次结构时，key path特别有用。<br>例如，<code>owner.address.street</code>应用于银行账户实例的key path是指存储在银行账户所有者地址中的<code>street</code>字符串的值。</p><h4 id="使用key获取属性值"><a href="#使用key获取属性值" class="headerlink" title="使用key获取属性值"></a>使用key获取属性值</h4><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line">- (<span class="keyword">void</span>)getAttributeValuesUsingKeys &#123;</span><br><span class="line">    Account *myAccount = [[Account alloc] init];</span><br><span class="line">    myAccount.currBalance = @<span class="number">100</span>;</span><br><span class="line">    </span><br><span class="line">    Person *owner = [[Person alloc] init];</span><br><span class="line">    Address *address = [[Address alloc] init];</span><br><span class="line">    address.street = <span class="string">@&quot;第三大道&quot;</span>;</span><br><span class="line">    owner.address = address;</span><br><span class="line">    myAccount.owner = owner;</span><br><span class="line">    </span><br><span class="line">    Transaction *t1 = [[Transaction alloc] init];</span><br><span class="line">    Person *p1 = [[Person alloc] init];</span><br><span class="line">    p1.name = <span class="string">@&quot;p1&quot;</span>;</span><br><span class="line">    t1.payee = p1;</span><br><span class="line">    </span><br><span class="line">    Transaction *t2 = [[Transaction alloc] init];</span><br><span class="line">    Person *p2 = [[Person alloc] init];</span><br><span class="line">    p2.name = <span class="string">@&quot;p2&quot;</span>;</span><br><span class="line">    t2.payee = p2;</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">NSArray</span> *ts = @[t1, t2];</span><br><span class="line">    myAccount.transactions = ts;</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">NSNumber</span> *currBalance = [myAccount valueForKey:<span class="string">@&quot;currBalance&quot;</span>];</span><br><span class="line">    <span class="built_in">NSLog</span>(<span class="string">@&quot;currBalance = %@&quot;</span>, currBalance); <span class="comment">// currBalance = 100</span></span><br><span class="line">    </span><br><span class="line">    <span class="built_in">NSString</span> *street = [myAccount valueForKeyPath:<span class="string">@&quot;owner.address.street&quot;</span>];</span><br><span class="line">    <span class="built_in">NSLog</span>(<span class="string">@&quot;street = %@&quot;</span>, street); <span class="comment">// street = 第三大道</span></span><br><span class="line">    </span><br><span class="line">    <span class="built_in">NSDictionary</span> *values = [myAccount dictionaryWithValuesForKeys:@[<span class="string">@&quot;currBalance&quot;</span>, <span class="string">@&quot;owner&quot;</span>]];</span><br><span class="line">    <span class="built_in">NSLog</span>(<span class="string">@&quot;values = %@&quot;</span>, values); <span class="comment">// values = &#123;currBalance = 100; owner = &quot;&lt;Person: 0x60000179af40&gt;&quot;;&#125;</span></span><br><span class="line">    </span><br><span class="line">    <span class="built_in">NSArray</span> *payees = [myAccount valueForKeyPath:<span class="string">@&quot;transactions.payee.name&quot;</span>];</span><br><span class="line">    <span class="built_in">NSLog</span>(<span class="string">@&quot;payees = %@&quot;</span>, payees); <span class="comment">// payees = (p1, p2)</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">// Terminating app due to uncaught exception &#x27;NSUnknownKeyException&#x27;, reason: &#x27;[&lt;Account 0x600002685ee0&gt; valueForUndefinedKey:]&#x27;</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">//    [myAccount valueForKey:@&quot;owner.address.street&quot;];</span></span><br><span class="line">    <span class="comment">//    [myAccount valueForKey:@&quot;test&quot;];</span></span><br><span class="line">    <span class="comment">//    [myAccount dictionaryWithValuesForKeys:@[@&quot;currBalance&quot;, @&quot;transactions.payee.name&quot;]];</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="使用key设置属性值"><a href="#使用key设置属性值" class="headerlink" title="使用key设置属性值"></a>使用key设置属性值</h4><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">- (<span class="keyword">void</span>)settingAttributeValuesUsingKeys &#123;</span><br><span class="line">    Account *myAccount = [[Account alloc] init];</span><br><span class="line">    [myAccount setValue:@<span class="number">100.0</span> forKey:<span class="string">@&quot;currBalance&quot;</span>];</span><br><span class="line">    <span class="built_in">NSLog</span>(<span class="string">@&quot;currBalance = %@&quot;</span>, myAccount.currBalance); <span class="comment">// currBalance = 100</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">// operationTimes是非引用类型，这里进行了和NSNumber的自动转换</span></span><br><span class="line">    [myAccount setValue:@<span class="number">10</span> forKey:<span class="string">@&quot;operationTimes&quot;</span>];</span><br><span class="line">    <span class="built_in">NSLog</span>(<span class="string">@&quot;operationTimes = %ld&quot;</span>, myAccount.operationTimes); <span class="comment">// operationTimes = 10</span></span><br><span class="line">    </span><br><span class="line">    Person *owner = [[Person alloc] init];</span><br><span class="line">    Address *address = [[Address alloc] init];</span><br><span class="line">   </span><br><span class="line">    [myAccount setValue:address forKeyPath:<span class="string">@&quot;owner.address&quot;</span>]; <span class="comment">// 这时候owner还是null</span></span><br><span class="line">    <span class="built_in">NSLog</span>(<span class="string">@&quot;address = %@&quot;</span>, myAccount.owner.address); <span class="comment">// address = (null)</span></span><br><span class="line">    </span><br><span class="line">    [myAccount setValue:owner forKeyPath:<span class="string">@&quot;owner&quot;</span>];</span><br><span class="line">    [myAccount setValue:address forKeyPath:<span class="string">@&quot;owner.address&quot;</span>];</span><br><span class="line">    <span class="built_in">NSLog</span>(<span class="string">@&quot;address = %@&quot;</span>, myAccount.owner.address); <span class="comment">// address = &lt;Address: 0x600001a43550&gt;</span></span><br><span class="line">    </span><br><span class="line">    [myAccount setValuesForKeysWithDictionary:@&#123;<span class="string">@&quot;currBalance&quot;</span>: @<span class="number">200.0</span>, <span class="string">@&quot;owner&quot;</span>: owner&#125;];</span><br><span class="line">    <span class="built_in">NSLog</span>(<span class="string">@&quot;currBalance = %@, owner = %@&quot;</span>, myAccount.currBalance, myAccount.owner); <span class="comment">// currBalance = 200, owner = &lt;Person: 0x600001478ee0&gt;</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">// Terminating app due to uncaught exception &#x27;NSUnknownKeyException&#x27;, reason: &#x27;[&lt;Account 0x6000029c2490&gt; setValue:forUndefinedKey:]: xxx&#x27;</span></span><br><span class="line">    <span class="comment">//    [myAccount setValue:@&quot;value&quot; forUndefinedKey:@&quot;undefinedKey&quot;];</span></span><br><span class="line">    <span class="comment">//    [myAccount setValuesForKeysWithDictionary:@&#123;@&quot;currBalance&quot;: @200.0, @&quot;owner.address.street&quot;: @&quot;第一大道&quot;&#125;];</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="访问集合属性"><a href="#访问集合属性" class="headerlink" title="访问集合属性"></a>访问集合属性</h3><p>符合键值编码的对象以与公开其他属性相同的方式公开其多对多属性。您可以使用<code>valueForKey:</code>或<code>setValue:forKey:</code>来获取或设置集合属性。但是，当你想要操作这些集合内容的时候，使用协议定义的可变代理方法通常是最有效的。<br>该协议为集合对象访问定义了三种不同的代理方法，每种方法都有一个key和key path变量：</p><ul><li><code>mutableArrayValueForKey:</code>和<code>mutableArrayValueForKeyPath:</code> 返回一个行为类似<code>NSMutableArray</code>的代理对象</li><li> <code>mutableSetValueForKey:</code>和<code>mutableSetValueFOrKeyPath:</code> 返回一个行为类似<code>NSMutableSet</code>的代理对象</li><li><code>mutableOrderedSetValueForKey:</code>和<code>mutableOrderedSetValueForKeyPath:</code> 返回一个行为类似<code>NSMutableOrderedSet</code>的代理对象<br>当您对代理对象进行操作，向对象添加元素，从中删除元素或者替换其中的元素时，协议的默认实现会相应地修改基础属性。这比使用<code>valueForKey:</code>获取一个不可变的集合对象，再创建一个可修改的集合，然后把修改后的集合通过<code>setValue:forKey:</code>更有效。在许多情况下，它比直接使用可变属性也是更有效的。这些方法为持有集合对象的对象们提供了维护KVO特性的好处。<figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">- (<span class="keyword">void</span>)accessingCollectionProperties &#123;</span><br><span class="line">    Transaction *t1 = [[Transaction alloc] init];</span><br><span class="line">    Transaction *t2 = [[Transaction alloc] init];</span><br><span class="line">    Account *myAccount = [[Account alloc] init];</span><br><span class="line">    </span><br><span class="line">    [myAccount addObserver:<span class="keyword">self</span> forKeyPath:<span class="string">@&quot;transactions&quot;</span> options:<span class="built_in">NSKeyValueObservingOptionOld</span> | <span class="built_in">NSKeyValueObservingOptionNew</span> context:<span class="literal">nil</span>];</span><br><span class="line">    </span><br><span class="line">    </span><br><span class="line">    [myAccount setValue:@[t1, t2] forKey:<span class="string">@&quot;transactions&quot;</span>];</span><br><span class="line">    <span class="built_in">NSLog</span>(<span class="string">@&quot;1st transactions = %@&quot;</span>, myAccount.transactions); <span class="comment">// 1st transactions = (&quot;&lt;Transaction: 0x6000009d1400&gt;&quot;,&quot;&lt;Transaction: 0x6000009d1420&gt;&quot;)</span></span><br><span class="line">    <span class="built_in">NSMutableArray</span> &lt;Transaction *&gt;*transactions = [myAccount mutableArrayValueForKey:<span class="string">@&quot;transactions&quot;</span>];</span><br><span class="line">    </span><br><span class="line">    [transactions addObject:[[Transaction alloc] init]];</span><br><span class="line">    <span class="built_in">NSLog</span>(<span class="string">@&quot;2nd transactions = %@&quot;</span>, myAccount.transactions); <span class="comment">// 2nd transactions = (&quot;&lt;Transaction: 0x6000009d1400&gt;&quot;,&quot;&lt;Transaction: 0x6000009d1420&gt;&quot;,&quot;&lt;Transaction: 0x6000009cabf0&gt;&quot;)</span></span><br><span class="line">    </span><br><span class="line">    [transactions removeLastObject];</span><br><span class="line">    <span class="built_in">NSLog</span>(<span class="string">@&quot;3th transactions = %@&quot;</span>, myAccount.transactions); <span class="comment">// 3th transactions = (&quot;&lt;Transaction: 0x6000009d1400&gt;&quot;,&quot;&lt;Transaction: 0x6000009d1420&quot;)</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="使用集合操作符"><a href="#使用集合操作符" class="headerlink" title="使用集合操作符"></a>使用集合操作符</h4>当您向<code>valueForKeyPath:</code>消息发送符合键值编码的对象时，可以在key path中嵌入集合运算符。集合运算符是一个小的关键字列表之一，前面是一个@符号，它指定了getter应该执行的操作，以便在返回之前以某种方式操作数据。<code>NSObject</code>为<code>valueForKeyPath:</code>提供了默认实现。<br>当key path包含集合运算符时，运算符之前的部分称为左键路径，指示相对于消息接受者操作的集合，当你直接向一个集合（例如<code>NSArray</code>）发送消息时左键路径或许可以省略。操作符之后的部分称为右键路径，指定操作符应处理的集合中的属性，除了<code>@count</code>之外的所有操作符都需要一个右键路径。<br><img src="http://image.iosprogrammer.hongbility.com/KVC_KVOkeypath.jpg"><br>集合运算符表现出三种基本类型的行为：</li><li><strong>聚合运算符</strong>以某种方式合并集合的对象，并返回通常与右键路径中指定的属性的数据类型匹配的单个对象。<code>@count</code>是一个例外，它没有正确的关键路径并始终将返回一个<code>NSNumber</code>实例。包括：<code>@avg</code>/<code>@count</code>/<code>@max</code>/<code>@min</code>/<code>@sum</code>。</li><li><strong>数组运算符</strong>返回一个<code>NSArray</code>实例，该实例包含命名集合中保存的对象的某个子集。包含：<code>@distinctUnionOfObjects</code>/<code>@unionOfObjects</code>。</li><li><strong>嵌套运算符</strong>处理包含其他集合的集合，并根据操作符返回一个<code>NSArray</code>或<code>NSSet</code>实例，它以某种方式组合嵌套集合的对象。包含：<code>@distinctUnionOfArrays</code>/<code>@unionOfArrays</code>/<code>@distinctUnionOfSets</code>。</li></ul><h4 id="示例"><a href="#示例" class="headerlink" title="示例"></a>示例</h4><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br></pre></td><td class="code"><pre><span class="line">- (<span class="keyword">void</span>)usingCollectionOperators &#123;</span><br><span class="line">    Transaction *t1 = [Transaction transactionWithPayee:<span class="string">@&quot;Green Power&quot;</span> amount:@(<span class="number">120.00</span>) date:[<span class="built_in">NSDate</span> dateWithTimeIntervalSinceNow:<span class="number">100</span>]];</span><br><span class="line">    Transaction *t3 = [Transaction transactionWithPayee:<span class="string">@&quot;Green Power&quot;</span> amount:@(<span class="number">170.00</span>) date:[<span class="built_in">NSDate</span> dateWithTimeIntervalSinceNow:<span class="number">300</span>]];</span><br><span class="line">    Transaction *t5 = [Transaction transactionWithPayee:<span class="string">@&quot;Car Loan&quot;</span> amount:@(<span class="number">250.00</span>) date:[<span class="built_in">NSDate</span> dateWithTimeIntervalSinceNow:<span class="number">500</span>]];</span><br><span class="line">    Transaction *t6 = [Transaction transactionWithPayee:<span class="string">@&quot;Car Loan&quot;</span> amount:@(<span class="number">250.00</span>) date:[<span class="built_in">NSDate</span> dateWithTimeIntervalSinceNow:<span class="number">600</span>]];</span><br><span class="line">    Transaction *t13 = [Transaction transactionWithPayee:<span class="string">@&quot;Animal Hospital&quot;</span> amount:@(<span class="number">600.00</span>) date:[<span class="built_in">NSDate</span> dateWithTimeIntervalSinceNow:<span class="number">500</span>]];</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">NSArray</span> *transactions = @[t1, t3, t5, t6, t13];</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/* 聚合运算符</span></span><br><span class="line"><span class="comment">     * 聚合运算符可以处理数组或属性集，从而生成反映集合某些方面的单个值。</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="comment">// @avg 平均值</span></span><br><span class="line">    <span class="built_in">NSNumber</span> *transactionAverage = [transactions valueForKeyPath:<span class="string">@&quot;@avg.amount&quot;</span>];</span><br><span class="line">    <span class="built_in">NSLog</span>(<span class="string">@&quot;transactionAverage = %@&quot;</span>, transactionAverage); <span class="comment">// transactionAverage = 278</span></span><br><span class="line">    <span class="comment">// @count 个数</span></span><br><span class="line">    <span class="built_in">NSNumber</span> *numberOfTransactions = [transactions valueForKeyPath:<span class="string">@&quot;@count&quot;</span>];</span><br><span class="line">    <span class="built_in">NSLog</span>(<span class="string">@&quot;numberOfTransactions = %@&quot;</span>, numberOfTransactions); <span class="comment">// numberOfTransactions = 5</span></span><br><span class="line">    <span class="comment">// @max 最大值 使用compare:进行比较</span></span><br><span class="line">    <span class="built_in">NSDate</span> *latestDate = [transactions valueForKeyPath:<span class="string">@&quot;@max.date&quot;</span>];</span><br><span class="line">    <span class="built_in">NSLog</span>(<span class="string">@&quot;latestDate = %@&quot;</span>, latestDate); <span class="comment">// latestDate = Thu Nov  1 15:05:59 2018</span></span><br><span class="line">    <span class="comment">// @min 最小值 使用compare:进行比较</span></span><br><span class="line">    <span class="built_in">NSDate</span> *earliestDate = [transactions valueForKeyPath:<span class="string">@&quot;@min.date&quot;</span>];</span><br><span class="line">    <span class="built_in">NSLog</span>(<span class="string">@&quot;earliestDate = %@&quot;</span>, earliestDate);<span class="comment">// earliestDate = Thu Nov  1 14:57:39 2018</span></span><br><span class="line">    <span class="comment">// @sum 总和</span></span><br><span class="line">    <span class="built_in">NSNumber</span> *amountSum = [transactions valueForKeyPath:<span class="string">@&quot;@sum.amount&quot;</span>];</span><br><span class="line">    <span class="built_in">NSLog</span>(<span class="string">@&quot;amountSum = %@&quot;</span>, amountSum); <span class="comment">// amountSum = 1390</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">/* 数组运算符</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * 数组运算符导致valueForKeyPath:返回与右键路径指示的特定对象集相对应的对象数组。</span></span><br><span class="line"><span class="comment">     * 如果使用数组运算符时任何叶对象为nil，则valueForKeyPath：方法会引发异常。</span></span><br><span class="line"><span class="comment">     **/</span></span><br><span class="line">    <span class="comment">// @distinctUnionOfObjects 创建并返回一个数组，该数组包含与右键路径指定的属性对应的集合的不同对象。会删除重复对象。</span></span><br><span class="line">    <span class="built_in">NSArray</span> *distinctPayees = [transactions valueForKeyPath:<span class="string">@&quot;@distinctUnionOfObjects.payee&quot;</span>];</span><br><span class="line">    <span class="built_in">NSLog</span>(<span class="string">@&quot;distinctPayees = %@&quot;</span>, distinctPayees); <span class="comment">// distinctPayees = (&quot;Green Power&quot;, &quot;Animal Hospital&quot;, &quot;Car Loan&quot;)</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">// @unionOfObjects 创建并返回一个数组，该数组包含与右键路径指定的属性对应的集合的所有对象。不删除重复对象</span></span><br><span class="line">    <span class="built_in">NSArray</span> *payees = [transactions valueForKeyPath:<span class="string">@&quot;@unionOfObjects.payee&quot;</span>];</span><br><span class="line">    <span class="built_in">NSLog</span>(<span class="string">@&quot;payees = %@&quot;</span>, payees); <span class="comment">// payees = (&quot;Green Power&quot;, &quot;Green Power&quot;, &quot;Car Loan&quot;, &quot;Car Loan&quot;, &quot;Animal Hospital&quot;)</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">/** 嵌套运算符</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * 嵌套运算符对嵌套集合进行操作，集合中的每个条目都包含一个集合。</span></span><br><span class="line"><span class="comment">     * 如果使用数组运算符时任何叶对象为nil，则valueForKeyPath：方法会引发异常。</span></span><br><span class="line"><span class="comment">     **/</span></span><br><span class="line">    Transaction *moreT1 = [Transaction transactionWithPayee:<span class="string">@&quot;General Cable - Cottage&quot;</span> amount:@(<span class="number">120.00</span>) date:[<span class="built_in">NSDate</span> dateWithTimeIntervalSinceNow:<span class="number">10</span>]];</span><br><span class="line">    Transaction *moreT2 = [Transaction transactionWithPayee:<span class="string">@&quot;General Cable - Cottage&quot;</span> amount:@(<span class="number">1550.00</span>) date:[<span class="built_in">NSDate</span> dateWithTimeIntervalSinceNow:<span class="number">3</span>]];</span><br><span class="line">    Transaction *moreT7 = [Transaction transactionWithPayee:<span class="string">@&quot;Hobby Shop&quot;</span> amount:@(<span class="number">600.00</span>) date:[<span class="built_in">NSDate</span> dateWithTimeIntervalSinceNow:<span class="number">160</span>]];</span><br><span class="line">    <span class="built_in">NSArray</span> *moreTransactions = @[moreT1, moreT2, moreT7];</span><br><span class="line">    <span class="built_in">NSArray</span> *arrayOfArrays = @[transactions, moreTransactions];</span><br><span class="line">    <span class="comment">// @distinctUnionOfArrays  指定@distinctUnionOfArrays运算符时，valueForKeyPath:创建并返回一个数组，该数组包含与右键路径指定的属性对应的所有集合的组合的不同对象。</span></span><br><span class="line">    <span class="built_in">NSArray</span> *collectedDistinctPayees = [arrayOfArrays valueForKeyPath:<span class="string">@&quot;@distinctUnionOfArrays.payee&quot;</span>];</span><br><span class="line">    <span class="built_in">NSLog</span>(<span class="string">@&quot;collectedDistinctPayees = %@&quot;</span>, collectedDistinctPayees); <span class="comment">// collectedDistinctPayees = ( &quot;General Cable - Cottage&quot;, &quot;Animal Hospital&quot;, &quot;Hobby Shop&quot;, &quot;Green Power&quot;, &quot;Car Loan&quot;)</span></span><br><span class="line">    <span class="comment">// @unionOfArrays 与@distinctUnionOfArrays 不同的是不会删除相同的元素</span></span><br><span class="line">    <span class="built_in">NSArray</span> *collectedPayees = [arrayOfArrays valueForKeyPath:<span class="string">@&quot;@unionOfArrays.payee&quot;</span>];</span><br><span class="line">    <span class="built_in">NSLog</span>(<span class="string">@&quot;collectedPayees = %@&quot;</span>, collectedPayees); <span class="comment">// collectedPayees = (&quot;Green Power&quot;, &quot;Green Power&quot;, &quot;Car Loan&quot;, &quot;Car Loan&quot;, &quot;Animal Hospital&quot;, &quot;General Cable - Cottage&quot;, &quot;General Cable - Cottage&quot;, &quot;Hobby Shop&quot;)</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">// @distinctUnionOfSets 与@distinctUnionOfArrays作用相同，只是用于NSSet对象而不是NSArray</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="访问者搜索模式"><a href="#访问者搜索模式" class="headerlink" title="访问者搜索模式"></a>访问者搜索模式</h3><p>NSObject提供的NSkeyValueCoding协议的默认实现使用明确定义的规则集将基于键的访问器调用映射到对象的基础属性。这些协议方法使用“key”在其自己的对象实例中搜索访问器、实例变量以及遵循某个命名规则的相关方法。虽然您很少修改此默认搜索，但了解它的工作方式会有所帮助，既可以跟踪键值编码对象的行为，也可以使您自己的对象兼容KVC。</p><h4 id="Getter的搜索模式"><a href="#Getter的搜索模式" class="headerlink" title="Getter的搜索模式"></a>Getter的搜索模式</h4><p><code>valueForKey:</code>的默认实现是，给定<code>key</code>参数作为输入，通过下面的过程，在接收<code>valueForKey:</code>调用的类实例中操作。</p><ol><li>按顺序搜索访问器方法<code>get&lt;Key&gt;</code>/<code>&lt;key&gt;</code>/<code>is&lt;Key&gt;</code>/<code>_&lt;key&gt;</code>。如果找到，调用该方法并且带着方法的调用结果调转到第5步执行；否则，继续下一步。</li><li>如果没有找到简单的访问方法，搜索其名称匹配某些模式的方法的实例。其中匹配模式包含<code>countOf&lt;Key&gt;</code>，<code>objectIn&lt;Key&gt;AtIndex:</code>（对应于<code>NSArray</code>定义的基本方法），和<code>&lt;key&gt;AtIndexs:</code>（对应于<code>NSArray</code>的方法<code>objectsAtIndexs:</code>）<br>一旦找到第一个和其他两个中的至少一个，则创建一个响应所以<code>NSArray</code>方法并返回该方法的集合代理对象。否则，执行第3步。<br>代理对象随后将任何<code>NSArray</code>接收到的一些组合的消息。**实际上，与符合键值编码对象一起工作的代理对象允许底层属性的行为就像它是<code>NSArray</code>一样，即便它不是。</li><li>如果没有找到简单的访问器方法或数组访问方法组，则寻找三个方法<code>countOf&lt;Key&gt;</code>/<code>enumeratorOf&lt;Key&gt;</code>/<code>memberOf&lt;Key&gt;:</code>，对应<code>NSSet</code>类的基本方法。<br>如果三个方法全找到了，则创建一个集合代理对象来响应所有的NSSet方法并返回。否则，执行第4步。</li><li>如果上面的方法都没有找到，并且接受者的类方法<code>accessInstanceVariablesDirectly</code>返回<code>YES</code>（默认YES），则按序搜索以下实例变量：<code>_&lt;key&gt;</code>/<code>_is&lt;Key&gt;</code>/<code>&lt;key&gt;</code>/<code>is&lt;Key&gt;</code>。如果找到其中之一，直接获取实例变量的值并跳转到第5步；否则执行第6步。</li><li>如果检索到的属性值是对象指针，则只返回结果；如果值是受<code>NSNumber</code>支持的标量，则将其存储在<code>NSNumber</code>实例中并返回；如果结果是<code>NSNumber</code>不支持的标量，则转换成<code>NSValue</code>对象并返回</li><li>如果以上所有的尝试都失败了，则调用<code>valueForUndefinedKey:</code>，这个方法默认抛出异常，<code>NSObject</code>的子类可以重写来自定义行为。</li></ol><h4 id="Setter的搜索模式"><a href="#Setter的搜索模式" class="headerlink" title="Setter的搜索模式"></a>Setter的搜索模式</h4><p><code>setValue:forKey:</code>的默认实现是给定<code>key</code>和<code>value</code>作为参数输入，尝试把<code>value</code>设置给以<code>key</code>命名的属性。过程如下：</p><ol><li>按序搜索<code>set&lt;Key&gt;:</code>或<code>_set&lt;Key&gt;</code>，如果找到，则使用输入参数调用并结束。</li><li>如果没有找到简单的访问器方法，并且如果类方法<code>accessInstanceVariablesDirectly</code>返回<code>YES</code>（默认为YES），则按序搜索以下实例变量: <code>_&lt;key&gt;</code>/<code>_is&lt;Key&gt;</code>/<code>&lt;key&gt;</code>/<code>is&lt;Key&gt;</code>，如果找到了则直接进行赋值并结束。</li><li>以上方法皆失败则调用<code>setValue:forUndefinedKey:</code>，这个方法默认抛出异常，<code>NSObject</code>的子类可以自定义。</li></ol><h1 id="KVO"><a href="#KVO" class="headerlink" title="KVO"></a>KVO</h1><p>Key-value observing提供了一种机制，允许对象把自身属性的更改通知给其他属性。它对应用程序中model和controller层之间的通信特别有用。通常，控制器对象观察模型对象的属性，视图对象通过控制器观察模型对象的属性。另外，一个模型对象或许会观察另一个模型对象（通常用与确认从属值何时改变）或甚至自身（再次确认从属值何时改变）。<br>你可以观察属性，包括简单属性，一对一关系和多对多关系。多对多关系的观察者被告知所作出的改变的类型——以及改变中涉及哪些对象。</p><h2 id="注册KVO"><a href="#注册KVO" class="headerlink" title="注册KVO"></a>注册KVO</h2><ul><li>使用<code>addObserver:forKeyPath:options:content:</code>方法来给observer注册一个observed object</li><li>在observer内部实现<code>observerValueForKeyPath:ofObject:change:context:</code>来接收更改的通知消息。</li><li>当不再应该接收消息时，使用<code>removeObserver:forKeyPath:</code>方法来反注册观察者。起码也要在observer被移除前调用这个方法。</li></ul><h3 id="注册Observer"><a href="#注册Observer" class="headerlink" title="注册Observer"></a>注册Observer</h3><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">addObserver:forKeyPath:options:content:</span><br></pre></td></tr></table></figure><h4 id="options"><a href="#options" class="headerlink" title="options"></a>options</h4><p>options参数指定了一个按位<code>OR</code>的常量选项，会影响通知中提供的更改字典的内容和生成通知的方式。<br>你可以选择使用<code>NSKeyValueObservingOptionOld</code>选项，在被观察的属性修改前收到旧值；也可以使用<code>NSKeyValueObservingOptionNew</code>来获取修改后的新值。通过<code>NSKeyValueObservingOptionOld | NSKeyValueObservingOptionNew</code>获取两者。<br>使用<code>NSKeyValueObservingOptionInitial</code>选项，让被观察的属性在<code>addObserver:forKeyPath:options:context</code>方法返回前发送即时通知。你可以使用此附加的一次性通知来在观察者中建立属性的初始值。<br>通过包含<code>NSKeyValueObservingOptionPrior</code>来指示被观察对象在属性更改之前发送通知（除了在更改之后发送通知）。在更改之前发送的通知中的<code>change</code>字典始终包含<code>NSKeyValueChangeNotificationIsPriorKey</code>，其值是包含布尔值YES的NSNumber对象，但不包含<code>NSKeyValueChangeNewKey</code>的内容。如果指定此选项，则更改后发送的通知中的<code>change</code>字典的内容和未指定此选项时包含的内容相同。当观察者自己的键值观察兼容性要求它为自己的一个属性调用-willChangexxx方法之一时，可以使用此选项，并且该属性的值取决于被观察对象的属性的值。</p><h4 id="context"><a href="#context" class="headerlink" title="context"></a>context</h4><p><code>addObserver:forKeyPath:options:context:</code>消息中的上下文指针包含将在相应的更改通知中传递回观察者的任意数据。您可以使用NULL来完全指定并依赖于<code>key path</code>字符串来确定更改通知的来源，但是这种方法可能会导致其超类也因不同原因观察到相同密钥路径的对象出现问题。</p><p>一个更安全且具有扩展性的方法是使用<code>content</code>来确保你收到的通知就是发给你的而不是超类的。</p><p>类中唯一命名的静态（static）变量的地址是一个很好的content。在超类或子类中以类似的方式选择的上下文不太可能重叠。您可以为整个类选择同一个上下文，并根据通知消息中的key path字符串来确定更改的内容；或者，您可以为每个观察到的密钥路径创建不同的上下文，从而完全绕过字符串比较的需要，从而实现更有效的通知解析。</p><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">- (<span class="keyword">void</span>)registerAsObserver &#123;</span><br><span class="line">    BankAccount *myAccount = [[BankAccount alloc] init];</span><br><span class="line">    [myAccount addObserver:<span class="keyword">self</span> forKeyPath:<span class="string">@&quot;currBalance&quot;</span> options:<span class="built_in">NSKeyValueObservingOptionInitial</span> | <span class="built_in">NSKeyValueObservingOptionNew</span> | <span class="built_in">NSKeyValueObservingOptionOld</span> | <span class="built_in">NSKeyValueObservingOptionPrior</span> context:PersonAccountBalanceContext];</span><br><span class="line">    myAccount.currBalance = @<span class="number">100</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>注意，<strong>键值观察<code>addObserver:forKeyPath:options:context:</code>方法不对观察者、被观察的对象、上下文保持强引用。如需要，你应该对它们保持强引用。</strong></p><h3 id="接受改变的通知"><a href="#接受改变的通知" class="headerlink" title="接受改变的通知"></a>接受改变的通知</h3><p>当对象的被观察属性值改变的时候，观察者对象会收到<code>observeValueForKeyPath:ofObject:change:context:</code>消息。所有的观察者必须实现这个方法。</p><p>观察对象提供触发通知的key path，自身作为<code>object</code>，<code>change</code>字典包含改变的细节，并且<code>context</code>指针就是观察者被注册时提供的。</p><p><code>NSKeyValueChangeKindKey</code>提供改变类型的信息。<code>NSKeyValueChangeKindKey</code>表示观察对象的值已更改。如果观察的属性是一个对多的关系，<code>NSKeyValueChangeInsertion</code>/<code>NSKeyValueChangeRemoval</code>/<code>NSKeyValueChangeReplacement</code>分别表示集合的插入、删除、替换操作。<code>NSKeyValueChangeIndexesKey</code>表示集合中已更改内容的<code>NSIndexSet</code>。</p><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">- (<span class="keyword">void</span>)observeValueForKeyPath:(<span class="built_in">NSString</span> *)keyPath ofObject:(<span class="keyword">id</span>)object change:(<span class="built_in">NSDictionary</span>&lt;<span class="built_in">NSKeyValueChangeKey</span>,<span class="keyword">id</span>&gt; *)change context:(<span class="keyword">void</span> *)context &#123;</span><br><span class="line">    <span class="keyword">if</span> (context == PersonAccountBalanceContext) &#123;</span><br><span class="line">        <span class="built_in">NSLog</span>(<span class="string">@&quot;PersonAccountBalanceContext 对应的属性改变了&quot;</span>);</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (context == PersonAccountTransactionContext) &#123;</span><br><span class="line">        <span class="keyword">if</span> ([change[<span class="built_in">NSKeyValueChangeKindKey</span>] unsignedIntValue] == <span class="built_in">NSKeyValueChangeSetting</span>) &#123;</span><br><span class="line">            <span class="built_in">NSLog</span>(<span class="string">@&quot;集合内容赋值 索引为：%@&quot;</span>, change[<span class="built_in">NSKeyValueChangeIndexesKey</span>]);</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> ([change[<span class="built_in">NSKeyValueChangeKindKey</span>] unsignedIntValue] == <span class="built_in">NSKeyValueChangeInsertion</span>) &#123;</span><br><span class="line">            <span class="built_in">NSLog</span>(<span class="string">@&quot;集合内容插入 索引为：%@&quot;</span>, change[<span class="built_in">NSKeyValueChangeIndexesKey</span>]);</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> ([change[<span class="built_in">NSKeyValueChangeKindKey</span>] unsignedIntValue] == <span class="built_in">NSKeyValueChangeRemoval</span>) &#123;</span><br><span class="line">            <span class="built_in">NSLog</span>(<span class="string">@&quot;集合内容删除 索引为：%@&quot;</span>, change[<span class="built_in">NSKeyValueChangeIndexesKey</span>]);</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> ([change[<span class="built_in">NSKeyValueChangeKindKey</span>] unsignedIntValue] == <span class="built_in">NSKeyValueChangeReplacement</span>) &#123;</span><br><span class="line">            <span class="built_in">NSLog</span>(<span class="string">@&quot;集合内容替换 索引为：%@&quot;</span>, change[<span class="built_in">NSKeyValueChangeIndexesKey</span>]);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="移除观察者对象"><a href="#移除观察者对象" class="headerlink" title="移除观察者对象"></a>移除观察者对象</h3><p>通过想观察者发送<code>removeObserver:forKeyPath:context</code>消息来移除观察者对象。收到该消息后，观察者对象将不再接收任何<code>observerValueForKeyPath:ofObject:change:context</code>中指定key path/object的消息。</p><p>删除观察者时，注意：</p><ul><li><strong>移除和添加的方法要保持对称</strong>，否则会引发异常。如果无法保持对称，则把移除的方法放到try/catch块中。</li><li>对象释放时，不会自动把自己从观察者中移除，此时被观察者继续发送通知。但是就像任何其他消息一样，改变的通知发送给了已经释放的对象会触发内存访问异常。因此，<strong>务必在观察者从内存中消失前，将其移除</strong></li><li>协议没有提供方法来查询一个对象是否是观察者或被观察者。你必须在代码中自行避免错误。典型的方案是在观察者初始化期间（init或dealloc）注册为观察者，并在释放时（dealloc）注销。</li></ul><h2 id="兼容KVO"><a href="#兼容KVO" class="headerlink" title="兼容KVO"></a>兼容KVO</h2><p>为了让特定属性符合KVO标准，class必须满足一下内容：</p><ul><li>该类必须是符合该属性的KVC</li><li>该类会为该属性触发KVO通知</li><li>相关的key已经被成功注册</li></ul><p>有两种技术可确保发出KVO通知。NSObject提供自动支持，默认情况下可用于符合键值编码的类的所有属性。通常，如果你遵守Cocoa编码和命名约定，则可以使用自动通知，而不必编写任何代码。</p><p>手动方式为通知触发时提供了更多的控制权，并且需要额外编码。你可以通过实现<code>automaticallyNotifiesObserversForKey:</code>来控制子类属性的自动通知。</p><h3 id="自动通知"><a href="#自动通知" class="headerlink" title="自动通知"></a>自动通知</h3><p>下列方法列举了会触发自动通知的一些场景：</p><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//调用访问器方法。</span></span><br><span class="line">[account setName：@“Savings”];</span><br><span class="line"> </span><br><span class="line"><span class="comment">//使用setValue：forKey：。</span></span><br><span class="line">[account setValue：@“Savings”forKey：@“name”];</span><br><span class="line"> </span><br><span class="line"><span class="comment">//使用密钥路径，其中&#x27;account&#x27;是&#x27;document&#x27;的kvc兼容属性。</span></span><br><span class="line">[document setValue：@“Savings”forKeyPath：@“account.name”];</span><br><span class="line"> </span><br><span class="line"><span class="comment">//使用mutableArrayValueForKey：检索关系代理对象。</span></span><br><span class="line">Transaction * newTransaction = &lt;＃为帐户＃&gt;创建新交易;</span><br><span class="line"><span class="built_in">NSMutableArray</span> * transactions = [account mutableArrayValueForKey：@“transactions”];</span><br><span class="line">[transactions addObject：newTransaction];</span><br></pre></td></tr></table></figure><h3 id="手动通知"><a href="#手动通知" class="headerlink" title="手动通知"></a>手动通知</h3><p>有些情况下，你可能想要控制通知的过程，例如，最大限度减少因应用程序特定原因而不必要的触发通知，或把一组通知整合到一个。</p><p>手动通知和自动通知不是互斥的。手动和自动的通知可以同时触发。如果你只想要手动触发，则需要通过重写<code>automaticallyNotifiesObserversForKey:</code>方法来禁止自动通知。</p><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">+ (<span class="built_in">BOOL</span>)automaticNotifiesObserversForKey:(<span class="built_in">NSString</span> *)theKey &#123;</span><br><span class="line">    <span class="built_in">BOOL</span> automatic = <span class="literal">NO</span>;</span><br><span class="line">    <span class="keyword">if</span> ([theKey isEqualToString：@“balance”]) &#123;</span><br><span class="line">        automatic = <span class="literal">NO</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">        automatic = [<span class="keyword">super</span> automaticNotifiesObserversForKey: theKey];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> automatic;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>**要实现手动观察者通知，你要在值改变前调用<code>willChangeValueForKey:</code>，并在值改变后调用<code>didChangeValueForKey:</code>。有三组类似的方法：</p><ul><li><code>willChangeValueForKey:</code>和<code>didChangeValueForKey:</code>。用于单个对象</li><li><code>willChange:valuesAtIndexes:forKey:</code>和<code>didChange:valuesAtIndexes:forKey:</code>。用于有序集合</li><li><code>willChangeValueForKey:withSetMutation:usingObjects:</code>和<code>willChangeValueForKey:withSetMutation:usingObjects:</code>。用于无须集合</li></ul><p>下面在访问器方法中手动触发：</p><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">- (<span class="keyword">void</span>)setBalance:(<span class="keyword">double</span>)theBalance &#123;</span><br><span class="line">    [<span class="keyword">self</span> willChangeValueForKey:<span class="string">@&quot;balance&quot;</span>];</span><br><span class="line">    _balance = theBalance;</span><br><span class="line">    [<span class="keyword">self</span> didChangeValueForKey:<span class="string">@&quot;balance&quot;</span>];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>为了减少不必要的通知，可以先检查值是否改变了，然后决定是否发通知：</p><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">- (<span class="keyword">void</span>)setBalance:(<span class="keyword">double</span>)theBalance &#123;</span><br><span class="line">    <span class="keyword">if</span> (theBalance != _balance) &#123;</span><br><span class="line">        [<span class="keyword">self</span> willChangeValueForKey:<span class="string">@&quot;balance&quot;</span>];</span><br><span class="line">        _balance = theBalance;</span><br><span class="line">        [<span class="keyword">self</span> didChangeValueForKey:<span class="string">@&quot;balance&quot;</span>];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如果一个操作导致多个key发生改变，必须嵌套发送通知：</p><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">- (<span class="keyword">void</span>)setBalance:(<span class="keyword">double</span>)theBalance &#123;</span><br><span class="line">    [<span class="keyword">self</span> willChangeValueForKey:<span class="string">@&quot;balance&quot;</span>];</span><br><span class="line">    [<span class="keyword">self</span> willChangeValueForKey:<span class="string">@&quot;itemChanged&quot;</span>];</span><br><span class="line">    _balance = theBalance;</span><br><span class="line">    _itemChanged = _itemChanged+<span class="number">1</span>;</span><br><span class="line">    [<span class="keyword">self</span> didChangeValueForKey:<span class="string">@&quot;itemChanged&quot;</span>];</span><br><span class="line">    [<span class="keyword">self</span> didChangeValueForKey:<span class="string">@&quot;balance&quot;</span>];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在有序的to-many关系中，除了指定更改的key，还不许指定更改的类型和所涉及对象的索引。</p><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">- (<span class="keyword">void</span>)removeTransactionsAtIndexes:(<span class="built_in">NSIndexSet</span> *)indexes &#123;</span><br><span class="line">    [<span class="keyword">self</span> willChange:<span class="built_in">NSKeyValueChangeRemoval</span></span><br><span class="line">        valuesAtIndexes:indexes forKey:<span class="string">@&quot;transactions&quot;</span>];</span><br><span class="line"> </span><br><span class="line">    <span class="comment">// Remove the transaction objects at the specified indexes.</span></span><br><span class="line"> </span><br><span class="line">    [<span class="keyword">self</span> didChange:<span class="built_in">NSKeyValueChangeRemoval</span></span><br><span class="line">        valuesAtIndexes:indexes forKey:<span class="string">@&quot;transactions&quot;</span>];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="注册从属keys"><a href="#注册从属keys" class="headerlink" title="注册从属keys"></a>注册从属keys</h2><p>在许多情况下，一个属性的值取决于另一个对象中的一个或多个其他属性的值。如果一个属性的值发生更改，则还应标记派生属性的值以进行更改。</p><h3 id="To-One-关系"><a href="#To-One-关系" class="headerlink" title="To-One 关系"></a>To-One 关系</h3><p>要为一对一关系自动触发通知，应该重写<code>keyPathsForValuesAffectingValueForKey</code>或实现一个合适的方法，该方法遵循它为注册依赖键定义的模式。</p><p>例如，<code>fullName</code>取决于<code>firstName</code>和<code>lastName</code>。返回<code>fullName</code>的方法可以写成如下：</p><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">- （<span class="built_in">NSString</span> *）fullName &#123;</span><br><span class="line">    <span class="keyword">return</span> [<span class="built_in">NSString</span> stringWithFormat：@“％@％@”，firstName，lastName];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>当<code>firstName</code>或<code>lastName</code>发生改变时，必须通知观察<code>fullName</code>属性的程序，因为它们影响这个属性的值。</p><p>一个解决方案是重写<code>keyPathsForValuesAffectingValueForKey</code>来指定<code>fullName</code>属性依赖于<code>lastName</code>和<code>firstName</code>。</p><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">+ (<span class="built_in">NSSet</span> *)keyPathsForValuesAffectingValueForKey:(<span class="built_in">NSString</span> *)key &#123;</span><br><span class="line"> </span><br><span class="line">    <span class="built_in">NSSet</span> *keyPaths = [<span class="keyword">super</span> keyPathsForValuesAffectingValueForKey:key];</span><br><span class="line"> </span><br><span class="line">    <span class="keyword">if</span> ([key isEqualToString:<span class="string">@&quot;fullName&quot;</span>]) &#123;</span><br><span class="line">        <span class="built_in">NSArray</span> *affectingKeys = @[<span class="string">@&quot;lastName&quot;</span>, <span class="string">@&quot;firstName&quot;</span>];</span><br><span class="line">        keyPaths = [keyPaths setByAddingObjectsFromArray:affectingKeys];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> keyPaths;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>重写通常应该调用super并返回一个集合，以免影响超类中对此方法的重写。</p><p>通过重写<code>keyPathsForValuesAffecting&lt;Key&gt;</code>也可以达到相同的效果。</p><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">+ (<span class="built_in">NSSet</span> *)keyPathsForValuesAffectingFullName &#123;</span><br><span class="line">    <span class="keyword">return</span> [<span class="built_in">NSSet</span> setWithObjects:<span class="string">@&quot;lastName&quot;</span>, <span class="string">@&quot;firstName&quot;</span>, <span class="literal">nil</span>];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="To-many-关系"><a href="#To-many-关系" class="headerlink" title="To-many 关系"></a>To-many 关系</h3><p><code>keyPathsForValuesAffectingValueForKey:</code>方法不支持to-many关系的key paths。可以使用下面两种方案来处理to-many 关系：</p><ol><li>使用key-value observing注册父项作为子项的相关属性观察者。当子对象添加到关系或从关系中删除的时候，你必须添加或删除父对象。在<code>observeValueForKeyPath:ofObject:change:context:</code>方法中，你可以更新依赖值以相应更改，如下：<figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">[<span class="keyword">self</span> addObserver:<span class="keyword">self</span> forKeyPath:<span class="string">@&quot;transactions&quot;</span> options:<span class="built_in">NSKeyValueObservingOptionNew</span> context:<span class="literal">NULL</span>];</span><br><span class="line"></span><br><span class="line">- (<span class="keyword">void</span>)observeValueForKeyPath:(<span class="built_in">NSString</span> *)keyPath ofObject:(<span class="keyword">id</span>)object change:(<span class="built_in">NSDictionary</span>&lt;<span class="built_in">NSKeyValueChangeKey</span>,<span class="keyword">id</span>&gt; *)change context:(<span class="keyword">void</span> *)context &#123;</span><br><span class="line">    <span class="built_in">NSLog</span>(<span class="string">@&quot;amount = %@&quot;</span>, [<span class="keyword">self</span> valueForKeyPath:<span class="string">@&quot;transactions.@sum.amount&quot;</span>]);</span><br><span class="line">    [<span class="keyword">self</span> setTotalConsumption:[<span class="keyword">self</span> valueForKeyPath:<span class="string">@&quot;transactions.@sum.amount&quot;</span>]];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li>在Core Data中，则可以将父项作为其托管对象上下文的观察者注册到应用程序的通知中心。父项应以类似于键值观察的方式回应孩子们发布的相关变更通知。</li></ol><h2 id="Key-Value-Observing-的实现细节"><a href="#Key-Value-Observing-的实现细节" class="headerlink" title="Key-Value Observing 的实现细节"></a>Key-Value Observing 的实现细节</h2><p>自动key-value observing 是使用一种叫做<em>isa-swizzling</em>的技术实现的。</p><p><em>isa</em>指针指向维护一个调度表（dispatch table）的对象的类。该调度表包含了指向该类实现的方法的指针，以及其他数据。</p><p>当观察者注册对象的属性时，观察对象的isa指针被修改，指向中间类而不是真正的类。因此，isa指针的值不一定反映实例的实际类。</p><p>永远不要依赖isa指针来确定类成员。而应该使用<code>class</code>方法来决定实例所属的类。</p><h1 id="参考连接"><a href="#参考连接" class="headerlink" title="参考连接"></a>参考连接</h1><p><a href="https://github.com/shizhiang/KVC_KVO-Tutorial">示例代码</a></p><p><a href="https://developer.apple.com/library/archive/documentation/Cocoa/Conceptual/KeyValueCoding/index.html#//apple_ref/doc/uid/10000107-SW1">KVC</a></p><p><a href="https://developer.apple.com/library/archive/documentation/Cocoa/Conceptual/KeyValueObserving/KeyValueObserving.html#//apple_ref/doc/uid/10000177-BCICJDHA">KVO</a></p>]]></content>
      
      
      
        <tags>
            
            <tag> iOS </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>iOS内存管理</title>
      <link href="iOS-Memory-Management/"/>
      <url>iOS-Memory-Management/</url>
      
        <content type="html"><![CDATA[<p>本文内容是对<a href="https://developer.apple.com/library/archive/documentation/Cocoa/Conceptual/MemoryMgmt/Articles/MemoryMgmt.html#//apple_ref/doc/uid/10000011-SW1">Advanced Memory Management Programming Guide</a>中重点内容的总结</p><a id="more"></a><h2 id="内存管理策略"><a href="#内存管理策略" class="headerlink" title="内存管理策略"></a>内存管理策略</h2><h3 id="基本内存管理规则"><a href="#基本内存管理规则" class="headerlink" title="基本内存管理规则"></a>基本内存管理规则</h3><p>内存管理模型基于对象所有权的。任何对象可能有一个或多个所有者。对象只要有超过一个所有者就会继续存在；如果一个对象没有所有者了，运行时系统就会把它销毁。为了让开发者清楚自己什么时候拥有/不拥有对象，Cocoa设置了一些规则：</p><ul><li>你拥有你创建的对象 - You own any object you create<blockquote><p>使用以”alloc”, “new”, “copy”, “mutableCopy”开头的方法创建对象</p></blockquote></li><li>你可以使用retain来获取对象的所有权<blockquote><p>可以在两种情况下使用<code>retain</code>：（1）在存储器方法的实现或者<code>init</code>方法中，获取要作为属性值存储的对象的所有权；（2）避免某些操作的副作用造成对象不可用</p></blockquote></li><li>当你不再需要的时候，一定要放弃对象所有权<blockquote><p>给对象发送<code>release</code>/<code>autorelease</code>消息来放弃所有权。因此，在Cocoa术语中，把放弃所有权称为”releasing”一个对象</p></blockquote></li><li>一定不能放弃你没有所有权的对象</li></ul><h2 id="内存管理实战"><a href="#内存管理实战" class="headerlink" title="内存管理实战"></a>内存管理实战</h2><h3 id="使用存储器方法来使内存管理更容易"><a href="#使用存储器方法来使内存管理更容易" class="headerlink" title="使用存储器方法来使内存管理更容易"></a>使用存储器方法来使内存管理更容易</h3><p>如果你的类有一个对象属性，你必须确保被设置的对象在使用过程中不会被释放。因此在它被设置的时候，你必须声明对它的所有权。并且你必须确保之后放弃对当前持有值的所有权。虽然这样做有时候是冗长乏味的，但是如果你坚持这种方法，就可以显著减少内存管理问题。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">@interface Counter : NSObject</span><br><span class="line">@property (nonatomic, retain) NSNumber *count;</span><br><span class="line">@end;</span><br></pre></td></tr></table></figure><blockquote><p>这个<code>property</code>声明了一对存取器方法。通常，我们应当让编译器合成这些方法；但是，看一下它们是怎么实现的会很有意义。</p></blockquote><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">- (<span class="built_in">NSNumber</span> *)count &#123;</span><br><span class="line">    <span class="keyword">return</span> _count;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>“get”存取器只是返回了合成的实例变量并不需要<code>retain</code>或者<code>release</code></p></blockquote><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">- (<span class="keyword">void</span>)setCount:(<span class="built_in">NSNumber</span> *)newCount &#123;</span><br><span class="line">    [newCount <span class="keyword">retain</span>];</span><br><span class="line">    [_count release];</span><br><span class="line">    <span class="comment">// Make the new assignment.</span></span><br><span class="line">    _count = newCount;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>“set”存取器需要先<code>retain</code>新值，之后<code>release</code>旧值，最后进行赋值操作。为了避免前后是同一个对象的情况下出现意外的问题，必须要在<code>realse</code>之前调用<code>retain</code>。</p></blockquote><h3 id="不要在初始化和dealloc方法中使用存取器方法"><a href="#不要在初始化和dealloc方法中使用存取器方法" class="headerlink" title="不要在初始化和dealloc方法中使用存取器方法"></a>不要在初始化和dealloc方法中使用存取器方法</h3><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">- init &#123;</span><br><span class="line">    <span class="keyword">self</span> = [<span class="keyword">super</span> init];</span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">self</span>) &#123;</span><br><span class="line">        _count = [[<span class="built_in">NSNumber</span> alloc] initWithInteger:<span class="number">0</span>];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">self</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- initWithCount:(<span class="built_in">NSNumber</span> *)startingCount &#123;</span><br><span class="line">    <span class="keyword">self</span> = [<span class="keyword">super</span> init];</span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">self</span>) &#123;</span><br><span class="line">        _count = [startingCount <span class="keyword">copy</span>];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">self</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (<span class="keyword">void</span>)dealloc &#123;</span><br><span class="line">    [_count release];</span><br><span class="line">    [<span class="keyword">super</span> dealloc];</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="使用弱引用来避免循环引用"><a href="#使用弱引用来避免循环引用" class="headerlink" title="使用弱引用来避免循环引用"></a>使用弱引用来避免循环引用</h3><p>只有当对象的所有强引用都释放后对象才能被释放，如果两个对象互相强引用了彼此，那么它们都不会被释放，这样就造成了<strong>循环引用</strong><br><img src="https://developer.apple.com/library/archive/documentation/Cocoa/Conceptual/MemoryMgmt/Art/retaincycles_2x.png" alt="循环引用"><br>弱引用可以解决循环引用的问题。弱引用是<em>non-owning</em>的关系。为了保持对象至少有一个引用而不被释放，不能把所有引用都设置成弱引用。因此，Cocoa建立了一个惯例，“parent”对象对“children”对象持有强引用，而children对象弱引用parent对象。如上图表示的一样。</p><p>当向弱引用的对象发送消息时一定要消息。如果向已经释放的兑现发送消息时会引起崩溃。这里特别注意的是：通知中心。当向NotificationCenter注册观察者时，通知中心会持有观察者的弱引用，如果观察者释放时没有主动从通知中心移除自己，通知中心会在之后向被释放掉的观察者发送消息，这时候会引起崩溃。（文档中还提到了delegate，但是在ARC下我们使用weak来修饰，就不会引起问题了。）</p><h3 id="避免正在使用的对象被释放"><a href="#避免正在使用的对象被释放" class="headerlink" title="避免正在使用的对象被释放"></a>避免正在使用的对象被释放</h3><p>下面两种情况是需要特别注意的：</p><ol><li><p>当一个对象从集合中移除的时候：</p><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">heisenObject = [array objectAtIndex:n];</span><br><span class="line">[array removeObjectAtIndex:n];</span><br><span class="line"><span class="comment">// heisenObject could now be invalid.</span></span><br></pre></td></tr></table></figure><blockquote><p>对象从集合中移除的时候，会收到<code>release</code>消息（而不是<code>autorelease</code>）。如果集合是对象的唯一持有者，这个对象会被立即释放。</p></blockquote></li><li><p>“parent object”释放</p><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">id</span> parent = &lt;<span class="meta">#create a parent object#&gt;;</span></span><br><span class="line"><span class="comment">// ...</span></span><br><span class="line">heisenObject = [parent child] ;</span><br><span class="line">[parent release]; <span class="comment">// Or, for example: self.parent = nil;</span></span><br><span class="line"><span class="comment">// heisenObject could now be invalid.</span></span><br></pre></td></tr></table></figure><blockquote><p>一个对象是由另一个对象生成的，之后直接或者间接的释放了父对象。如果这个释放导致了父对象的销毁，并且父对象是子对象的唯一持有者，那么子对象也会同时被销毁。</p></blockquote></li></ol><p>要想避免这些情况，我们可以<code>retain heisenObject</code>。比如：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">heisenObject &#x3D; [[array objectAtIndex:n] retain];</span><br><span class="line">[array removeObjectAtIndex:n];</span><br><span class="line">&#x2F;&#x2F; Use heisenObject...</span><br><span class="line">[heisenObject release];</span><br></pre></td></tr></table></figure><h3 id="不要使用dealloc管理稀缺资源"><a href="#不要使用dealloc管理稀缺资源" class="headerlink" title="不要使用dealloc管理稀缺资源"></a>不要使用dealloc管理稀缺资源</h3><p>不要在<code>dealloc</code>方法中管理文件描述符、网络连接、缓存或者缓冲区等稀有资源。特别是，类中的<code>dealloc</code>方法不是你认为会调用的时候就会调用。<code>dealloc</code>的调用可能会由于bug或者应用“tear-down”造成延迟或者不调用。</p><p>相反地，如果你有一个类的实例来管理稀缺资源，你应该把你的应用设计成当资源不在需要的时候调用“clean up”方法来清理资源，之后释放实例，<code>dealloc</code>会紧接着调用，这样的话，即使<code>dealloc</code>没有调用也不会引起其他问题。</p><p>如果在<code>dealloc</code>中管理稀缺资源可能会引起几个问题：</p><ol><li>对象图拆卸的顺序依赖性<br> 对象图的拆卸链是没有固定顺序的。</li><li>不回收稀缺资源<br> 内存泄露是应该被解决的bug，但是他们不会立即致命。如果稀缺资源没有按照预先设计的正常释放，可能会引起更严重的问题。比如，如果应用程序的文件描述符耗尽了，用户可能将无法保存数据。</li><li>在错误的线程上执行清理逻辑<br> 如果一个对象在意外时间自动释放，它将在它碰巧所在的任何线程的自动释放池块中被释放。对于只能从一个线程触及的资源，这中情况是非常严重的问题。</li></ol><h3 id="集合拥有它们包含的对象"><a href="#集合拥有它们包含的对象" class="headerlink" title="集合拥有它们包含的对象"></a>集合拥有它们包含的对象</h3><p>当把一个对象放到集合中（例如array，dictionary，set），集合会持有这个对象。当对象从集合中移除或者集合本身被释放的时候，集合会放弃所有权。因此，如果你想要创建一个“numbers”的数组时，可以这样做：</p><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">NSMutableArray</span> *array = &lt;#Get a <span class="keyword">mutable</span> array#&gt;;</span><br><span class="line"><span class="built_in">NSUInteger</span> i;</span><br><span class="line"><span class="comment">// ...</span></span><br><span class="line"><span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++) &#123;</span><br><span class="line">    <span class="built_in">NSNumber</span> *convenienceNumber = [<span class="built_in">NSNumber</span> numberWithInteger:i];</span><br><span class="line">    [array addObject:convenienceNumber];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这样做，你没有调用<code>alloc</code>，因此不需要调用<code>release</code>。这里也不需要“retain”这些新的numbers，因为数组会这样做。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">NSMutableArray *array &#x3D; &lt;#Get a mutable array#&gt;;</span><br><span class="line">NSUInteger i;</span><br><span class="line">&#x2F;&#x2F; ...</span><br><span class="line">for (i &#x3D; 0; i &lt; 10; i++) &#123;</span><br><span class="line">    NSNumber *allocedNumber &#x3D; [[NSNumber alloc] initWithInteger:i];</span><br><span class="line">    [array addObject:allocedNumber];</span><br><span class="line">    [allocedNumber release];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这种方式需要在<code>for</code>循环内<code>[allocedNumber release]</code>来匹配<code>alloc</code>，否则的话<code>allocedNumber</code>对象的引用计数就无法匹配了。</p><h3 id="所有权策略是使用引用计数来实现的"><a href="#所有权策略是使用引用计数来实现的" class="headerlink" title="所有权策略是使用引用计数来实现的"></a>所有权策略是使用引用计数来实现的</h3><ul><li>创建对象的时候，引用计数为1</li><li>向对象发送<code>retain</code>消息时，引用计数+1</li><li>向对象发送<code>release</code>消息时，引用计数-1。向对象发送<code>autorelease</code>消息时，对象的引用计数会在autorelease pool block的结尾处-1</li><li>引用计数减到0时，对象被销毁</li></ul><blockquote><p>不要使用<code>retainCount</code>来确定对象的引用计数，它是不准确的。应该使用引用计数规则结合代码来判断对象的引用计数。</p></blockquote><h2 id="使用Autorelease-Pool-Blocks"><a href="#使用Autorelease-Pool-Blocks" class="headerlink" title="使用Autorelease Pool Blocks"></a>使用Autorelease Pool Blocks</h2><p>自动释放池提供了一个可以用来<strong>废弃所有权而且又可以避免对象被立即销毁</strong>的机制。通常情况下，我们不需要创建自动释放吃，但是有些情况下必须使用或者如果使用了会提供一些益处。</p><h3 id="关于自动释放池"><a href="#关于自动释放池" class="headerlink" title="关于自动释放池"></a>关于自动释放池</h3><p>自动释放池是使用<code>@autoreleasepool</code>标记的</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">@autoreleasepool &#123;</span><br><span class="line">    &#x2F;&#x2F; Code that creates autorelease objects.</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在自动释放池的结尾，所有收到<code>autorelease</code>消息的对象会被发送<code>release</code>消息。</p><p>和其他的block类似，自动释放池也能够嵌套</p><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">@autoreleasepool</span> &#123;</span><br><span class="line">    <span class="comment">// . . .</span></span><br><span class="line">    <span class="keyword">@autoreleasepool</span> &#123;</span><br><span class="line">        <span class="comment">// . . .</span></span><br><span class="line">    &#125;</span><br><span class="line">    . . .</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>嵌套的自动释放池遵循就近原则。</p><p>Cocoa总是认为所有的代码会在自动释放池的范围内执行，否则的话自动释放的对象就无法被释放了，这样会导致内存泄露。如果有这种情况，Cocoa会打印出适当的错误信息。AppKit和UIKit框架中的事件循环迭代（例如鼠标点击或者用户触摸）都是在自动释放池内的。因此通常情况下，你不需要创建自动释放池。但是，下面的三种情况下，需要自己创建自动释放池：</p><ul><li>编写非UI framework程序时，例如命令行工具</li><li>在需要创建很多临时对象的循环中。在循环中使用自动释放池可以减少内存峰值</li><li>创建第二线程</li></ul><h3 id="使用自动释放池来降低内存峰值"><a href="#使用自动释放池来降低内存峰值" class="headerlink" title="使用自动释放池来降低内存峰值"></a>使用自动释放池来降低内存峰值</h3><p>有些代码需要创建一些自动释放的临时对象。这些对象直到自动释放池结尾处一直都在内存中。有时候这样做不会造成过多的内存提高；有时候这些对象过大就会造成过多的内存提升，而不得不尽快的释放这些临时对象。对于后一种情况，我们可以创建自己的自动释放池，在自动释放池的结尾这些占用内存的对象都会被销毁来节省内存。</p><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">NSArray</span> *urls = &lt;# An array of file URLs #&gt;;</span><br><span class="line"><span class="keyword">for</span> (<span class="built_in">NSURL</span> *url <span class="keyword">in</span> urls) &#123;</span><br><span class="line"> </span><br><span class="line">    <span class="keyword">@autoreleasepool</span> &#123;</span><br><span class="line">        <span class="built_in">NSError</span> *error;</span><br><span class="line">        <span class="built_in">NSString</span> *fileContents = [<span class="built_in">NSString</span> stringWithContentsOfURL:url</span><br><span class="line">                                         encoding:<span class="built_in">NSUTF8StringEncoding</span> error:&amp;error];</span><br><span class="line">        <span class="comment">/* Process the string, creating and autoreleasing more objects. */</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>for</code>循环每次都处理一个文件。在自动释放池中<code>fileContents</code>对象是“autoreleased”，当到达自动释放池的结尾会自动释放。每次都会自动回收内存，就避免了内存占用过多的问题。</p><p>切记，自动释放的对象只要超出最近的自动释放池范围后就会被释放。也就是说，自动释放的对象被释放后就无法继续使用了，不要向这些对象发送消息，也不要把它们作为返回值。例如下面的这种情况：</p><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">– (<span class="keyword">id</span>)findMatchingObject:(<span class="keyword">id</span>)anObject &#123;</span><br><span class="line"> </span><br><span class="line">    <span class="keyword">id</span> match;</span><br><span class="line">    <span class="keyword">while</span> (match == <span class="literal">nil</span>) &#123;</span><br><span class="line">        <span class="keyword">@autoreleasepool</span> &#123;</span><br><span class="line"> </span><br><span class="line">            <span class="comment">/* Do a search that creates a lot of temporary objects. */</span></span><br><span class="line">            match = [<span class="keyword">self</span> expensiveSearchForObject:anObject];</span><br><span class="line"> </span><br><span class="line">            <span class="keyword">if</span> (match != <span class="literal">nil</span>) &#123;</span><br><span class="line">                [match <span class="keyword">retain</span>]; <span class="comment">/* Keep match around. */</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    <span class="keyword">return</span> [match autorelease];   <span class="comment">/* Let match go and return it. */</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>向自动释放池内的<code>match</code>对象发送<code>retain</code>消息来延长它的生命期，这样我们就可以把自动释放池内的对象作为返回值了，同时使用<code>autorelease</code>标记返回值是为了匹配<code>retain</code>的引用计数。</p><h3 id="自动释放池和线程"><a href="#自动释放池和线程" class="headerlink" title="自动释放池和线程"></a>自动释放池和线程</h3><p>每一个Cocoa的应用程序都有自己的自动释放池栈。如果你正在编写只包含Foundation框架的程序，或者自己创建了一个线程，你需要自己创建自动释放池。</p><p>如果应用或线程是长久保存的并且潜在的生成了很多自动释放的对象，这时应该定期的清空并且创建自动释放池（就像 Application Kit 在主线程中做的那样）；否则，对象的积累会增加内存的占用。如果，独立的线程并没有使用 Cocoa 的调用，你没有必要去创建一个自动释放池。</p><blockquote><p>如果使用了 POSIX 线程 APIS 而不是 NSThread 对象来创建线程，你不能使用 Cocoa，包括 NSautoreleasePool，除非 Cocoa 是在多线程模式下，Cocoa 进入了多线程模式只有在首次创建 NSThread 对象的时候，为了在第二个 POSIX 线程中使用 Cocoa ，你的应用必须首先至少创建了一个独立的 NSThread 对象，这个对象可以立即退出。你可以通过 NSThread 类方法 isMultiTheraded 来测试 Cocoa 是否在多线程模式下。</p></blockquote>]]></content>
      
      
      
        <tags>
            
            <tag> iOS </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Objective-C 消息转发</title>
      <link href="Objective-C-Message-Forward/"/>
      <url>Objective-C-Message-Forward/</url>
      
        <content type="html"><![CDATA[<p>消息转发是Objc的核心概念，不论是工作过程中还是出去面试都不能避免要接触到这个概念，利用消息转发可以实现一些非常灵巧的功能。这篇文章由浅入深的讲解了消息转发的概念和实际应用的场景。</p><a id="more"></a><h4 id="一些概念"><a href="#一些概念" class="headerlink" title="一些概念"></a>一些概念</h4><p><strong>静态绑定</strong>：在编译期就能决定运行时所应调用的函数。代表语言：C、C++等<br><strong>动态绑定</strong>：所要调用的函数直到运行期才能确定。代表语言：OC、swift等<br><strong>消息传递</strong>：对象正常解读消息，传递过去<br><strong>消息转发</strong>：对象无法解读消息，之后进行消息转发</p><h4 id="消息处理流程"><a href="#消息处理流程" class="headerlink" title="消息处理流程"></a>消息处理流程</h4><ol><li>OC中调用方法<code>[a method]</code>后都是在执行<code>id objc_msgSend(id receiver, SEL op, ...) </code><blockquote><p><code>id objc_msgSend(id self, SEL op, ...) </code>是一个参数个数可变的函数，第一参数代表接受者，第二个参数代表选择子（OC函数名），之后的参数就是消息中传入的参数。</p></blockquote></li><li>当消息发送给对象时，消息函数跟随对象的isa指针找到类结构，并尝试在cache中搜索类中是否有对应的<code>SEL</code>，如果找到在cache中找到了则直接调用，这种情况下消息发送的耗时和函数调用相差无几</li><li>若cache中搜索失败，则到该类对应的<code>dispatch table</code>中搜寻方法，如果能找到这个跟选择子名称相同的方法，就跳转到其实现代码，往下执行。</li><li>该类的<code>dispatch table</code>中没有找到则继续沿着类层级向上寻找直到NSObject，找到后则进行方法调用并缓存。</li><li>如果最终还是找不到，那就进入消息转发的流程去进行处理。</li></ol><h4 id="消息转发流程"><a href="#消息转发流程" class="headerlink" title="消息转发流程"></a>消息转发流程</h4><p><img src="https://upload-images.jianshu.io/upload_images/424855-83a396fca4f6c206.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="msg_forward.png"></p><ol><li>调用resolveInstanceMethod：征询接受者（所属的类）是否可以添加方法以处理未知的选择子？(此过程称为动态方法解析）若有，转发结束。若没有，走第二步。</li><li>调用forwardingTargetForSelector：询问接受者是否有其他对象能处理此消息。若有，转发结束，一切如常。若没有，走第三步。</li><li>调用forwardInvocation：运行期系统将消息封装到NSInvocation对象中，再给接受者一次机会。</li><li>以上三步还不行，就抛出异常：unrecognized selector sent to instance xxxx</li></ol><h4 id="消息转发实例"><a href="#消息转发实例" class="headerlink" title="消息转发实例"></a>消息转发实例</h4><ol><li><p>在ViewController的头文件中声明一个方法，但是不要在ViewController.m中实现</p> <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">ViewController.h</span><br><span class="line"></span><br><span class="line">#import &lt;UIKit&#x2F;UIKit.h&gt;</span><br><span class="line"></span><br><span class="line">@interface ViewController : UIViewController</span><br><span class="line"></span><br><span class="line">- (void)testForwardMethod;</span><br><span class="line"></span><br><span class="line">@end</span><br></pre></td></tr></table></figure></li><li><p>在AppDelegate中调用ViewController的<code>testForwardMethod </code>方法</p> <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">AppDelegate.m</span><br><span class="line"></span><br><span class="line">[[[ViewController alloc] init] testForwardMethod];</span><br></pre></td></tr></table></figure></li><li><p>这时候编译没有问题，但是运行会出现<code>-[ViewController testForwardMethod]: unrecognized selector sent to instance 0x10581bfe0</code></p></li><li><p>在ViewController.m中增加消息转发的方法</p> <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">ViewController.m</span><br><span class="line"></span><br><span class="line">- (id)forwardingTargetForSelector:(SEL)aSelector</span><br><span class="line">&#123;</span><br><span class="line">    NSLog(@&quot;ViewController forwardingTargetForSelector&quot;);</span><br><span class="line">    return [[TestView alloc] init];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 如果有方法的实现，所有消息转发的过程都不会进行</span><br><span class="line">&#x2F;&#x2F;- (void)testForwardMethod</span><br><span class="line">&#x2F;&#x2F;&#123;</span><br><span class="line">&#x2F;&#x2F;    NSLog(@&quot;ViewController testForwardMethod&quot;);</span><br><span class="line">&#x2F;&#x2F;&#125;</span><br><span class="line"></span><br><span class="line">TestView.m</span><br><span class="line"></span><br><span class="line">- (void)testForwardMethod</span><br><span class="line">&#123;</span><br><span class="line">    NSLog(@&quot;TestView testForwardMethod&quot;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><ul><li>(id)forwardingTargetForSelector:(SEL)aSelector; 把aSelector转发给其他类对象。</li></ul></blockquote></li><li><p>在ViewController.m中增加两个消息转发的方法</p> <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">ViewController.m</span><br><span class="line">  </span><br><span class="line">- (NSMethodSignature *)methodSignatureForSelector:(SEL)aSelector</span><br><span class="line">&#123;</span><br><span class="line">    NSLog(@&quot;ViewController methodSignatureForSelector&quot;);</span><br><span class="line">    if (aSelector &#x3D;&#x3D; @selector(testForwardMethod))</span><br><span class="line">    &#123;</span><br><span class="line">        NSLog(@&quot;ViewController methodSignatureForSelector equal&quot;);</span><br><span class="line">        return [NSMethodSignature signatureWithObjCTypes:&quot;v@:&quot;];</span><br><span class="line">    &#125;</span><br><span class="line">    return [super methodSignatureForSelector:aSelector];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">-  (void)forwardInvocation:(NSInvocation *)anInvocation</span><br><span class="line">&#123;</span><br><span class="line">    NSLog(@&quot;ViewController forwardInvocation:&quot;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><ol><li><code>- (NSMethodSignature *)methodSignatureForSelector:(SEL)aSelector</code>返回一NSMethodSignature对象，该对象包含给定选择器标识的方法的描述。在方法转发过程中如果需要使<code>NSInvocation </code>则就需要使用这个方法</li></ol></blockquote></li><li><p><code>signatureWithObjCTypes:</code>是用C字符串来创建<code>NSMethodSignature</code>对象，详细的描述以看<a href="https://blog.csdn.net/bigtiger1648/article/details/51084957">这篇文章</a></p></li></ol><h4 id="避开动态绑定"><a href="#避开动态绑定" class="headerlink" title="避开动态绑定"></a>避开动态绑定</h4><p>要想不使用OC的动态绑定，唯一的方案是获取到方法地址直接调用。 **这种方案仅适用于 对一个方法重复多次调用，并且对性能敏感 的情况 **</p><ol><li>通过<code>NSObject</code>的<code>methodForSelector</code>获取到方法实现的地址</li><li>使用指针直接调用方法<br>下面是以<code>setFilled:</code>方法为例 <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">void (*setter)(id, SEL, BOOL);</span><br><span class="line">int i;</span><br><span class="line"></span><br><span class="line">setter &#x3D; (void (*)(id, SEL, BOOL))[target</span><br><span class="line">    methodForSelector:@selector(setFilled:)];</span><br><span class="line">for ( i &#x3D; 0 ; i &lt; 1000 ; i++ )</span><br><span class="line">    setter(targetList[i], @selector(setFilled:), YES);</span><br></pre></td></tr></table></figure><blockquote><p><code>methodForSelector</code>不是Objective-C的特性，而是由Cocoa runtime system提供</p></blockquote></li></ol>]]></content>
      
      
      
        <tags>
            
            <tag> iOS </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>WebSocket简介和SocketRocket源码分析</title>
      <link href="WebSocket-And-SocketRocket-Source-Analysis/"/>
      <url>WebSocket-And-SocketRocket-Source-Analysis/</url>
      
        <content type="html"><![CDATA[<p>iOS开发使用FB开源的项目实现Socket长链接。</p><a id="more"></a><p><a href="http://www.iosprogrammer.tech/iOS-SocketRocket/">之前的文章</a>讲了SocketRocket的用法，这里讲一下什么是WebSocket并且对SocketRocket的源码进行分析。</p><h3 id="WebSocket"><a href="#WebSocket" class="headerlink" title="WebSocket"></a>WebSocket</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">The WebSocket Protocol is an independent TCP-based protocol.&lt;br&gt;Its only relationship to HTTP is that its handshake is interpreted by HTTP servers as an Upgrade request.</span><br></pre></td></tr></table></figure><div align=center><img src="http://image.iosprogrammer.hongbility.com/WebSocket-SocketRocket-Source/6651f2f811ec133b0e6d7e6d0e194b4c_hd.jpg"></div><p>WebSocket的特点:<br>    1. 建立在 TCP 协议之上，服务器端的实现比较容易。<br>    2. 与 HTTP 协议有着良好的兼容性。默认端口也是80和443，并且握手阶段采用 HTTP 协议，因此握手时不容易屏蔽，能通过各种 HTTP 代理服务器。<br>    3. 数据格式比较轻量，性能开销小，通信高效。<br>    4. 可以发送文本，也可以发送二进制数据。<br>    5. 没有同源限制，客户端可以与任意服务器通信。<br>    6. 协议标识符是ws（如果加密，则为wss），服务器网址就是URL。<code>ws://example.com:80/some/path</code><br>    7. 全双工通信。</p><p>WebSocket握手类似于HTTP：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">GET &#x2F;chat HTTP&#x2F;1.1</span><br><span class="line">Host: server.example.com</span><br><span class="line">Upgrade: websocket</span><br><span class="line">Connection: Upgrade</span><br><span class="line">Sec-WebSocket-Key: x3JJHMbDL1EzLkh9GBhXDw&#x3D;&#x3D;</span><br><span class="line">Sec-WebSocket-Protocol: chat, superchat</span><br><span class="line">Sec-WebSocket-Version: 13</span><br><span class="line">Origin: http:&#x2F;&#x2F;example.com</span><br></pre></td></tr></table></figure><blockquote><p>Upgrade和Connection是在通知Apache或者Nginx等代理服务器，正在进行的是websocket协议连接而不是普通的HTTP。<br><br>Sec-WebSocket-Key是浏览器随机生成的base64编码值，用来验证服务器是不是真正的websocket。<br> Sec_WebSocket-Protocol 是一个用户定义的字符串，用来区分同URL下，不同的服务所需要的协议。<br> Sec-WebSocket-Version 是告诉服务器所使用的协议版本。</p></blockquote><p>服务器验证通过后会返回：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">HTTP&#x2F;1.1 101 Switching Protocols</span><br><span class="line">Upgrade: websocket</span><br><span class="line">Connection: Upgrade</span><br><span class="line">Sec-WebSocket-Accept: HSmrc0sMlYUkAGmm5OPpG2HaGWk&#x3D;</span><br><span class="line">Sec-WebSocket-Protocol: chat</span><br></pre></td></tr></table></figure><blockquote><p>Upgrade和Connection的作用同样是为了表明进行的是websocket连接。<br><br>Sec-WebSocket-Accept 这个则是经过服务器确认，并且加密过后的 Sec-WebSocket-Key，用来给客户端验证身份。<br><br>Sec-WebSocket-Protocol 则是表示最终使用的协议。</p></blockquote><p>数据帧：<br><br><img src="http://image.iosprogrammer.hongbility.com/WebSocket-SocketRocket-Source/frame_form.png" alt="数据帧格式"></p><div align=center><font color="gray" size="2">数据帧格式</font></div><ol><li><p>不同于其他协议，WebSocket是基于帧的而不是基于流<br></p></li><li><p>字段解释:</p><ol><li>FIN: 1 bit 表示是否是当前信息的最后一段</li><li>RSV1, RSV2, RSV3: 1 bit 除非双方协商定义了非0值，否则为0</li><li>Opcode: 4 bits 定义了数据包的类型，如果不是已定义类型则表示连接出错。定义的数据类型包括: 0x0表示中间数据包；0x1表示text类型数据包；0x2表示binary类型数据包；0x3-7保留；0x8表示连接关闭；0x9表示ping；0xA表示pong；0xB-F保留</li><li>MASK：1 bit 表示Payload是否经过掩码处理。MASK如果是1，Masking-Key的数据即是掩码密钥，用于解码PayloadData。客户端发出的数据帧需要进行掩码处理，所以此为是1。</li><li>Payload length：7 bit，7+16 bits，or 7+64 bits 表示payload data的长度，如果其值是0-125，则是payload的真实长度；如果是126，则后面的2个字节形成的16bits无符号整型数的值是payload的真实长度；如果是127，则后面8个字节形成的64bits无符号整型数的值是payload的真实长度。</li></ol></li><li><p>掩码</p><ol><li>掩码值必须是随机的32-bit值</li><li>掩码值并不会影响Payload data的长度。</li><li>掩码算法：掩码后的第i字节数据 = 掩码前的第i字节的数据 XOR 掩码key的第（i mod 4）字节的数据</li></ol></li></ol><h3 id="SocketRocket源码解析"><a href="#SocketRocket源码解析" class="headerlink" title="SocketRocket源码解析"></a>SocketRocket源码解析</h3><ol start="0"><li><p>辅助类简单说明</p><ol><li><text>_SRRunLoopThread</text>: 承载和处理所有事件的线程。通过<code>NSRunLoop (SRWebSocket)</code>把这个线程放到了RunLoop里。并且在<code>- (void)main</code>中使用一个while循环使这个线程正常情况下永不停止。</li><li>SRIOConsumer和SRIOConsumerPool: 用来处理收到的消息。</li></ol></li><li><p>主要方法说明</p><ol><li><p><code>- (id)initWithURLRequest:(NSURLRequest *)request protocols:(NSArray *)protocols allowsUntrustedSSLCertificates:(BOOL)allowsUntrustedSSLCertificates</code> 基本初始化方法。初始化了SRSocket类内的几个成员变量。</p></li><li><p><code>_SR_commonInit</code></p><ol><li>判断协议类型</li><li>初始化了_workQueue，这个GCD队列用来处理主要的业务逻辑，包括处理错误、发送内容、关闭连接等。</li><li>初始化_delegateDispatchQueue，这个队列是用来向外发送通知的。我们可以通过<code>- (void)setDelegateOperationQueue:(NSOperationQueue*) queue</code>或<code>- (void)setDelegateDispatchQueue:(dispatch_queue_t) queue</code>来自定义这个队列。</li></ol></li><li><p><code>_initializeStreams</code> 创建输入/出流</p></li><li><p><code>open</code>/<code>openConnection</code> 这两个方法和被他们调用的方法是用来配置并打开流的</p></li><li><p><code>didConnect</code></p><ol><li>构建HTTP Header</li><li>发送HTTP Header</li><li>注册一个接收服务器返回Header信息的监听，并在回调内进行相应处理</li></ol></li><li><p><code>- (void)safeHandleEvent:(NSStreamEvent)eventCode stream:(NSStream *)aStream</code></p><ol><li>这是NSStream的回调方法，输入和输出流的共同回调</li><li><code>NSStreamEventOpenCompleted</code> 连接打开；<code>NSStreamEventHasBytesAvailable</code> 可读取；<code>NSStreamEventHasSpaceAvailable</code> 可写入数据</li><li>在<code>NSStreamEventOpenCompleted</code>里面的<code>[self _pumpScanner];</code>用来触发第5条中的3，来处理服务器返回的握手Header信息</li></ol></li><li><p><code>_pumpWriting</code></p><ol><li>向输出流写数据<code>[_outputStream write:_outputBuffer.bytes + _outputBufferOffset maxLength:dataLength - _outputBufferOffset]</code></li><li><code>if (_outputBufferOffset &gt; 4096 &amp;&amp; _outputBufferOffset &gt; (_outputBuffer.length &gt;&gt; 1)) &#123; _outputBuffer = [[NSMutableData alloc] initWithBytes:(char *)_outputBuffer.bytes + _outputBufferOffset length:_outputBuffer.length - _outputBufferOffset]; _outputBufferOffset = 0; &#125;</code> 当缓存超过4M时清空</li></ol></li><li><p><code>- (void)_sendFrameWithOpcode:(SROpCode)opcode data:(id)data</code> 把数据组装成符合协议要求的格式。参考“数据帧格式”的图片。</p><ol><li>向frame_buffer中写入fin/opcode字段</li><li>写入mask字段</li><li>根据要发送的数据得到未掩码数据<code>unmasked_payload</code></li><li>使用<code>int SecRandomCopyBytes(SecRandomRef rnd, size_t count, void *bytes);</code>得到掩码key<code>mask_key</code></li><li>根据mask_key和unmasked_payload得到掩码后数据并切入frame_buffer</li></ol></li><li><p><code>_HTTPHeadersDidFinish</code> 处理服务器返回的握手信息。通过对服务器返回的握手信息的分析来判断连接是否成功打开。</p></li><li><p><code>_innerPumpScanner</code> 处理收到的数据，读取未读数据，并且把未读数据通过<code>consumer.handler(self, slice);</code>返回给consumer来解析数据内容。</p></li><li><p><code>- (void)_handleFrameWithData:(NSData *)frameData opCode:(NSInteger)opcode</code> 根据opCode对收到的数据进行分类处理</p></li><li><p><code>- (void)_readFrameContinue</code> 这个是主要的数据处理方法。整个数据结构的处理的过程就是按照WebSocket协议的规定来的。</p></li></ol></li></ol><p>到此，SocketRocket的源码分析就结束了。其中一些地方说的比较啰嗦，有些地方说的可能不够详细。大家在看源码的时候一定要对照着WebSocket的协议内容。如果有不清楚的地方欢迎咨询。有说的不对的地方也欢迎指正。<br></p><p>祝你早日走上人生巅峰!!!</p><h3 id="参考文章"><a href="#参考文章" class="headerlink" title="参考文章"></a>参考文章</h3><p><a href="http://www.ruanyifeng.com/blog/2017/05/websocket.html">阮一峰的网络日志</a><br><br><a href="https://www.zhihu.com/question/20215561">知乎</a><br><br><a href="https://tools.ietf.org/html/rfc6455">RFC6455 WebSocket Protocol</a></p>]]></content>
      
      
      
        <tags>
            
            <tag> iOS </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>iOS直播APP的开发——拉流</title>
      <link href="iOS-Pull-Live-Stream/"/>
      <url>iOS-Pull-Live-Stream/</url>
      
        <content type="html"><![CDATA[<p>编译iOS平台使用的ijkPlayer并用它来进行直播推流和拉流。</p><a id="more"></a><h3 id="播放器：IJKPlayer"><a href="#播放器：IJKPlayer" class="headerlink" title="播放器：IJKPlayer"></a>播放器：IJKPlayer</h3><ul><li>github地址：<a href="https://github.com/Bilibili/ijkplayer">https://github.com/Bilibili/ijkplayer</a></li><li>下载、编译过程<ul><li> git clone <a href="https://github.com/Bilibili/ijkplayer.git">https://github.com/Bilibili/ijkplayer.git</a> ijkplayer-ios</li><li>cd ijkplayer-ios</li><li>git checkout -B latest k0.8.8</li><li>./init-ios.sh</li><li>cd ios</li><li>./compile-ffmpeg.sh clean</li><li>./compile-ffmpeg.sh all</li></ul></li><li>编译过程中遇到的问题：<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">.&#x2F;libavutil&#x2F;arm&#x2F;asm.S:50:9: error: unknown directive</span><br><span class="line">        .arch armv7-a</span><br><span class="line">        ^</span><br><span class="line">make: *** [libavcodec&#x2F;arm&#x2F;aacpsdsp_neon.o] Error 1</span><br></pre></td></tr></table></figure></li><li>解决：<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">最新的 Xcode 已经弱化了对 32 位的支持, 解决方法: 在 compile-ffmpeg.sh 中删除 armv7 , 修改:FF_ALL_ARCHS_IOS8_SDK&#x3D;&quot;arm64 i386 x86_64&quot; 再重新执行出现错误的命令: .&#x2F;compile-ffmpeg.sh all</span><br></pre></td></tr></table></figure><h3 id="获取-framework"><a href="#获取-framework" class="headerlink" title="获取.framework"></a>获取.framework</h3></li></ul><ol><li>打开<code>IJKMediaPlayer.xcodeproj</code></li><li>选择真机</li><li>切换到Release模式</li><li>cmd+B 编译项目</li><li>获取/Product目录下的<code>IJKMediaFramework.framework</code>，并拷贝</li></ol><h3 id="获取rtmp直播流"><a href="#获取rtmp直播流" class="headerlink" title="获取rtmp直播流"></a>获取rtmp直播流</h3><p>我使用charles抓包到《鱼水直播》的推荐列表链接：<a href="http://api.chujianapp.com/live/get_hot_list?app_version=6.3.0&amp;bundle_id=fish.livezb.wte&amp;device=ios&amp;device_id=7ED19CAE-E21F-44BF-98DC-F5346E64E502&amp;device_idfa=51C0FC66-54C0-4F69-91E4-4C168698D1F5&amp;device_model=iPhone%206s&amp;device_version=iOS11.3.1&amp;pkg_channel=ys19&amp;secure_key=bd54628575ff36bd7695519218f6934f&amp;server_upgrade=1&amp;time_stamp=1525858044919&amp;token=18231046%7C227842b7058bc5dad052bc6d8834e68f%7C1525858019&amp;uid=18231046">http://api.chujianapp.com/live/get_hot_list?app_version=6.3.0&amp;bundle_id=fish.livezb.wte&amp;device=ios&amp;device_id=7ED19CAE-E21F-44BF-98DC-F5346E64E502&amp;device_idfa=51C0FC66-54C0-4F69-91E4-4C168698D1F5&amp;device_model=iPhone%206s&amp;device_version=iOS11.3.1&amp;pkg_channel=ys19&amp;secure_key=bd54628575ff36bd7695519218f6934f&amp;server_upgrade=1&amp;time_stamp=1525858044919&amp;token=18231046%7C227842b7058bc5dad052bc6d8834e68f%7C1525858019&amp;uid=18231046</a><br>从这个链接中可以得到rtmp流</p><h3 id="新建一个OC-Demo项目"><a href="#新建一个OC-Demo项目" class="headerlink" title="新建一个OC Demo项目"></a>新建一个OC Demo项目</h3><p>1. 把<code>IJKMediaFramework.framework</code>拷贝到项目目录中<br>2. 在<code>ViewController.m</code>中<code>#import &lt;IJKMediaFramework/IJKFFMoviePlayerController.h&gt;</code>，并且在<code>viewDidLoad</code>中添加如下代码：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">NSURL *playerURL &#x3D; [NSURL URLWithString:@&quot;rtmp:\&#x2F;\&#x2F;pili-live-rtmp.chujianapp.com\&#x2F;ragingfire\&#x2F;1663091115258475730&quot;];</span><br><span class="line">    IJKFFMoviePlayerController *playerVC &#x3D; [[IJKFFMoviePlayerController alloc] initWithContentURL:playerURL withOptions:nil];</span><br><span class="line">    [playerVC prepareToPlay];</span><br><span class="line">    playerVC.view.frame &#x3D; CGRectMake(30, 20, [UIScreen mainScreen].bounds.size.width * 2 &#x2F; 3, [UIScreen mainScreen].bounds.size.height * 2 &#x2F; 3);</span><br><span class="line">    playerVC.view.backgroundColor &#x3D; [UIColor grayColor];</span><br><span class="line">    [self.view insertSubview:playerVC.view atIndex:1];</span><br></pre></td></tr></table></figure><h3 id="运行项目"><a href="#运行项目" class="headerlink" title="运行项目"></a>运行项目</h3><p>(o゜▽゜)o☆[BINGO!]</p><h3 id="参考链接"><a href="#参考链接" class="headerlink" title="参考链接"></a>参考链接</h3><p><a href="https://www.jianshu.com/p/9743a68c2939">https://www.jianshu.com/p/9743a68c2939</a></p><p>👍👍👍</p>]]></content>
      
      
      
        <tags>
            
            <tag> 音视频 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>从零开始到提交一个开源项目到Cocopods</title>
      <link href="Create-Cocoapods-Repo/"/>
      <url>Create-Cocoapods-Repo/</url>
      
        <content type="html"><![CDATA[<p>iOS组件化要用到Cocopods，让我们讨论一下那么怎么创建自己的Cocoapods并且在多个项目组成员中间使用。</p><a id="more"></a><h3 id="开发过程"><a href="#开发过程" class="headerlink" title="开发过程"></a>开发过程</h3><ol><li><p>执行<code>pod lib create [ProjectName]</code>创建项目。过程中需要回答几个问题，根据自己的需要设置设置就可以了。我的设置是：</p><ul><li><p>What platform do you want to use?? [ iOS / macOS ]</p><blockquote><p>iOS</p></blockquote></li><li><p>What language do you want to use?? [ Swift / ObjC ]</p><blockquote><p>Swift</p></blockquote></li><li><p>Would you like to include a demo application with your library? [ Yes / No ]</p><blockquote><p>Yes</p></blockquote></li><li><p>Which testing frameworks will you use? [ Quick / None ]</p><blockquote><p>None</p></blockquote></li><li><p>Would you like to do view based testing? [ Yes / No ]</p><blockquote><p>No</p></blockquote><p>紧接着会自动执行<code>pod install</code>，我们只需要静静的等着完成就可以了。</p></li></ul></li><li><p>项目结构。 <code>pod install</code>之后，Cocoapods会直接打开Xcode project。项目结构如下：<br><img src="http://image.iosprogrammer.hongbility.com/Create-Cocoapods-Repo/project-struct.png" alt="project-struct"></p><ol><li>Podspec Metadata<ul><li>.podpsec - 项目相关的pod信息。包括了版本号、github主页、对其他项目的依赖、作者信息和指定资源文件</li><li>README.md - 对当前项目的介绍和使用方法。也就是github中项目主页的介绍内容。</li><li>LICENSE - 指定使用的开源协议  </li></ul></li><li>Example for DemoProj - 对开源代码的使用实例。其他人从github下载了开源项目后可以通过这个来查看使用方法。如果在<code>Would you like to include a demo application with your library?</code>中选择了No，这个项目就不会创建。因此强烈建议这个问题回答YES。对自己调试和别人使用都非常有利。</li><li>Tests - 单元测试。</li><li>Development Pods - 开源库代码就放在这里。</li><li>Frameworks - 当前开源项目的依赖库</li></ol></li><li><p>.podspec文件详解</p><ul><li>s.name - 名称，<code>pod search</code>搜索的关键词,注意这里一定要和.podspec的名称一样,否则报错</li><li>s.version - 版本号，这个版本号要和tag版本一致，否则报错</li><li>s.summary - 项目简介，<code>pod search</code>的结果中会展示</li><li>s.homepage - 项目主页地址，也就是github地址</li><li>s.source - <code>git clone</code>的项目地址。 </li><li>s.ios.deployment_target - 支持到的iOS版本</li><li>s.source_files - 资源文件路径。请确保把项目相关的源文件放在这个文件夹下面，否则报错。</li><li>s.dependency - 项目依赖的其他三方库。</li></ul></li><li><p>在github上创建仓库</p></li><li><p>开发项目。。。</p></li><li><p>开发结束，把项目提交到github。</p></li><li><p>打tag并把tag提交。tag号要和.podspec中的s.server一致。</p></li><li><p>验证.podspec</p><ol><li><code>pod lib lint</code>本地验证</li><li><code>pod spec lint</code>和github上的内容进行对比</li></ol></li><li><p>把项目发布到Cocopods的master上。<code>pod trunk push [ProjectName].podspec</code>。注意，这个过程较(chao ji)慢。</p></li></ol><h3 id="可能遇到的问题"><a href="#可能遇到的问题" class="headerlink" title="可能遇到的问题"></a>可能遇到的问题</h3><ol><li><code>pod lib lint</code>通过，但是<code>pod spec lint</code>报错：<code>use of unresolved identifier</code>。遇到这个问题后，分为两步：<ol><li><code>pod spec lint --no-clean --verbose</code>查看错误原因，这是会看到临时文件，到临时文件里查看会发现缺少文件</li><li>使用<code>pod cache clean</code></li><li>重新执行一次<code>pod spec lint</code></li></ol></li><li>项目提交后执行<code>pod search</code>找不到的话，执行<code>pod setup</code>。</li><li>验证的时候出现<code>.swift-version</code>错误。解决办法是在项目目录下创建一个执行<code>echo &quot;4.0&quot; &gt; .swift-version</code>。注意，这里的4.0是我开发项目时使用的Swift版本。</li><li><strong>注意权限控制和Swift与OC的混编问题</strong></li></ol><h3 id="赠送一个提交开源库的shell脚本"><a href="#赠送一个提交开源库的shell脚本" class="headerlink" title="赠送一个提交开源库的shell脚本"></a>赠送一个提交开源库的shell脚本</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> bin/sh</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> 验证本地 pod lib lint</span></span><br><span class="line">echo &#x27;pod lib lint...\n&#x27;</span><br><span class="line">pod lib lint</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 下拉git  git pull</span></span><br><span class="line">echo &#x27;\ngit pull...\n&#x27;</span><br><span class="line">git pull</span><br><span class="line">echo `git pull`</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 上传git git add git commit git push</span></span><br><span class="line">echo &quot;git add . \n&quot;</span><br><span class="line">git add .</span><br><span class="line">echo &quot;Enter a commit message: \c&quot;</span><br><span class="line">read commitMsg</span><br><span class="line">echo &quot;git commit -m $commitMsg&quot;</span><br><span class="line">git commit -m &#x27;$commitMsg&#x27;</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> tag git tag  git push --tags</span></span><br><span class="line">echo &quot;\ngit push ...\n&quot;</span><br><span class="line">git push</span><br><span class="line"></span><br><span class="line">echo &quot;\nEnter tag version: \c&quot;</span><br><span class="line">read tagVersion</span><br><span class="line">git tag $tagVersion</span><br><span class="line">echo &quot;\n git push --tags ...&quot;</span><br><span class="line">git push --tags</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 远程验证 pod spec lint</span></span><br><span class="line">echo &quot;\npod spec lint ...\n&quot;</span><br><span class="line">pod spec lint</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 提交代码 pod trunk</span></span><br><span class="line">echo &quot;\npod trunk push ...\n&quot;</span><br><span class="line">pod trunk push [yourprojectname].podspec</span><br></pre></td></tr></table></figure><p>👍👍👍</p>]]></content>
      
      
      
        <tags>
            
            <tag> iOS </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>LLDB调试iOS程序（二）—— 高级用法</title>
      <link href="LLDB-Advanced-Usage/"/>
      <url>LLDB-Advanced-Usage/</url>
      
        <content type="html"><![CDATA[<p>断点调试是每一个开发人员的必备技能，在iOS开发中LLDB作为官方的调试工具是iOS开发者必须掌握的。</p><a id="more"></a><h3 id="巧用help命令"><a href="#巧用help命令" class="headerlink" title="巧用help命令"></a>巧用<code>help</code>命令</h3><p>LLDB中的命令非常多，虽然有一些算是常用的，但是要完全记住也很难，为了解决这个问题，我们可以充分利用<code>help</code>命令。比如要查看<code>breakPoint</code>的用法，可以先查看它的自命令：<br>![help breakpoint](<a href="http://image.iosprogrammer.hongbility.com/LLDB-Advanced-Usage/help">http://image.iosprogrammer.hongbility.com/LLDB-Advanced-Usage/help</a> breakpoint.png)<br>图中列举出了所有的<code>breakpoint</code>的子命令。</p><p>请看最后一行<code>For more help on any particular subcommand, type &#39;help &lt;command&gt; &lt;subcommand&gt;&#39;</code>。根据这条提示，我们来查看其中一条子命令的详细用法。<br>![help breakpoint](<a href="http://image.iosprogrammer.hongbility.com/LLDB-Advanced-Usage/help">http://image.iosprogrammer.hongbility.com/LLDB-Advanced-Usage/help</a> breakpoint set.png)<br>图中只是截取了部分内容。</p><p>由此可见LLDB给我们提供的<code>help</code>命令还是很强大的。我们在平时的调试过程中，如果遇到了不确定命令是什么了，可以使用<code>help</code>命令来查看，也可以使用<strong>自动提示</strong>功能来帮助我们。</p><h3 id="流程控制"><a href="#流程控制" class="headerlink" title="流程控制"></a>流程控制</h3><p>执行流程控制的命令包括<code>process</code>、<code>breakpoint</code>、<code>thread</code>，具体可以查看<a href="http://www.cocoachina.com/swift/20171013/20789.html">这篇文章</a>。</p><p>这里只讨论设置命中断点后执行的命令<code>breakpoint command add &lt;#断点#&gt;</code>。</p><p>首先使用<code>breakpoint list</code>来查看所有的断点。<br>![breakpoint list](<a href="http://image.iosprogrammer.hongbility.com/LLDB-Advanced-Usage/breakpoint">http://image.iosprogrammer.hongbility.com/LLDB-Advanced-Usage/breakpoint</a> list.png)<br>其中，前面的数字是断点的序号，可以唯一标识一个断点。图中的1/2都是全局断点，3是我自己加的断点。下面我们给3.1断点增加执行后的指令：<br>![breakpoint command add](<a href="http://image.iosprogrammer.hongbility.com/LLDB-Advanced-Usage/breakpoint">http://image.iosprogrammer.hongbility.com/LLDB-Advanced-Usage/breakpoint</a> command add.png)<br>如图，我们在断点出分别执行<code>po self</code>、<code>po self.view</code>、<code>continue</code>。其中<code>continue</code><strong>表示到此断点后继续执行，这在循环等场景特别有用</strong>。命令的执行结果为：<br>![breakpoint command add result](<a href="http://image.iosprogrammer.hongbility.com/LLDB-Advanced-Usage/breakpoint">http://image.iosprogrammer.hongbility.com/LLDB-Advanced-Usage/breakpoint</a> command add result.png)</p><p>这种方法在需要多次执行的场景中特别有用，完全可以代替使用<code>print()</code>来查看变量值的方案。</p><h3 id="给断点增加触发条件"><a href="#给断点增加触发条件" class="headerlink" title="给断点增加触发条件"></a><strong><em>给断点增加触发条件</em></strong></h3><p>有这样一种场景：在一个循环中，我们只要在某些条件下才需要触发断点。可以这样设置：<br>![breakpoint condition](<a href="http://image.iosprogrammer.hongbility.com/LLDB-Advanced-Usage/breakpoint">http://image.iosprogrammer.hongbility.com/LLDB-Advanced-Usage/breakpoint</a> condition.png)</p><h4 id="参考文章"><a href="#参考文章" class="headerlink" title="参考文章"></a>参考文章</h4><p><a href="http://www.cocoachina.com/swift/20171013/20789.html">使用LLDB调试Swift</a></p>]]></content>
      
      
      
        <tags>
            
            <tag> iOS </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>LLDB调试iOS（一）—— 初识LLDB</title>
      <link href="Get-To-Know-LLDB/"/>
      <url>Get-To-Know-LLDB/</url>
      
        <content type="html"><![CDATA[<h3 id="什么是LLDB"><a href="#什么是LLDB" class="headerlink" title="什么是LLDB"></a><strong>什么是LLDB</strong></h3><p>LLDB是下一代、高性能的调试器。它是作为一组可重用组件构建的，它可以高度利用较大<strong>LLVM</strong>项目中的现有库，例如<strong>Clang</strong>表达式解析器和LLVM反汇编器。</p><p>LLDB是Mac OS X上Xcode的默认调试器，支持在桌面和iOS设备、模拟器上调试C/Objective-C/C++/Swift。</p><a id="more"></a><h3 id="LLDB的进步"><a href="#LLDB的进步" class="headerlink" title="LLDB的进步"></a>LLDB的进步</h3><ol><li>支持现代化的多线程程序</li><li>以高效的方式处理调试符号</li><li>使用基于编码器（LLVM）的代码知识</li><li>支持插件扩展</li></ol><h3 id="与LLVM集成的优势"><a href="#与LLVM集成的优势" class="headerlink" title="与LLVM集成的优势"></a>与LLVM集成的优势</h3><p>LLDB当前将调试信息转换为clang类型，以便它可以利用clang编译器基础结构。 这允许LLDB在表达式中支持最新的C，C ++，Objective C和Objective C ++语言功能和运行时，而无需重新实现这些功能。 在进行表达式的函数调用，分解指令和提取指令细节时，它还利用编译器处理所有ABI细节，等等。</p><p>主要好处包括:</p><ul><li>C，C ++，Objective C的最新语言支持</li><li>可以声明局部变量和类型的多行表达式</li><li>支持时使用JIT表达式</li><li>在无法使用JIT时评估表达式Intermediate Intermediateation（IR）</li></ul><h3 id="LLDB与GDB的不同"><a href="#LLDB与GDB的不同" class="headerlink" title="LLDB与GDB的不同"></a>LLDB与GDB的不同</h3><pre><code>1. GDB是GNU项目中的一部分，是为了和GNU编译器协同工作而创建的2. LLDB是LLVM项目中的一部分，是为了和LLVM编译器协同工作而创建的3. GDB和LLDB的命令有一些不同。LLDB命令就像OC语法一样，要有形参名，而GDB则不需要，这一点上孰优孰劣就见仁见智了。</code></pre><h3 id="LLDB命令结构"><a href="#LLDB命令结构" class="headerlink" title="LLDB命令结构"></a>LLDB命令结构</h3><p>为了更好的使用和了解LLDB，所有学习LLDB的用户都应该了解LLDB的命令结构<br>LLDB的命令都是这样的形式：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;command&gt; [&lt;subcommand&gt; [&lt;subcommand&gt;...]] &lt;action&gt; [-options [option-value]] [argument [argument...]]</span><br></pre></td></tr></table></figure><p><code>command</code>和<code>subcommand</code>都是LLDB调试器对象的名称。命令和子命令按照层次结构排列：特定的命令对象为其后的子命令对象创建上下文，该对象再次为下一个子命令提供上下文，依此类推。<br><code>action</code>是你想要在调试器对象（前面提到的命令和子命令）组成的上下文中执行的一些操作。<br><code>options</code>：行为修改器(action modifiers)。通常带有一些值。<br><code>argument</code>：根据使用的命令的上下文来表示各种不同的东西。</p><p>LLBD命令行的解析操作在执行命令之前完成。上面的这些元素之间通过空格来分割，如果某一元素自身含有空格，则可以使用双引用。而如果元素中又包含双引号，则可以使用反斜杠；或者元素使用单引号。如下所示：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">(lldb) command [subcommand] -option &quot;some \&quot;quoted\&quot; string&quot;</span><br></pre></td></tr></table></figure><p>也可以这样表示：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">(lldb) command [subcommand] -option &quot;some \&quot;quoted\&quot; string&quot;</span><br></pre></td></tr></table></figure><p>这种命令解析设计规范了LLDB命令语法，并对所有命令做了个统一。</p><h3 id="使用举例"><a href="#使用举例" class="headerlink" title="使用举例"></a>使用举例</h3><p>调试快捷键：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">command+shift+Y 打开调试窗口</span><br><span class="line">command+Y 调试运行程序</span><br><span class="line">command+option+P 继续</span><br><span class="line">command+shift+O 跳过</span><br><span class="line">command+shift+I 进入</span><br><span class="line">command+shift+T 跳出</span><br></pre></td></tr></table></figure><ul><li><code>p/po</code> 这两个命令都是用来做输出调用的，其中p用来打印常量，po用来打印对象<br><img src="http://image.iosprogrammer.hongbility.com/Get-To-Know-LLDB/p%E5%92%8Cpo.png" alt="p/po"></li><li><code>call</code>：一般只在不需要显示输出，或是方法无返回值时使用call。想要在debug阶段修改view的背景色、试一下label显示更多文字的效果、调用一个忘记调用的函数。。。都可以使用call命令</li><li><code>e</code>：可以在调试时动态执行指定表达式，并将结果打印出来。常用于在调试过程中修改变量的值。<img src="http://image.iosprogrammer.hongbility.com/Get-To-Know-LLDB/e.png" alt="e"></li></ul><h3 id="参考链接"><a href="#参考链接" class="headerlink" title="参考链接"></a>参考链接</h3><ul><li><a href="http://blog.csdn.net/talentedlas/article/details/51945569">LLVM与Clang的概述及关系</a></li><li><a href="http://lldb.llvm.org/">LLDB Homepage</a></li><li><a href="https://developer.apple.com/library/content/documentation/IDEs/Conceptual/gdb_to_lldb_transition_guide/document/lldb-basics.html#//apple_ref/doc/uid/TP40012917-CH2-SW1">LLDB Quick Start Guide</a></li><li><a href="http://www.cocoachina.com/swift/20171013/20789.html">使用LLDB调试Swift</a></li><li><a href="https://mp.weixin.qq.com/s/us5aXQAwSSoxkUMOVzofkg">什么是LLVM？Swift，Rust，Clang等语言背后的原力</a></li></ul>]]></content>
      
      
      
        <tags>
            
            <tag> iOS </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Xcode持续集成简介</title>
      <link href="XCode-Server-CI/"/>
      <url>XCode-Server-CI/</url>
      
        <content type="html"><![CDATA[<p>Xcode持续集成简介</p><a id="more"></a><h3 id="环境"><a href="#环境" class="headerlink" title="环境"></a>环境</h3><ul><li>Xcode 9.2</li><li>macOS High Sierra 10.13.2</li></ul><h3 id="本文的目的"><a href="#本文的目的" class="headerlink" title="本文的目的"></a>本文的目的</h3><ul><li>介绍Xcode CI和Xcode Server</li><li>手把手教你从头开始创建一个Xcode Server来进行自动集成</li></ul><h3 id="Xcode-CI和Xcode-Server"><a href="#Xcode-CI和Xcode-Server" class="headerlink" title="Xcode CI和Xcode Server"></a>Xcode CI和Xcode Server</h3><p>正如<a href="https://developer.apple.com/library/content/documentation/IDEs/Conceptual/xcode_guide-continuous_integration/index.html#//apple_ref/doc/uid/TP40013292-CH1-SW1">苹果开发者网站</a>所描述的</p><blockquote><p>In Xcode, continuous integration is the process of automating and streamlining the building, analyzing, testing, and archiving of your Mac and iOS apps, in order to ensure that they are always in a releasable state.</p></blockquote><p>Xcode CI是一种为了确保你的APP始终处于可发布状态而存在的自动的、流式的过程，整个过程包括了编译、解析、测试和打包。<br>Xcode Server是用来远程进行这个过程的服务器。</p><p>整个过程类似下图<br><img src="http://image.iosprogrammer.hongbility.com/XCode-Server-CI/Xcode-CI-Intro.png"></p><ul><li>使用这个过程的目的就是为了集成开发APP的整个过程，让这个过程完全自动化进行。通过Xcode CI可以在每次提交代码后自动进行编译到打包的过程，并且可以查看代码的测试覆盖率。因为它可以自动执行单元测试，可以更方便的查看测试报告。</li></ul><h3 id="集成"><a href="#集成" class="headerlink" title="集成"></a>集成</h3><ol><li><p>打开Xcode Server</p><ol><li>点击Xcode菜单栏中的Xcode选项卡的Xcode Server…</li><li>将右上角的开关调到On</li></ol></li><li><p>配置Xcode Server</p><ol><li><p>点击Product选项卡中的Create Bot…</p></li><li><p>配置bot的Name。Server一般不需要<img src="http://image.iosprogrammer.hongbility.com/XCode-Server-CI/Create-a-new-bot.png"></p></li><li><p>配置代码库<img src="http://image.iosprogrammer.hongbility.com/XCode-Server-CI/Configure-source-control-for-this-bot.png"><br><img src="http://image.iosprogrammer.hongbility.com/XCode-Server-CI/Configrure-souce-code-2.png"></p><blockquote><p>这里选择的是使用.ssh的公钥来配置，当然也可以使用UserName And Password或者Bot Specific SSh Keys。</p></blockquote></li><li><p>选择分支</p></li><li><p>配置Bot的环境<br><img src="http://image.iosprogrammer.hongbility.com/XCode-Server-CI/Configure-build-configuration.png"></p><blockquote><p>这里可以选择在集成的时候是否进行静态分析、测试和打包</p></blockquote></li><li><p>配置集成周期<img src="http://image.iosprogrammer.hongbility.com/XCode-Server-CI/Schedule-bot-integrations.png"></p><blockquote><p>其中，Ingegrate选项中Periodically表示按周期集成，包括小时、天、周；Clean选项表示对项目进行Clean的周期，包括Always/Once a day/Once a week/Never。</p></blockquote></li><li><p>选择集成的目标设备。可以设置模拟器和真机、所有的模拟器、所有的真机、指定的模拟器和指定的真机。</p></li><li><p>配置项目证书</p></li><li><p>集成完成<img src="http://image.iosprogrammer.hongbility.com/XCode-Server-CI/create-ci-success.png"></p></li></ol></li></ol><h3 id="可能遇到的问题和解决方案"><a href="#可能遇到的问题和解决方案" class="headerlink" title="可能遇到的问题和解决方案"></a>可能遇到的问题和解决方案</h3><ol><li>The sandbox is not in sync with the Podfile.lock.Run ‘pod install’ or update your CocoaPods installation.</li><li>Invalid byte sequence in US_ASCII(Argument Error)</li></ol><blockquote><p>其中第一个问题需要在每次integrate之前执行<code>pod install</code>；第二个问题是由于Ruby的编码问题导致的，这两个问题的统一解决方案是给Bot添加一个prebuild script，步骤如下： 1. Edit Bot…  2. Triggers 3. Click ‘+’, select ‘Pre-Integraation Script’<br>具体的脚本内容为：<img src="http://image.iosprogrammer.hongbility.com/XCode-Server-CI/pre-script.jpg"><br>下面对这个脚本做一个解释说明:<br>(1). 第2行是用来查看脚本（也就是Server）当前的环境<img src="http://image.iosprogrammer.hongbility.com/XCode-Server-CI/set.jpg"><br>(2). 第4行是切换到项目所在目录，目录地址可以从环境的PWD变量获得<br>(3). 6-8行是用来解决第2个问题的<br>(4). 第10行来执行<code>pod install</code></p></blockquote><h3 id="脚本上传到蒲公英"><a href="#脚本上传到蒲公英" class="headerlink" title="脚本上传到蒲公英"></a>脚本上传到蒲公英</h3><p>   增加一个Post-Integration Scripts<img src="http://image.iosprogrammer.hongbility.com/XCode-Server-CI/post_integration_scripy.jpg" alt="post_integration_script"></p>]]></content>
      
      
      
        <tags>
            
            <tag> iOS </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>使用Instruments工具测试CPU与常见对CPU占用过高的操作</title>
      <link href="Using-Instruments-To-Oprimize-CPU-Performance/"/>
      <url>Using-Instruments-To-Oprimize-CPU-Performance/</url>
      
        <content type="html"><![CDATA[<p>使用Xcode自带的Instruments工具，检测CPU</p><a id="more"></a><h2 id="Instruments"><a href="#Instruments" class="headerlink" title="Instruments"></a>Instruments</h2><p>打开Instruments：Xcode -&gt; Product -&gt; Profile 或者 cmd + i<br>启动后如下：<br><img src="http://upload-images.jianshu.io/upload_images/424855-8c5d278b6d7b35c0.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="Instruments.png"><br>其中常用的有用来检测内存泄露的Leaks和查看CPU消耗情况的Time Profiler。下面介绍查看CPU使用情况的Time Profiler</p><h3 id="Time-Profier"><a href="#Time-Profier" class="headerlink" title="Time Profier"></a>Time Profier</h3><ol><li>打开Time Profier</li></ol><p><img src="https://upload-images.jianshu.io/upload_images/424855-4322b66e910ec9ae.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="Timer profile 9.0.png"></p><blockquote><p>要查看每个函数的CPU性能，直接双击函数就可以定位到代码了。<br>函数前面的数值是所用时间，可以根据这个时间判断是是否需要优化。</p></blockquote><p>有了上面的基础知识就可以对App的CPU消耗情况进行实时检测了。</p><h3 id="常见的对CPU消耗过高的操作"><a href="#常见的对CPU消耗过高的操作" class="headerlink" title="常见的对CPU消耗过高的操作"></a>常见的对CPU消耗过高的操作</h3><ul><li>加载图片<br>两种不同方式在相同时间内的CPU消耗情况对比：<br><img src="http://upload-images.jianshu.io/upload_images/424855-70124a2646fe806a.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="Paste_Image.png"><br><img src="http://upload-images.jianshu.io/upload_images/424855-0f98cb8f0b9d974b.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="屏幕快照 2016-03-13 下午6.25.34.png"><br>并且，使用5s真机测试以下代码40s后Memory过高造成闪退，但是使用<code>imageWithContentOfFile</code>数分钟后没有出现闪退现象<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">while (1)</span><br><span class="line">    &#123;</span><br><span class="line">        [UIImage imageNamed:@&quot;58_58&quot;];</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure></li><li>初始化对象<ul><li>正则表达式</li><li>时间戳<br><img src="http://upload-images.jianshu.io/upload_images/424855-612ee50bf16040c3.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="屏幕快照 2016-03-13 下午6.37.50.png"></li></ul></li></ul><p>在需要多次使用的地方尽量只初始化一次，然后多次使用</p><ul><li>视图布局<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;-(void)layoutSubviews</span><br><span class="line">&#123;</span><br><span class="line">    &#x2F;&#x2F; do something</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">[view setNeedsLayout];</span><br><span class="line">[view layoutIfNeeded];</span><br></pre></td></tr></table></figure>这些函数尽量不要使用。每对view进行一次重新布局就会对CPU增加很多消耗。</li><li>绘制图层<br>需要用到<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[layout rendInContext:]</span><br></pre></td></tr></table></figure>的地方尽量换成iOS7以后新增的方法：<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[view drawViewHierachyInRect:]</span><br></pre></td></tr></table></figure>性能同样可以获得很大的提升</li></ul><div class="note info"><p>到公众号【iOS开发栈】学习更多SwiftUI、iOS开发相关内容。回复“博客”免费获取各大互联网公司面试题。</p></div>]]></content>
      
      
      
        <tags>
            
            <tag> iOS </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>SocketRocket使用</title>
      <link href="iOS-SocketRocket/"/>
      <url>iOS-SocketRocket/</url>
      
        <content type="html"><![CDATA[<p>SocketRocket是Facebook开源的一个用于 iOS, macOS and tvOS客户端的websocket框架。<br></p><a id="more"></a><p>WebSocket的协议分析和SocketRocket框架源码分析在<a href="http://www.iosprogrammer.tech/WebSocket-And-SocketRocket-Source-Analysis/">这里</a></p><h2 id="1-集成"><a href="#1-集成" class="headerlink" title="1. 集成"></a>1. 集成</h2><ul><li><p>使用cocoapods<br>  只需要在podfile文件中加入<code>pod &#39;SocketRocket&#39;</code>，然后执行<code>pod install</code>就可以了</p></li><li><p>不使用cocoapods</p><ol><li><p>添加文件<br>把下面的三个文件拖入项目中<br><img src="http://upload-images.jianshu.io/upload_images/424855-07d19159ebcaf127.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="Paste_Image.png"><br>其中，SocketRocket.h文件是用来引入框架的所有类的文件，就像&lt;UIKit/UIkit.h&gt;。目前，这个文件只引入了一个类，所以只有一行代码 <code>&lt;SocketRocket/SRWebSocket.h&gt;</code>，这样的话，编译会报错，因为并没有一个SocketRocket的framework，需要把这一行代码改为 <code>#import &quot;SRWebSocket.h&quot;</code>。</p></li><li><p>添加依赖库<br>在Build Phases -&gt; Link Binary With Libraries里加入如下frameworks：</p><ul><li>libicucore.dylib</li><li>CFNetwork.framework</li><li>Security.framework</li><li>Foundation.framework</li></ul></li></ol></li></ul><h2 id="2-使用"><a href="#2-使用" class="headerlink" title="2. 使用"></a>2. 使用</h2><ol><li>初始化   初始化方法分为两类：<ul><li>通过传入NSURLRequest的对象进行初始化<figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">-(<span class="keyword">id</span>)initWithURLRequest:(<span class="built_in">NSURLRequest</span> *)request protocols:(<span class="built_in">NSArray</span> *)protocols allowsUntrustedSSLCertificates:(<span class="built_in">BOOL</span>)allowsUntrustedSSLCertificates;</span><br><span class="line">-(<span class="keyword">id</span>)initWithURLRequest:(<span class="built_in">NSURLRequest</span> *)request protocols:(<span class="built_in">NSArray</span> *)protocols;</span><br><span class="line">-(<span class="keyword">id</span>)initWithURLRequest:(<span class="built_in">NSURLRequest</span> *)request;</span><br></pre></td></tr></table></figure></li><li>通过传入NSURL的对象进行初始化<figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">-(<span class="keyword">id</span>)initWithURL:(<span class="built_in">NSURL</span> *)url protocols:(<span class="built_in">NSArray</span> *)protocols allowsUntrustedSSLCertificates:(<span class="built_in">BOOL</span>)allowsUntrustedSSLCertificates;</span><br><span class="line">-(<span class="keyword">id</span>)initWithURL:(<span class="built_in">NSURL</span> *)url protocols:(<span class="built_in">NSArray</span> *)protocols;</span><br><span class="line">-(<span class="keyword">id</span>)initWithURL:(<span class="built_in">NSURL</span> *)url;</span><br></pre></td></tr></table></figure>其中，使用NSURLRequest进行初始化可以自定义请求超时时间<figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[<span class="built_in">NSURLRequest</span> requestWithURL:url cachePolicy:<span class="built_in">NSURLRequestUseProtocolCachePolicy</span> timeoutInterval:timeoutInterval]</span><br></pre></td></tr></table></figure></li></ul></li><li>打开连接<br>使用第一步创建出来的SRWebSocket对象（以下简称‘对象’）调用<code>- (void)open</code>来与服务器建立连接。这里需要注意<code>// SRWebSockets are intended for one-time-use only.  Open should be called once and only once.</code>一个对象只能调用一次<code>- (void)open</code>调用过open后，对象的readyState就为SR_CONNECTING，如果再调用open，就会<code>NSAssert(_readyState == SR_CONNECTING, @&quot;Cannot call -(void)open on SRWebSocket more than once&quot;);</code></li><li>发送数据<br>使用对象调用<code>- (void)send:(id)data</code>这个data可以是一个UTF8的字符串或者NSData对象</li><li>关闭连接<br>使用对象调用<code>- (void)close</code>来关闭一个连接。</li><li>回调<br> 以delegate的方式进行回调，包括下面几个回调函数<figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">@protocol</span> <span class="title">SRWebSocketDelegate</span> &lt;<span class="title">NSObject</span>&gt;</span></span><br><span class="line">-(<span class="keyword">void</span>)webSocket:(SRWebSocket *)webSocket didReceiveMessage:(<span class="keyword">id</span>)message;</span><br><span class="line"><span class="keyword">@optional</span></span><br><span class="line">-(<span class="keyword">void</span>)webSocketDidOpen:(SRWebSocket *)webSocket;</span><br><span class="line">-(<span class="keyword">void</span>)webSocket:(SRWebSocket *)webSocket didFailWithError:(<span class="built_in">NSError</span> *)error;</span><br><span class="line">-(<span class="keyword">void</span>)webSocket:(SRWebSocket *)webSocket didCloseWithCode:(<span class="built_in">NSInteger</span>)code reason:(<span class="built_in">NSString</span> *)reason wasClean:(<span class="built_in">BOOL</span>)wasClean;</span><br><span class="line">-(<span class="keyword">void</span>)webSocket:(SRWebSocket *)webSocket didReceivePong:(<span class="built_in">NSData</span> *)pongPayload;</span><br><span class="line">-(<span class="built_in">BOOL</span>)webSocketShouldConvertTextFrameToString:(SRWebSocket *)webSocket;</span><br><span class="line"><span class="keyword">@end</span></span><br></pre></td></tr></table></figure>其中，<ul><li><code>webSocketDidOpen</code>表示与服务器的连接建立成功，这时就可以与服务器进行交互了。</li><li><code>didFailWithError</code>表示连接出现错误，包括连接没有成功建立的错误、网络错误等。如果需要进行重连，应该在这里进行，可以采用Demo里面的方式进行重连：把以后的对象置空-&gt;重新初始化-&gt;调用open。应用切到后台2分钟以后才会出现连接错误的回调。</li></ul></li><li>SocketRocket已经对消息的收发进行了处理。我们收到和发出的消息都是根据socket头进行分隔的，所以不会出现消息不完整或者多条消息同时收发的问题。</li></ol><p>上面是在使用SocketRocket的过程中的总结，通过这些应该可以把这个框架使用起来，以后有时间会继续钻研这个框架的源码。SocketRocket还是挺好用的。</p><div class="note info"><p>到公众号【iOS开发栈】学习更多SwiftUI、iOS开发相关内容。回复“博客”免费获取各大互联网公司面试题。</p></div>]]></content>
      
      
      
        <tags>
            
            <tag> iOS </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Array().addObject(ViewController())造成控制器不释放</title>
      <link href="Array-addObject-ViewController-cause-viewcontroller-not-release/"/>
      <url>Array-addObject-ViewController-cause-viewcontroller-not-release/</url>
      
        <content type="html"><![CDATA[<h2 id="场景"><a href="#场景" class="headerlink" title="场景"></a>场景</h2><p>项目中有一个单例<code>Singleton</code>。有多个<code>UIViewController</code>需要向Singleton中注册观察者来接受<code>Singleton</code>的消息。<br> 这种情况下，使用<code>NSNotificationCenter</code>的方案有些松散，因此不作考虑；<br>  还有一种是使用<code>delegate</code>的方式。为了让<code>delegate</code>可以实现一对多的功能，可以在<code>Singleton</code>的里面增加一个<code>mutableArray</code>的变量和一个<code>addDelegate:</code>的方法。然后在需要接受这个<code>Singleton</code>通知的地方<code>Singleton().addDelegate(self)</code>，这样可以达到目的，但是你会发现这个控制器再也不会调用<code>dealloc</code>。</p><a id="more"></a><h2 id="问题1"><a href="#问题1" class="headerlink" title="问题1"></a>问题1</h2><p>那个调用了<code>Singleton().addDelegate(self)</code>的控制器为什么不会<code>dealloc()</code>了呢？</p><h2 id="分析1"><a href="#分析1" class="headerlink" title="分析1"></a>分析1</h2><ol><li><code>Singleton()</code>作为单例是不会释放的；</li><li><code>mutableArray</code>被<code>Singleton()</code>强引用着，因此也是不会释放的；</li><li>接受消息的控制器被添加到了<code>mutableArray()</code>中，就会被<code>mutableArray()</code>强引用，因此也不会释放；<h2 id="结论1"><a href="#结论1" class="headerlink" title="结论1"></a>结论1</h2>控制器会一直被强引用，因此不会调用<code>dealloc()</code><h2 id="问题2"><a href="#问题2" class="headerlink" title="问题2"></a>问题2</h2>那么，如果把<code>Singleton().addDelegate(self)</code>中的self改成__weak呢？<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">__weak UIViewController *weakself &#x3D; self;</span><br><span class="line">Singleton().addDelegate(weakself);</span><br></pre></td></tr></table></figure><h2 id="分析2"><a href="#分析2" class="headerlink" title="分析2"></a>分析2</h2>先来看一段代码：<figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">_arr = [<span class="built_in">NSMutableArray</span> array];</span><br><span class="line">Dog *dog1 = [[Dog alloc] init];</span><br><span class="line"><span class="built_in">NSLog</span>(<span class="string">@&quot;-- retain count: %ld&quot;</span>, <span class="built_in">CFGetRetainCount</span>((__bridge <span class="built_in">CFTypeRef</span>)(dog1)));</span><br><span class="line">__<span class="keyword">weak</span> Dog *weakDog = dog1;</span><br><span class="line"><span class="built_in">NSLog</span>(<span class="string">@&quot;-- retain count: %ld&quot;</span>, <span class="built_in">CFGetRetainCount</span>((__bridge <span class="built_in">CFTypeRef</span>)(dog1)));</span><br><span class="line"><span class="built_in">NSLog</span>(<span class="string">@&quot;-- retain count: %ld&quot;</span>, <span class="built_in">CFGetRetainCount</span>((__bridge <span class="built_in">CFTypeRef</span>)(weakDog)));</span><br><span class="line">[<span class="keyword">self</span>.arr addObject:weakDog];</span><br><span class="line"><span class="built_in">NSLog</span>(<span class="string">@&quot;-- retain count: %ld&quot;</span>, <span class="built_in">CFGetRetainCount</span>((__bridge <span class="built_in">CFTypeRef</span>)(dog1)));</span><br><span class="line"><span class="built_in">NSLog</span>(<span class="string">@&quot;-- retain count: %ld&quot;</span>, <span class="built_in">CFGetRetainCount</span>((__bridge <span class="built_in">CFTypeRef</span>)(weakDog)));</span><br><span class="line"></span><br><span class="line">Dog *dog2 = dog1;    </span><br><span class="line"></span><br><span class="line"><span class="built_in">NSLog</span>(<span class="string">@&quot;dog1 = %p&quot;</span>, dog1);</span><br><span class="line"><span class="built_in">NSLog</span>(<span class="string">@&quot;weakdog1 = %p&quot;</span>, weakDog);</span><br><span class="line"><span class="built_in">NSLog</span>(<span class="string">@&quot;weakdog1 = %p&quot;</span>, <span class="keyword">self</span>.arr.firstObject);</span><br><span class="line"><span class="built_in">NSLog</span>(<span class="string">@&quot;dog2 = %p&quot;</span>, dog2);</span><br><span class="line"><span class="built_in">NSLog</span>(<span class="string">@&quot;retain count: %ld&quot;</span>, <span class="built_in">CFGetRetainCount</span>((__bridge <span class="built_in">CFTypeRef</span>)(dog1)));</span><br></pre></td></tr></table></figure>打印结果是：<figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">retain</span> count: <span class="number">1</span></span><br><span class="line"><span class="keyword">retain</span> count: <span class="number">1</span></span><br><span class="line"><span class="keyword">retain</span> count: <span class="number">2</span></span><br><span class="line"><span class="keyword">retain</span> count: <span class="number">2</span></span><br><span class="line"><span class="keyword">retain</span> count: <span class="number">3</span></span><br><span class="line">dog1 = <span class="number">0x60400000b600</span></span><br><span class="line">weakdog1 = <span class="number">0x60400000b600</span></span><br><span class="line">weakdog1 = <span class="number">0x60400000b600</span></span><br><span class="line">dog2 = <span class="number">0x60400000b600</span></span><br><span class="line"><span class="keyword">retain</span> count: <span class="number">3</span></span><br></pre></td></tr></table></figure>可以验证：<ol><li><strong><em>__weak的作用是在不增加对象引用计数的前提下持有对象的引用</em></strong> </li><li><strong><em>mutableArray会增加所持有指针所指对象的引用计数（不论是不是强指针）</em></strong></li><li><strong><em>指针赋值可以使新的指针指向相同的地址（与本问题无关）</em></strong><h2 id="结论2"><a href="#结论2" class="headerlink" title="结论2"></a>结论2</h2>使用__weak的弱指针同样会使当前控制器被数组强引用，同样会造成当前控制器不释放<h1 id="结论3"><a href="#结论3" class="headerlink" title="结论3"></a>结论3</h1>通过以上分析可以看出，想要控制器得到释放，就不能让数组持有控制器的强引用，下面有三个方案可以达到这个目的：<h2 id="方法1-NSValue-不要使用这个了，最近发现会造成野指针，具体原因不明。"><a href="#方法1-NSValue-不要使用这个了，最近发现会造成野指针，具体原因不明。" class="headerlink" title="方法1 NSValue 不要使用这个了，最近发现会造成野指针，具体原因不明。"></a>方法1 <del>NSValue</del> 不要使用这个了，最近发现会造成野指针，具体原因不明。</h2><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">NSValue</span> *value = [<span class="built_in">NSValue</span> valueWithNonretainedObject:myObj];</span><br><span class="line">[array addObject:value];</span><br><span class="line"></span><br><span class="line">value.nonretainedObjectValue</span><br></pre></td></tr></table></figure><h2 id="方法2-NSPointerArray"><a href="#方法2-NSPointerArray" class="headerlink" title="方法2 NSPointerArray"></a>方法2 NSPointerArray</h2>参见：<a href="http://blog.csdn.net/jeffasd/article/details/60774974">http://blog.csdn.net/jeffasd/article/details/60774974</a><h2 id="方法3-Bridge"><a href="#方法3-Bridge" class="headerlink" title="方法3 Bridge"></a>方法3 Bridge</h2>增加一个中间层<figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">@interface</span> <span class="title">DelegateBridge</span>: <span class="title">NSObject</span> &lt;<span class="title">aDelegate</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">@property</span> (<span class="keyword">nonatomic</span>, <span class="keyword">assign</span>) <span class="keyword">id</span> &lt;aDelegate&gt;delegate;</span><br><span class="line"></span><br><span class="line">- (<span class="keyword">instancetype</span>)initWithDelegate:(<span class="keyword">id</span>&lt;aDelegate&gt;)delegate;</span><br><span class="line"></span><br><span class="line"><span class="keyword">@end</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">@implementation</span> <span class="title">DelegateBridge</span></span></span><br><span class="line"></span><br><span class="line">- (<span class="keyword">instancetype</span>)initWithDelegate:(<span class="keyword">id</span>&lt;aDelegate&gt;)delegate;</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">self</span> = [<span class="keyword">super</span> init];</span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">self</span>) &#123;</span><br><span class="line">        <span class="keyword">self</span>.delegate = delegate;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">self</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (<span class="keyword">void</span>)delegateMethod &#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">self</span>.delegate &amp;&amp; [<span class="keyword">self</span>.delegate respondsToSelector:<span class="keyword">@selector</span>(delegateMethod:)]) &#123;</span><br><span class="line">        [<span class="keyword">self</span>.delegate delegateMethod:aMessages];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">@end</span></span><br></pre></td></tr></table></figure><code>addDelegate()</code>的方法改为：<figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">- (<span class="keyword">void</span>)addDelegate:(<span class="keyword">id</span>&lt;aDelegate&gt;)delegate</span><br><span class="line">&#123;</span><br><span class="line">    DelegateBridge *bridge = [[DelegateBridge alloc] initWithDelegate:delegate];</span><br><span class="line">    [_delegates addObject:bridge];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ol></li></ol>]]></content>
      
      
      
        <tags>
            
            <tag> iOS </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Scheme以及微信、支付宝等第三方功能的实现</title>
      <link href="iOS-Scheme-Theory-And-Practice/"/>
      <url>iOS-Scheme-Theory-And-Practice/</url>
      
        <content type="html"><![CDATA[<p>通过配置plist文件中的scheme完成在app中接入微信、支付宝、微博等第三方平台并且能够来回跳转。</p><a id="more"></a><h2 id="理论"><a href="#理论" class="headerlink" title="理论"></a>理论</h2><p>在Apple的文档中，scheme在URL相关的内容中出现过，比如：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">This property contains the scheme. Any percent-encoded characters are not unescaped. For example, in the URL &#96;http:&#x2F;&#x2F;www.example.com&#x2F;index.html&#96; , the scheme is &#96;http&#96; .</span><br><span class="line">The full URL is the concatenation of the scheme, a colon ( &#96;:&#96; ), and the value of &#96;resourceSpecifier&#96; .</span><br></pre></td></tr></table></figure><p>紧接着这一段，有如下说明：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Note</span><br><span class="line">The term “protocol” is also sometimes used when talking about network-based URL schemes. However, not all URL schemes are networking protocols—data:&#x2F;&#x2F; URLs, for example.</span><br></pre></td></tr></table></figure><p>详情点击<a href="https://developer.apple.com/documentation/foundation/nsurl/1413437-scheme">这里</a>。可以看出，scheme是URL中 <strong>:</strong> 之前的部分。<br>在iOS/macOS/WatchOS 2中，可以利用scheme来标记APP并且通过它进行一些简单的通信。</p><h4 id="scheme的使用"><a href="#scheme的使用" class="headerlink" title="scheme的使用"></a>scheme的使用</h4><ol><li>设置scheme<br>Xcode项目的info.plist中增加URL types，这是一个数组，里面的每一项都是一个字典，默认只有URL Identifier——标记URL types中的某一个item，在这里可以添加URL Schemes。比如添加一个”test”</li><li>使用scheme，添加了scheme以后，重新run项目。<ol><li>可以在Safari中输入添加的scheme，然后就可以跳转到刚才的APP中了。</li><li>通过<code>UIApplication.shared.openURL</code>来进行APP间的跳转。如果是iOS9.0之后，需要先在info.plist中添加<a href="https://developer.apple.com/library/content/documentation/General/Reference/InfoPlistKeyReference/Articles/LaunchServicesKeys.html#//apple_ref/doc/uid/TP40009250-SW14">LSApplicationQueriesSchemes</a>，然后把要打开的scheme添加到里面。<br><img src="http://upload-images.jianshu.io/upload_images/424855-690eea9c590127f6.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240"></li></ol></li></ol><h2 id="高级用法"><a href="#高级用法" class="headerlink" title="高级用法"></a>高级用法</h2><ol><li>当APP被其他APP通过scheme调起的时候，可以通过<code>func application(_ app: UIApplication, open url: URL, options: [UIApplicationOpenURLOptionsKey : Any] = [:]) -&gt; Bool</code>方法从url参数中获取到当前启动这个APP的完整URL，还可以通过options获取到其他APP的**<em>Bundle Identifier**</em></li><li>在Safari中输入URL或者通过openURL来调起APP的时候，除了输入[scheme]://之外，还可以在后面带上一些内容，比如：<code>[scheme]://aaa=1?bbb=52</code></li></ol><h2 id="实战"><a href="#实战" class="headerlink" title="实战"></a>实战</h2><p>微信、支付宝、微博等应用的第三方登录、支付、分享功能，都是通过scheme来实现的。下面我们用微信的登录为例，来讲解一下scheme的使用过程。<br>要使用微信的授权登录功能，首先要去微信开放平台创建一个应用，需要我们填写应用名称、icon和Bundle Identifier，之后微信会把应用的AppId和AppSecret给我们。然后根据AppID集成微信的SDK，并且在URL types里面添加一个以appid为scheme的item。到这里，微信的分享功能就集成完成了。那么，每一步都在做什么呢？<br><img src="http://upload-images.jianshu.io/upload_images/424855-c63aa2111fe7ca58.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="微信授权过程.jpg"><br>其中，第3步中是否到服务器验证应该可以通过抓包来看到，但是我懒了，没有做。也不影响整体的流程。  </p>]]></content>
      
      
      
        <tags>
            
            <tag> iOS </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>

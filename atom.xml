<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>编程学堂</title>
  
  
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://www.iosprogrammer.tech/"/>
  <updated>2021-01-13T10:48:42.226Z</updated>
  <id>http://www.iosprogrammer.tech/</id>
  
  <author>
    <name>Davis</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>向hexo博客中插入数学公式</title>
    <link href="http://www.iosprogrammer.tech/insert-math-formula-to-hexo/"/>
    <id>http://www.iosprogrammer.tech/insert-math-formula-to-hexo/</id>
    <published>2021-01-13T10:43:22.000Z</published>
    <updated>2021-01-13T10:48:42.226Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>原生hexo并不支持数学公式，需要安装插件<a href="https://www.mathjax.org/" target="_blank" rel="noopener">mathJax</a>。<a href="https://www.mathjax.org/" target="_blank" rel="noopener">mathJax</a>是一款运行于浏览器中的开源数学符号渲染引擎，使用 mathJax 可以方便的在浏览器中嵌入数学公式。mathJax 使用网络字体产生高质量的排版，因此可适应各种分辨率，它的显示是基于文本的而非图片，因此显示效果更好。这些公式可以被搜索引擎使用，因此公式里的符号一样可以被搜索引擎检索到。</p></blockquote><h2 id="安装与配置"><a href="#安装与配置" class="headerlink" title="安装与配置"></a>安装与配置</h2><ol><li><code>$ npm install hexo-math --save</code><br>在站点配置文件 _config.yml 中添加：<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">math:</span><br><span class="line">  engine: &apos;mathjax&apos; # or &apos;katex&apos;</span><br><span class="line">  mathjax:</span><br><span class="line">    # src: custom_mathjax_source</span><br><span class="line">    config:</span><br><span class="line">      # MathJax config</span><br></pre></td></tr></table></figure></li></ol><p>在 next 主题配置文件中 themes/next-theme/_config.yml 中将 mathJax 设为 true:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"># MathJax Support</span><br><span class="line">mathjax:</span><br><span class="line">  enable: true</span><br><span class="line">  per_page: false</span><br><span class="line">  cdn: //cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MM</span><br></pre></td></tr></table></figure></p><h2 id="使用"><a href="#使用" class="headerlink" title="使用"></a>使用</h2><p>公式插入格式<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$数学公式$ 行内 不独占一行</span><br><span class="line">$$数学公式$$ 行间 独占一行</span><br></pre></td></tr></table></figure></p><p>例如<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$f(x)=ax+b$</span><br></pre></td></tr></table></figure></p><p>显示效果为：f(x)=ax+b<br>如果是行间则使用：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$$f(x)=ax+b$$</span><br></pre></td></tr></table></figure></p><p>显示效果为：<br>$$f(x)=ax+b$$</p><h3 id="语法格式"><a href="#语法格式" class="headerlink" title="语法格式"></a>语法格式</h3><h4 id="上标与下标"><a href="#上标与下标" class="headerlink" title="上标与下标"></a>上标与下标</h4><p>使用 ^ 表示上标，使用 _ 表示下标，如果上下标的内容多于一个字符，可以使用大括号括起来：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$$f(x) = a_1x^n + a_2x^&#123;n-1&#125; + a_3x^&#123;n-2&#125;$$</span><br></pre></td></tr></table></figure></p><p>显示效果为：<br>$$f(x) = a_1x^n + a_2x^{n-1} + a_3x^{n-2}$$<br>如果左右两边都有上下标可以使用 \sideset 语法：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$$\sideset&#123;^n_k&#125;&#123;^x_y&#125;a$$</span><br></pre></td></tr></table></figure></p><p>显示效果为：<br>$$\sideset{^n_k}{^x_y}a$$</p><h4 id="括号"><a href="#括号" class="headerlink" title="括号"></a>括号</h4><p>在 markdown 语法中，\, $, {, }, _都是有特殊含义的，所以需要加\转义。小括号与方括号可以使用原始的() [] 大括号需要转义\也可以使用\lbrace和 \rbrace<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">\&#123;x*y\&#125;</span><br><span class="line">\lbrace x*y \rbrace</span><br></pre></td></tr></table></figure></p><p>显示效果为：{x*y}<br>原始符号不会随着公式大小自动缩放，需要使用 \left 和 \right 来实现自动缩放：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$$\left \lbrace \sum_&#123;i=0&#125;^n i^3 = \frac&#123;(n^2+n)(n+6)&#125;&#123;9&#125; \right \rbrace$$</span><br></pre></td></tr></table></figure></p><p>效果：$$\left \lbrace \sum_{i=0}^n i^3 = \frac{(n^2+n)(n+6)}{9} \right \rbrace$$<br>不使用\left 和 \right的效果：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$$ \lbrace \sum_&#123;i=0&#125;^n i^3 = \frac&#123;(n^2+n)(n+6)&#125;&#123;9&#125;  \rbrace$$</span><br></pre></td></tr></table></figure></p><p>$$ \lbrace \sum_{i=0}^n i^3 = \frac{(n^2+n)(n+6)}{9}  \rbrace$$</p><h4 id="分数与开方"><a href="#分数与开方" class="headerlink" title="分数与开方"></a>分数与开方</h4><p>可以使用\frac 或者 \over 实现分数的显示：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$\frac xy$</span><br><span class="line">$ x+3 \over y+5 $</span><br></pre></td></tr></table></figure></p><p>分别显示为：$\frac xy$和$ x+3 \over y+5 $<br>开方使用\sqrt:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ \sqrt&#123;x^5&#125; $</span><br><span class="line">$ \sqrt[3]&#123;\frac xy&#125; $</span><br></pre></td></tr></table></figure></p><p>分别显示为：$ \sqrt{x^5} $和$ \sqrt[3]{\frac xy} $</p><h4 id="求和与积分"><a href="#求和与积分" class="headerlink" title="求和与积分"></a>求和与积分</h4><p>求和使用\sum,可加上下标，积分使用\int可加上下限，双重积分用\iint:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$ \sum_&#123;i=0&#125;^n $</span><br><span class="line">$ \int_1^\infty $</span><br><span class="line">$ \iint_1^\infty $</span><br></pre></td></tr></table></figure></p><p>分别显示为：$ \sum_{i=0}^n $和$ \int_1^\infty $以及$ \iint_1^\infty $</p><h4 id="极限"><a href="#极限" class="headerlink" title="极限"></a>极限</h4><p>极限使用\lim:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ \lim_&#123;x \to 0&#125; $</span><br></pre></td></tr></table></figure></p><p>显示为：$ \lim_{x \to 0} $</p><h4 id="表格和矩阵"><a href="#表格和矩阵" class="headerlink" title="表格和矩阵"></a>表格和矩阵</h4><p>表格样式lcr表示居中，|加入一条竖线，\hline表示行间横线，列之间用&amp;分隔，行之间用\分隔<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">$$\begin&#123;array&#125;&#123;c|lcr&#125;</span><br><span class="line">n &amp; \text&#123;Left&#125; &amp; \text&#123;Center&#125; &amp; \text&#123;Right&#125; \\\\</span><br><span class="line">\hline</span><br><span class="line">1 &amp; 1.97 &amp; 5 &amp; 12 \\\\</span><br><span class="line">2 &amp; -11 &amp; 19 &amp; -80 \\\\</span><br><span class="line">3 &amp; 70 &amp; 209 &amp; 1+i \\\\</span><br><span class="line">\end&#123;array&#125;$$</span><br></pre></td></tr></table></figure></p><p>显示效果为：<br>$$\begin{array}{c|lcr}<br>n &amp; \text{Left} &amp; \text{Center} &amp; \text{Right} \\<br>\hline<br>1 &amp; 1.97 &amp; 5 &amp; 12 \\<br>2 &amp; -11 &amp; 19 &amp; -80 \\<br>3 &amp; 70 &amp; 209 &amp; 1+i \\<br>\end{array}$$<br>表格的插入也可以使用以下方式：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">名称|说明</span><br><span class="line">---|---|---</span><br><span class="line">temperature|  室内温度</span><br><span class="line">set temperature|  设定温度</span><br><span class="line">height|  室内高度</span><br></pre></td></tr></table></figure></p><p>显示效果为：<br>名称|说明<br>—|—|—<br>temperature|  室内温度<br>set temperature|  设定温度<br>height|  室内高度<br>矩阵显示和表格很相似<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">$$\left[</span><br><span class="line">\begin&#123;matrix&#125;</span><br><span class="line">V_A \\\\</span><br><span class="line">V_B \\\\</span><br><span class="line">V_C \\\\</span><br><span class="line">\end&#123;matrix&#125;</span><br><span class="line">\right] =</span><br><span class="line">\left[</span><br><span class="line">\begin&#123;matrix&#125;</span><br><span class="line">1 &amp; 0 &amp; L \\\\</span><br><span class="line">-cosψ &amp; sinψ &amp; L \\\\</span><br><span class="line">-cosψ &amp; -sinψ &amp; L</span><br><span class="line">\end&#123;matrix&#125;</span><br><span class="line">\right]</span><br><span class="line">\left[</span><br><span class="line">\begin&#123;matrix&#125;</span><br><span class="line">V_x \\\\</span><br><span class="line">V_y \\\\</span><br><span class="line">W \\\\</span><br><span class="line">\end&#123;matrix&#125;</span><br><span class="line">\right] $$</span><br></pre></td></tr></table></figure></p><p>显示效果为：<br>$$\left[<br>\begin{matrix}<br>V_A \\<br>V_B \\<br>V_C \\<br>\end{matrix}<br>\right] =<br>\left[<br>\begin{matrix}<br>1 &amp; 0 &amp; L \\<br>-cosψ &amp; sinψ &amp; L \\<br>-cosψ &amp; -sinψ &amp; L<br>\end{matrix}<br>\right]<br>\left[<br>\begin{matrix}<br>V_x \\<br>V_y \\<br>W \\<br>\end{matrix}<br>\right] $$</p><hr><p>$\color{OrangeRed}{其他热门文章}$</p><ul><li><a href="http://www.iosprogrammer.tech/Hexo-Add-GZH-EveryPage//">Hexo文章末尾添加自定义内容给引流</a></li><li><a href="http://www.iosprogrammer.tech/deploy-hexo-to-gitlab/">部署Hexo到gitlab并自定义域名</a></li><li><a href="http://www.iosprogrammer.tech/Deploy-Hexo-Aliyun/">部署Hexo到自己的阿里云服务器</a></li></ul><hr>]]></content>
    
    <summary type="html">
    
      
      
        &lt;blockquote&gt;
&lt;p&gt;原生hexo并不支持数学公式，需要安装插件&lt;a href=&quot;https://www.mathjax.org/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;mathJax&lt;/a&gt;。&lt;a href=&quot;https://www.math
      
    
    </summary>
    
      <category term="其他" scheme="http://www.iosprogrammer.tech/categories/%E5%85%B6%E4%BB%96/"/>
    
    
  </entry>
  
  <entry>
    <title>一图搞懂Cmake、GCC、Make、Ninja是什么以及他们的关系</title>
    <link href="http://www.iosprogrammer.tech/relation-cmake-gcc-ninja/"/>
    <id>http://www.iosprogrammer.tech/relation-cmake-gcc-ninja/</id>
    <published>2021-01-12T12:03:17.755Z</published>
    <updated>2021-01-13T10:52:47.306Z</updated>
    
    <content type="html"><![CDATA[<p><img src="../images/cmake-make-ninja-gcc.png" alt></p><h3 id="命令与规则"><a href="#命令与规则" class="headerlink" title="命令与规则"></a>命令与规则</h3><blockquote><p>图中粉色的内容cmake、make、ninja、gcc都是命令也就是可执行程序<br>黑色内容本质上是文本文件，只不过是根据一定规则编写的<br>文件对应的命令可以解析这些规则并执行相应的命令</p></blockquote><p>比如，cmake程序对应的是CMakeLists.txt文件，CMakeLists.txt的编写是遵循一定的语法规则的，类似于Java、C语言等，但是它更简单，更类似于一种脚本语言。</p><p>当执行cmake程序（或者叫做调用cmake命令）时，cmake会去读取CMakeLists.txt的内容并按照约定的语法规则进行解析，然后cmake会根据CMakeLists.txt中的指示去做一些动作，比如操作文件、调用系统命令等等。</p><p>这就好比厨师做菜，厨师根据菜谱的指示拿着鸡鱼肉蛋和厨具做菜，厨师就相当于cmake程序，而菜谱就是CMakeLists.txt.</p><h3 id="为什么会有这样的设计"><a href="#为什么会有这样的设计" class="headerlink" title="为什么会有这样的设计"></a>为什么会有这样的设计</h3><p>最初要编译C语言需要使用一个<a href="https://zh.wikipedia.org/wiki/GCC" target="_blank" rel="noopener">扩增自由Pastel语言编写的编译器</a>，后来为了使C语言具有可移植性并增强编译器的性能和编译速度，<strong>GCC营运而生</strong>。从1987年开始GCC获得了不断的增强，到现在可以编译非常多的语言，并且支持市面上几乎所有的CPU架构。</p><p>随着项目的增加和复杂度的提高以及对编译速度的需求，单独使用GCC逐渐不能满足了。这时候需要一个工具来解放程序员执行GCC命令的工作，<strong><a href="https://zh.wikipedia.org/zh-hans/Make" target="_blank" rel="noopener">make和MakeFile应运而生</a></strong>。通过按照一定规则编写的makefile文件可以很好的应对大型项目，而且经过一次编写之后就可以通过一条<code>make</code>指令重复使用，简直就是码农的福音。</p><p>但是，经过若干年的发展，make和makefile逐渐变的臃肿，越来越无法满足用户对速度的要求。为了提高项目的编译速度，<strong><a href="https://ninja-build.org" target="_blank" rel="noopener">ninja出现了</a></strong>，起初它只是用来编译Google Chrome浏览器，后来由于它卓越的性能被用到了其他项目中。相信有一天ninja也会和make一样被时代抛弃。。。</p><p>make和ninja虽然解决了每次编译都要重新执行GCC的痛苦，可是它们也需要编写自己的文件，而且由于不同计算机指令集的命令不同，makefile和build.ninja文件也要区分CPU架构，这就造成一个跨平台的应用程序进行平台移植的时候要分别编写适用于对应平台的文件。</p><p>为了能够自动生成对应平台文件，<strong><a href="https://cmake.org" target="_blank" rel="noopener">cmake出现了</a></strong>。cmake是一个与平台无关的工具，cmake执行通过按照一定规则编写的CMakeLists.txt后，会生成对应平台的makefile或者build.ninja，之后再使用make或者ninja就可以生成对应平台的二进制可执行文件了。</p><p>至此，我们对编译工具家族有了一个自下而上的了解，这也是代码编译过程中用到的工具链。虽然现在开发大多使用IDE，很少接触到这些知识，不过作为了解还是很有意义的。</p><p>也许未来有一天，cmake也会和gcc一样成为背后英雄不为人所知，谁知道呢。。。</p><p><strong>想了解更多内容关注公众号【iOS开发栈】</strong></p><hr><p>$\color{OrangeRed}{其他热门文章}$</p><ul><li><a href="http://www.iosprogrammer.tech/WebSocket-And-SocketRocket-Source-Analysis/">WebSocket简介和SocketRocket源码分析</a></li><li><a href="http://www.iosprogrammer.tech/Deploy-Hexo-Aliyun/">部署Hexo到自己的服务器</a></li><li><a href="http://www.iosprogrammer.tech/Using-Instruments-To-Oprimize-CPU-Performance/">使用Instruments工具测试CPU与常见对CPU占用过高的操作</a></li></ul><hr>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;&lt;img src=&quot;../images/cmake-make-ninja-gcc.png&quot; alt&gt;&lt;/p&gt;
&lt;h3 id=&quot;命令与规则&quot;&gt;&lt;a href=&quot;#命令与规则&quot; class=&quot;headerlink&quot; title=&quot;命令与规则&quot;&gt;&lt;/a&gt;命令与规则&lt;/h3&gt;&lt;bl
      
    
    </summary>
    
      <category term="其他" scheme="http://www.iosprogrammer.tech/categories/%E5%85%B6%E4%BB%96/"/>
    
    
  </entry>
  
  <entry>
    <title>什么是Content Hugging Priorities/Content Compression Resistance Priorities</title>
    <link href="http://www.iosprogrammer.tech/What-is-Content-Hugging-Priorities-Content-Compression-Resistance-Priorities/"/>
    <id>http://www.iosprogrammer.tech/What-is-Content-Hugging-Priorities-Content-Compression-Resistance-Priorities/</id>
    <published>2021-01-06T07:00:19.000Z</published>
    <updated>2021-01-07T12:19:28.575Z</updated>
    
    <content type="html"><![CDATA[<p>这两个优先级属性都是用在iOS开发时Auto Layout布局中的。</p><h3 id="Content-Hugging-Priorities"><a href="#Content-Hugging-Priorities" class="headerlink" title="Content Hugging Priorities"></a>Content Hugging Priorities</h3><p><strong>Content Hugging Priorities：在Auto Layout中，当子视图不足以填充满空间时，优先满足此属性值较大的子视图的内容展示，而拉伸属性值较低的子视图。</strong></p><p>假设有这样一种情况，两个水平排列的UILabel中分别显示“编程学堂”和“www.iosprogrammer.tech“，给它们加上5个约束，其中2、3、5是水平约束，假设这3个水平约束的值都是10.</p><p>现在两个UILabel里面文字内容所占大小加上3个水平约束的值仍然小于（&lt;）父视图的宽度。此时会发现storyboard中有报错，但是我们仍然可以正常运行项目并看到展示结果。<br><img src="../images/hugging-prority-1.png" alt><br><img src="../images/hugging-prority-2.png" alt><br><img src="../images/hugging-prority-3.png" alt></p><p>我们可以看到“www.iosprogrammer.tech“所在label所占的空间变大了。此时设置这个label的Content Hugging Priorities为750。</p><p><img src="../images/hugging-prority-4.png" alt><br><img src="../images/hugging-prority-5.png" alt></p><p>“www.iosprogrammer.tech“所在label刚好满足展示内容，而“编程学堂”所在label所占空间变大了。</p><p>这也就是Content Hugging Priorities的作用，控制当内容不足以填充满空间时，优先满足此属性值较大的子view的内容展示，而拉伸属性值较低的子view。</p><h3 id="Content-Compression-Resistance-Priorities"><a href="#Content-Compression-Resistance-Priorities" class="headerlink" title="Content Compression Resistance Priorities"></a>Content Compression Resistance Priorities</h3><p><strong>Content Compression Resistance Priorities：在Auto Layout中，当子视图所需的内容超出父视图的空间时，优先展示此值较大的子视图，而省略压缩此值较小的子视图。</strong></p><p>假设有这样一种情况，两个水平排列的UILabel中分别显示“编程学堂专注于提高编程能力”和“编程学堂的官方网站是www.iosprogrammer.tech“，给它们加上5个约束，其中2、3、5是水平约束，假设这3个水平约束的值都是10.</p><p>现在两个UILabel里面文字内容所占大小超过了父视图的宽度。此时会发现storyboard中有报错，但是我们仍然可以正常运行项目并看到展示结果。<br><img src="../images/hugging-prority-6.png" alt><br><img src="../images/hugging-prority-7.png" alt><br><img src="../images/hugging-prority-8.png" alt></p><p>第一个Label被压缩了，里面的文字被省略了；第二个label正常展示了出来。此时我们把第一个label的Content Compression Resistance Priorities设置到大于第二个label。</p><p><img src="../images/hugging-prority-9.png" alt><br><img src="../images/hugging-prority-10.png" alt></p><p>可以看到第二个label被压缩了，第一个label正常展示了出来。</p><p><strong>Content Compression Resistance Priorities：在Auto Layout中，当子视图所需的内容超出父视图的空间时，优先展示此值较大的子视图，而省略压缩此值较小的子视图。</strong></p><p><a href="https://medium.com/@dineshk1389/content-hugging-and-compression-resistance-in-ios-35a0e8f19118" target="_blank" rel="noopener">参考文章</a></p><hr><p>$\color{OrangeRed}{其他热门文章}$</p><ul><li><a href="https://www.iosprogrammer.tech/WebSocket-And-SocketRocket-Source-Analysis/">WebSocket简介和SocketRocket源码分析</a></li><li><a href="https://www.iosprogrammer.tech/xib-color-different-with-hard-code/">xib和代码设置颜色不同的解决方法及其原理</a></li><li><a href="https://www.iosprogrammer.tech/UIStackView-Advanced-Knowledge/">UIStackView的正确使用姿势（最新最全、配视频教程）</a></li></ul><hr>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;这两个优先级属性都是用在iOS开发时Auto Layout布局中的。&lt;/p&gt;
&lt;h3 id=&quot;Content-Hugging-Priorities&quot;&gt;&lt;a href=&quot;#Content-Hugging-Priorities&quot; class=&quot;headerlink&quot; title
      
    
    </summary>
    
      <category term="iOS" scheme="http://www.iosprogrammer.tech/categories/iOS/"/>
    
    
  </entry>
  
  <entry>
    <title>UIStackView的正确使用姿势（最新最全、配视频教程）</title>
    <link href="http://www.iosprogrammer.tech/UIStackView-Advanced-Knowledge/"/>
    <id>http://www.iosprogrammer.tech/UIStackView-Advanced-Knowledge/</id>
    <published>2021-01-01T08:28:23.000Z</published>
    <updated>2021-01-07T12:19:28.575Z</updated>
    
    <content type="html"><![CDATA[<p>UIStackView在iOS9之后开始使用，继承自UIView，用来管理在它内部的views，<text style="color:#1E90FF">但是并不会被渲染出来</text>，经过我在工作中的使用总结，它确实可以很大程度提高界面开发效率，每一个iOS开发者都应该熟练掌握UIStackView的使用。</p><p>本文将分为基础和进阶两部分来讲解UIStackView，因此如果已经一定程度的使用过UIStackView，那么可以直接跳转到进阶部分。</p><h3 id="UIStackView基础入门知识"><a href="#UIStackView基础入门知识" class="headerlink" title="UIStackView基础入门知识"></a>UIStackView基础入门知识</h3><p>UIStackview的主要作用是管理<code>arrangedSubviews</code>数组中的view的布局，管理数组的有三个方法</p><pre><code>- addArrangedSubview:- removeArrangedSubview:- insertArrangedSubview:atIndex:</code></pre><p>UIStackView中arrangedSubview的布局主要是使用<code>UILayoutConstraintAxis</code> <code>UIStackViewDistribution</code> <code>UIStackViewAlignment</code> <code>spacing</code> 几个属性。</p><ol><li><code>UILayoutConstraintAxis</code> - 确定arrangedSubviews的排列方向，分为Horizontal和Vertical</li><li><p><code>UIStackViewDistribution</code> - arrangedSubviews<strong>在排列方向</strong>的布局方式</p><ol><li>UIStackViewDistributionFill 把UIStackView的空间填充满，对于有intrinsic content size的UIView（UILabel、UIButton、UIImageView、UIControl）需要通过设置Size Inspector中的<a href="https://www.iosprogrammer.tech/What-is-Content-Hugging-Priorities-Content-Compression-Resistance-Priorities/">Content Hugging Property</a>来决定优先满足哪个view的contrinsicSize，如果property相同则会默认选择第一个。</li><li>UIStackViewDistributionFillEqually arrangedSubviews平分UIStackView 排列方向上除了spacing的空间</li><li>UIStackViewDistributionFillProportionally 按比例分配每个arrangedSubview所占大小，按照每个arrangedSubview的intrinsic content size的比例</li><li>UIStackViewDistributionEqualSpacing 当arrangedSubviews不能填满时，空白区域会平均分配，而不会自动拉伸Hugging Property较低的view；如果arrangedSubviews放不开时，会优先保证<a href="https://www.iosprogrammer.tech/What-is-Content-Hugging-Priorities-Content-Compression-Resistance-Priorities/">compression resistance priority</a>较高的view内容能够完全展示，priority相同时会默认保证第一个view。</li><li>UIStackViewDistributionEqualCentering view中心之间的spacing相等。当spacing值过大，无法满足所有view都能正常展示，会优先保证compression resistance priority较高的view内容能够完全展示，priority相同时会默认保证第一个view。</li></ol></li><li><p>UIStackViewAlignment - arrangedSubviews<strong>垂直于排列方向</strong>的布局方式</p><ol><li>UIStackViewAlignmentFill 完全填充</li><li>UIStackViewAlignmentLeading/UIStackViewAlignmentTop 靠上/右</li><li>UIStackViewAlignmentTrailing/UIStackViewAlignmentBottom 靠下/左</li><li>UIStackViewAlignmentFirstBaseline/UIStackViewAlignmentLastBaseline 文字基线 下/上</li></ol></li><li>spacing - arrangedSubview的间距。对于<code>UIStackViewDistributionFillxxx</code>就是准确的距离，对于UIStackViewDistributionEqualSpacing、UIStackViewDistributionEqualCentering 是最小距离，<strong>使用负数view会覆盖</strong></li></ol><p>掌握了上面的基础知识后基本就可以上手使用UIStackView了。</p><h3 id="UIStackView进阶知识"><a href="#UIStackView进阶知识" class="headerlink" title="UIStackView进阶知识"></a>UIStackView进阶知识</h3><p>Q1. 在UIStackView中可以对子view使用约束吗？<br>A1. UIStackView是基于约束来确定里面arrangedSubview的布局的，手动给某一个arrangedSubview指定约束时，会优先满足指定的约束，不过因为系统也会根据我们设置的属性添加约束，所以要当心会出现约束冲突。</p><p>Q2. UIStackView.arrangedViews 和 UIStackView.subViews的关系？<br>A2. arragedViews是subViews的子集 </p><ol><li>UIStackView addSubview 并不会添加到arrangedSubviews中；</li><li>当向arrangedSubviews中添加view时会自动添加到subviews中 </li><li>把一个只在subview而不在arrangedview中的view移除时也不会影响到arrangedview </li><li>一个view既在subviews中又在arrangedviews中时，当把它从subviews中移除，也会自动从arragedviews中移除，反之则不然</li></ol><p>Q3. UIStackView设置了背景色为什么显示不出来？<br>A3. UIStackView虽然是UIView的子类，但是它并不会被渲染，所以设置背景色并没有什么显示，但是设置圆角是有作用的。</p><p>Q4. UIStackView怎么设置某一个子view和后面view的距离？<br>A4. 在iOS11之后UIStackView新加了方法可以设置<code>setCustomSpacing:afterView</code></p><iframe src="//player.bilibili.com/player.html?bvid=BV1wz4y1674t&page=1" scrolling="no" border="0" frameborder="no" framespacing="0" allowfullscreen="true" width="100%" height="300px"> </iframe><hr><p>$\color{OrangeRed}{其他热门文章}$</p><ul><li><a href="https://www.iosprogrammer.tech/WebSocket-And-SocketRocket-Source-Analysis/">WebSocket简介和SocketRocket源码分析</a></li><li><a href="https://www.iosprogrammer.tech/xib-color-different-with-hard-code/">xib和代码设置颜色不同的解决方法及其原理</a></li><li><a href="https://www.iosprogrammer.tech/Using-Instruments-To-Oprimize-CPU-Performance/">使用Instruments工具测试CPU与常见对CPU占用过高的操作</a></li></ul><hr>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;UIStackView在iOS9之后开始使用，继承自UIView，用来管理在它内部的views，&lt;text style=&quot;color:#1E90FF&quot;&gt;但是并不会被渲染出来&lt;/text&gt;，经过我在工作中的使用总结，它确实可以很大程度提高界面开发效率，每一个iOS开发者都应该
      
    
    </summary>
    
      <category term="iOS" scheme="http://www.iosprogrammer.tech/categories/iOS/"/>
    
    
  </entry>
  
  <entry>
    <title>iOS开发xib和代码设置颜色不同的解决方法及其原理（深度好文）</title>
    <link href="http://www.iosprogrammer.tech/xib-color-different-with-hard-code/"/>
    <id>http://www.iosprogrammer.tech/xib-color-different-with-hard-code/</id>
    <published>2020-12-18T03:40:37.000Z</published>
    <updated>2020-12-18T07:15:11.805Z</updated>
    
    <content type="html"><![CDATA[<p>本文主要包括两部分，其一是解决xib设置颜色有偏差的问题，其二是聊一下颜色的一些基础知识。</p><h2 id="xib和代码设置颜色有偏差的原因"><a href="#xib和代码设置颜色有偏差的原因" class="headerlink" title="xib和代码设置颜色有偏差的原因"></a>xib和代码设置颜色有偏差的原因</h2><p>在开发iOS app的过程中我们都是按照设计同学给出的标注来做的，而UI同学在作图时使用到的工具就会有“<strong>颜色配置文件（Color Profile）</strong>”。（下面有颜色配置文件的说明）<br><img src="../images/ps-color-profile.png" alt="PS中的颜色配置文件"><br>从上图可以看出，ps默认的颜色配置文件是sRGB，因此设计给我们的图都是以sRGB为准的。<br>但是在Xcode的ib相关文件中设置颜色时，默认的颜色配置文件是Generic RGB的。<br><img src="../images/xcode-xib-colors.png" alt="Xcode-colors"><br>因此，如果我们直接按照sRGB标的色值在Generic RGB的配置下进行设置就会出现色差了。<br>通过下面的GIF可以更直观的看到这种差异<br><img src="../images/record.gif" alt><br>而代码设置颜色时默认是采用的和photoshop一样的sRGB，也是和xib的Generic RGB不相同的，所以代码设置的颜色和UI同学提供的是一样的，而xib中是和他们两个不一样的。</p><h2 id="xib设置颜色和代码有差异的问题解决方案"><a href="#xib设置颜色和代码有差异的问题解决方案" class="headerlink" title="xib设置颜色和代码有差异的问题解决方案"></a>xib设置颜色和代码有差异的问题解决方案</h2><p>解决方案有两种，一种是把sRGB的色值转化成Generic RGB之后再进行设置，另一种是把配置改成sRGB的再进行设置。<br>这里用到的不同颜色配置之间进行转换的工具可以用mac自带的ColorSync Utility</p><p><center class="half" style="display:flex;margin-left:10%"><br>    <img src="../images/colorsyncutilityicon.png" width="200"><img src="../images/colorsyncinterface.png" width="300"><br></center></p><h2 id="xib和代码设置的颜色有差异的原理分析"><a href="#xib和代码设置的颜色有差异的原理分析" class="headerlink" title="xib和代码设置的颜色有差异的原理分析"></a>xib和代码设置的颜色有差异的原理分析</h2><p>上面说到了xib默认的颜色配置和ps、代码都是不同的，说到颜色配置（Color Profile）就不得不说颜色模型（Color Model）和颜色空间（Color Space）。<br>众所周知，计算机、摄像机、打印机等数字设备中只能认识0和1（不然它们也不会叫数字设备了🐶），因此为了把自然界中的五颜六色在数字设备中展示出来，<strong>颜色转换成数字的算法（公式）—— 颜色模型</strong> 就出现了。<br>现在被广泛使用的颜色模型有RGB、CMYK、CIELAB等，其中RGB主要用在摄像机、显示器等领域，CMYK主要用在打印机领域，具体内容可以查看<a href="https://www.dpbestflow.org/color/color-space-and-color-profiles" target="_blank" rel="noopener">这篇文章</a>。<br>有了算法，就要有<strong>颜色模型具体的算法实现——颜色空间</strong>。<br>之所以叫空间是因为每一个具体的颜色空间都有一个范围<br><img src="../image/../images/v2-374053ce809551b3eeef09046f48b074_1440w.jpg" alt><br>正如上图所示，颜色空间都是有不同的范围的，而不同范围的颜色空间进行转换的时候就会有损失，也就会造成<a href="https://zhuanlan.zhihu.com/p/72530732" target="_blank" rel="noopener">色差</a>。<br><img src="../images/v2-53ebd97b57e169f8b395766d580a1ea9_1440w.jpg" alt><br>颜色模型可以理解为一个概念、理论，颜色空间是对颜色模型的一次具象描述，但是它还不能被计算机所理解。<strong>颜色配置正是能够直接被数字设备拿来用的具体文件</strong>。<br>在Mac电脑的ColorSync Utility应用中可以看到下面这些颜色配置<br><img src="../images/colorsyncprofiles.png" alt></p><p>至此，我们把xib和代码设置颜色有偏差的现象彻底解决了，总结一句话就是：</p><blockquote><p>不同的颜色配置之间转换时会造成色差，而代码和xib进行颜色设置时使用了不同的颜色配置文件，才最终导致了同样的色值的最终表现不同。</p></blockquote><hr><p>$\color{OrangeRed}{其他热门文章}$</p><ul><li><a href="http://www.iosprogrammer.tech/WebSocket-And-SocketRocket-Source-Analysis/">WebSocket简介和SocketRocket源码分析</a></li><li><a href="http://www.iosprogrammer.tech/Android-FFmpeg-Cannot-find-a-valid-font-for-the-family-Sans/">Android下编译FFmepg并添加文字水印</a></li><li><a href="http://www.iosprogrammer.tech/Using-Instruments-To-Oprimize-CPU-Performance/">使用Instruments工具测试CPU与常见对CPU占用过高的操作</a></li></ul><hr>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;本文主要包括两部分，其一是解决xib设置颜色有偏差的问题，其二是聊一下颜色的一些基础知识。&lt;/p&gt;
&lt;h2 id=&quot;xib和代码设置颜色有偏差的原因&quot;&gt;&lt;a href=&quot;#xib和代码设置颜色有偏差的原因&quot; class=&quot;headerlink&quot; title=&quot;xib和代码设
      
    
    </summary>
    
      <category term="iOS" scheme="http://www.iosprogrammer.tech/categories/iOS/"/>
    
    
  </entry>
  
  <entry>
    <title>Android FFmpeg Cannot find a valid font for the family Sans</title>
    <link href="http://www.iosprogrammer.tech/Android-FFmpeg-Cannot-find-a-valid-font-for-the-family-Sans/"/>
    <id>http://www.iosprogrammer.tech/Android-FFmpeg-Cannot-find-a-valid-font-for-the-family-Sans/</id>
    <published>2020-12-06T03:25:47.000Z</published>
    <updated>2020-12-16T09:35:14.775Z</updated>
    
    <content type="html"><![CDATA[<p>在Android中使用FFmpeg添加文字水印时出现下面的错误提示：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">[Parsed_drawtext_0 @ 0x70fc22fe00] Cannot find a valid font for the family Sans</span><br><span class="line">[AVFilterGraph @ 0x71031fc980] Error initializing filter &apos;drawtext&apos;</span><br></pre></td></tr></table></figure></p><p>查看了很多文章，里面都是说要指定fontfill，这个是没有问题的，但是其他文章的例子都是windows上面使用ffmpeg的（FFmpeg相关的文章确实不多，也说明了音视频相关的技术依然并不普及，是非常有门槛的）。<br>最后通过我自己的理解+猜测，再参考其他文章的思路，终于找到了Android上面的解决方案。主要是下面几点：</p><ol><li>使用文字水印时需要指定一个自定义的字体文件</li><li>字体文件需要一个绝对路径</li><li>Android中不能使用项目中app/ 下的路径</li><li>要把自定义字体文件放在res/fonts目录下（在AS 4.1.1中要新建文件夹），然后在程序执行时保存到内部存储目录-/data/user</li></ol><p>下面是具体的步骤：</p><ol><li>我使用的字体是Arial.ttf  可以<a href="http://www.xiazaiziti.com/238949.html" target="_blank" rel="noopener">百度</a>自行下载</li><li>新建res/fonts目录，并把字体文件复制进去，注意：字体文件名要改成全小写 也就是arial.ttf，不然Android Studio会编译报错<code>&#39;A&#39; is not a valid file-based resource name character: File-based resource names must contain only lowercase a-z, 0-9, or underscore</code></li><li>在程序运行时把arial.ttf写入到内部存储中<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line">protected void onCreate(Bundle savedInstanceState) &#123;</span><br><span class="line">...</span><br><span class="line">doSaveTTF();</span><br><span class="line">...</span><br><span class="line">&#125;</span><br><span class="line">private void doSaveTTF() &#123;</span><br><span class="line">        File filesDir = MainActivity.this.getFilesDir();</span><br><span class="line">        File puhuitiMiniPath = new File(filesDir, &quot;arial.ttf&quot;);</span><br><span class="line">        //判断该文件存不存在</span><br><span class="line">        if (!puhuitiMiniPath.exists()) &#123;</span><br><span class="line">            //如果不存在，开始写入文件</span><br><span class="line">            copyFilesFromRaw(R.font.arial, &quot;arial.ttf&quot;, MainActivity.this.getFilesDir().getAbsolutePath());</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">void copyFilesFromRaw(int id, String fileName, String storagePath)&#123;</span><br><span class="line">        InputStream inputStream = MainActivity.this.getResources().openRawResource(id);</span><br><span class="line">        storagePath = storagePath + File.separator + fileName;</span><br><span class="line"></span><br><span class="line">        File file = new File(storagePath);</span><br><span class="line">        try &#123;</span><br><span class="line">            if (!file.exists()) &#123;</span><br><span class="line">                // 1.建立通道对象</span><br><span class="line">                FileOutputStream fos = new FileOutputStream(file);</span><br><span class="line">                // 2.定义存储空间</span><br><span class="line">                byte[] buffer = new byte[inputStream.available()];</span><br><span class="line">                // 3.开始读文件</span><br><span class="line">                int lenght = 0;</span><br><span class="line">                while ((lenght = inputStream.read(buffer)) != -1) &#123;// 循环从输入流读取buffer字节</span><br><span class="line">                    // 将Buffer中的数据写到outputStream对象中</span><br><span class="line">                    fos.write(buffer, 0, lenght);</span><br><span class="line">                &#125;</span><br><span class="line">                fos.flush();// 刷新缓冲区</span><br><span class="line">                // 4.关闭流</span><br><span class="line">                fos.close();</span><br><span class="line">                inputStream.close();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; catch (Exception e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure></li></ol><p>之后在FFmpeg加文字水印的命令中使用自定义字体的绝对路径就可以成功了<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">String drawtext = &quot;Ffmpeg -I xxx.mp4 drawtext=text=&apos;AAAAAA&apos;:fontfile=&apos;/data/user/0/com.sza.shorvideoassistant/files/arial.ttf&apos;:fontcolor=#ffffff:fontsize=33 -y xxx.mp4;</span><br></pre></td></tr></table></figure></p><p>我做的demo的最终效果<br><img src="../images/text-water-mark.webp" alt="最终效果"></p><p>$\color{OrangeRed}{其他热门文章}$</p><ul><li><a href="http://www.iosprogrammer.tech/WebSocket-And-SocketRocket-Source-Analysis/">WebSocket简介和SocketRocket源码分析</a></li><li><a href="http://www.iosprogrammer.tech/Calendar-Notes-Reminders/">Mac OS/iOS中日历、备忘录、提醒事项的使用以及使用iMessage共享屏幕</a></li><li><a href="http://www.iosprogrammer.tech/Using-Instruments-To-Oprimize-CPU-Performance/">使用Instruments工具测试CPU与常见对CPU占用过高的操作</a></li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;在Android中使用FFmpeg添加文字水印时出现下面的错误提示：&lt;br&gt;&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;
      
    
    </summary>
    
      <category term="音视频" scheme="http://www.iosprogrammer.tech/categories/%E9%9F%B3%E8%A7%86%E9%A2%91/"/>
    
    
  </entry>
  
  <entry>
    <title>Hexo在文章末尾添加自定义内容</title>
    <link href="http://www.iosprogrammer.tech/Hexo%E5%9C%A8%E6%96%87%E7%AB%A0%E6%9C%AB%E5%B0%BE%E6%B7%BB%E5%8A%A0%E8%87%AA%E5%AE%9A%E4%B9%89%E5%86%85%E5%AE%B9/"/>
    <id>http://www.iosprogrammer.tech/Hexo在文章末尾添加自定义内容/</id>
    <published>2020-07-15T05:40:59.000Z</published>
    <updated>2021-01-13T10:48:43.834Z</updated>
    
    <content type="html"><![CDATA[<p>现在我的博客有些流量了，所以想尝试把博客的流量引流到微信公众号（爱编程的大头）。</p><p>很多文章都是说怎么修改Hexo博客的页脚、Hexo博客怎么修改页头，没有找到一篇文章是讲怎么在文章内部加入固定内容的，所以我写下了这篇文章，希望对你有帮助。</p><p>一种方法是在每一篇文章都手动加入一段内容，这就需要把老文章重新编辑一遍，而且今后在些文章的时候都要复制这段内容。</p><p>很显然手动的方式不符合程序员“偷懒”的品质，所以我就尝试$\color{CornflowerBlue}{修改Next主题的layout文件}$。</p><p><strong>具体效果可以看我所有文章的结尾处。</strong></p><p>首先编辑<code>themes/next/layout/_macro/post.swig</code>，在第330行下面添加你要显示的内容<br><img src="../images/post-gzh.jpg" alt="post.swig"></p><p>然后在<code>themes/next/source/css/_common/components/post/post-buttom.styl</code>中对div添加你要的样式<br><img src="../images/post-gzh-style.png" alt></p><p>这样每一篇文章都会在文章的末尾添加固定的内容了，新建的文章也会有。</p><hr><p>$\color{OrangeRed}{其他热门文章}$</p><ul><li><a href="http://www.iosprogrammer.tech/Deploy-Hexo-Aliyun/">部署Hexo到自己的阿里云服务器</a></li><li><a href="http://www.iosprogrammer.tech/deploy-hexo-to-gitlab/">部署Hexo到gitlab并自定义域名</a></li><li><a href="http://www.iosprogrammer.tech/Submit-Domain-To-Baidu//">把域名提交到百度资源平台</a></li></ul><hr>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;现在我的博客有些流量了，所以想尝试把博客的流量引流到微信公众号（爱编程的大头）。&lt;/p&gt;
&lt;p&gt;很多文章都是说怎么修改Hexo博客的页脚、Hexo博客怎么修改页头，没有找到一篇文章是讲怎么在文章内部加入固定内容的，所以我写下了这篇文章，希望对你有帮助。&lt;/p&gt;
&lt;p&gt;一种方
      
    
    </summary>
    
      <category term="其他" scheme="http://www.iosprogrammer.tech/categories/%E5%85%B6%E4%BB%96/"/>
    
    
  </entry>
  
  <entry>
    <title>部署Hexo到自己的阿里云服务器</title>
    <link href="http://www.iosprogrammer.tech/Deploy-Hexo-Aliyun/"/>
    <id>http://www.iosprogrammer.tech/Deploy-Hexo-Aliyun/</id>
    <published>2020-07-10T07:51:51.000Z</published>
    <updated>2021-01-13T10:48:45.072Z</updated>
    
    <content type="html"><![CDATA[<p>xxx.github.io在国内访问速度不行，为了增强用户体验，把博客搬到自己的服务器。<br>操作环境：</p><ul><li>本地：Mac</li><li>服务器：阿里云CentOS</li></ul><p>主要步骤：</p><ol><li>服务器安装Nginx和Git（具体方法自行百度）</li><li><p>服务器创建用户git并设置密码。</p> <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">useradd git</span><br><span class="line">passwd git // 设置密码</span><br><span class="line">su git</span><br></pre></td></tr></table></figure></li><li><p>服务器端创建Git空仓库。</p> <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">mkdir ~/hexo.git</span><br><span class="line">cd ~/hexo.git/</span><br><span class="line">git init --bare</span><br></pre></td></tr></table></figure><p> git空仓库可以跟踪git提交信息，但是并不保存源文件。<br> 如果不使用空仓库，客户端是不能提交代码到服务器的。</p></li><li><p>在根目录下创建源码存放目录，并使用Git钩子指定源码存放目录。<br> 如果只是要使用git进行版本控制，这一步是不需要的。<br> 为了能够让网站被访问才需要存放源码。<br> 上一步创建的空仓库中包含一个Hooks文件夹，这个里面存放的是在Git各个阶段会自动触发的脚本。<br> 我们这里需要让Git仓库收到新的提交后自动把代码转移到源码目录。</p> <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">mkdir ~/blog</span><br><span class="line">vim ~/hexo.git/hooks/post-receive</span><br><span class="line"></span><br><span class="line">#!/bin/sh</span><br><span class="line">git --work-tree=/~/hexo --git-dir=/~/hexo.git checkout -f</span><br></pre></td></tr></table></figure></li><li><p>编辑Nginx配置文件</p> <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">server &#123;</span><br><span class="line">    listen       80;</span><br><span class="line">    server_name  【你的域名】;</span><br><span class="line">    root   /home/git/blog;</span><br><span class="line">    index  index.html index.htm;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p> 重启nginx </p> <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">sudo nginx -t # 检查您想配置文件</span><br><span class="line">sudo nginx -s reload # 重启</span><br></pre></td></tr></table></figure><p> 如果要收录到百度等网站，只能使用80端口。否则你可以指定其他端口。</p></li><li><p>增加hexo目录下_config.yml的deploy内容</p> <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">deploy:</span><br><span class="line">- type: git # 提交到自己服务器</span><br><span class="line">  repo: git@39.100.115.70:/home/git/hexo.git</span><br><span class="line">- type: git # 提交到github.io</span><br><span class="line">  repo: git@github.com:shizhiang/shizhiang.github.io.git</span><br><span class="line">- type: baidu_url_submitter</span><br></pre></td></tr></table></figure></li><li><p>部署博客内容</p> <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">hexo clean</span><br><span class="line">hexo g</span><br><span class="line">hexo d</span><br></pre></td></tr></table></figure><p> 这时候你需要输入自己服务器的root用户密码，如果想省略可以在<code>/root/.ssh/authorized_keys</code>加入自己电脑的<code>~/.ssh/id_rsa.pub</code></p></li><li>遇到的问题<ol><li><code>hexo g</code>生成的.html文件都是空的，解决方法是把node的版本将到稳定版。我的是从14降到了12</li><li>怎么让博客在国内和国外访问都很快？<br> 云解析分别解析。<img src="http://image.zanderwb.com/Hexo/%E6%88%AA%E5%B1%8F2020-07-12%20%E4%B8%8A%E5%8D%8811.37.04.png" alt="域名解析"></li></ol></li></ol><hr><p>$\color{OrangeRed}{其他热门文章}$</p><ul><li><a href="http://www.iosprogrammer.tech/Hexo-Add-GZH-EveryPage//">Hexo文章末尾添加自定义内容给引流</a></li><li><a href="http://www.iosprogrammer.tech/insert-math-formula-to-hexo/">Hexo博客插入数学公式</a></li><li><a href="http://www.iosprogrammer.tech/deploy-hexo-to-gitlab/">部署Hexo到gitlab并自定义域名</a></li></ul><hr>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;xxx.github.io在国内访问速度不行，为了增强用户体验，把博客搬到自己的服务器。&lt;br&gt;操作环境：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;本地：Mac&lt;/li&gt;
&lt;li&gt;服务器：阿里云CentOS&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;主要步骤：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;服务器安装Ng
      
    
    </summary>
    
      <category term="其他" scheme="http://www.iosprogrammer.tech/categories/%E5%85%B6%E4%BB%96/"/>
    
    
  </entry>
  
  <entry>
    <title>读《Effective Objective-C 2.0》（二）</title>
    <link href="http://www.iosprogrammer.tech/Read-Effective-Objective-C-2-0-2/"/>
    <id>http://www.iosprogrammer.tech/Read-Effective-Objective-C-2-0-2/</id>
    <published>2019-01-25T10:17:32.000Z</published>
    <updated>2020-12-08T09:42:09.045Z</updated>
    
    <content type="html"><![CDATA[<h3 id="第13条：用“方法调配技术”调试“黑盒方法”"><a href="#第13条：用“方法调配技术”调试“黑盒方法”" class="headerlink" title="第13条：用“方法调配技术”调试“黑盒方法”"></a>第13条：用“方法调配技术”调试“黑盒方法”</h3><ol><li>在运行期，可以向类中新增或替换选择子所对应的方法实现。</li><li>获取方法实现：<code>Method class_getInstanceMethod(Class aClass, SEL aSelector)</code></li><li>交换方法实现：<code>void method_exchangeImplementation(Method m1, Method m2)</code></li><li>一般来说，只有调试程序的时候才需要在运行期修改方法实现，这种做法不宜滥用。</li></ol><h3 id="第14条：理解“类对象”的用意"><a href="#第14条：理解“类对象”的用意" class="headerlink" title="第14条：理解“类对象”的用意"></a>第14条：理解“类对象”的用意</h3><ol><li>“在运行期检视对象类型”这一操作也叫做“类型信息查询”（内省），这个强大而有用的特性内置于Foundation框架的NSObject协议里，凡是由公共根类（NSObject或NSProxy）继承而来的对象都要遵守此协议。</li><li>每个Objective-C对象实例都是指向某块内存数据的指针。</li><li><p><code>id</code>类型的定义</p> <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">typedef struct objc_object &#123;</span><br><span class="line">    Class isa;</span><br><span class="line">&#125; *id;</span><br></pre></td></tr></table></figure><p> 由此可知，每个对象结构体的首个成员是Class类的变量。该变量定义了对象所属的类，通常称为“is a“指针。</p></li><li><p>Class对象的定义</p> <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">typedef struct objc_class *Class;</span><br><span class="line">struct objc_class &#123;</span><br><span class="line">    Class isa;</span><br><span class="line">    Class super_class;</span><br><span class="line">    const char *name;</span><br><span class="line">    long version;</span><br><span class="line">    long instance_size;</span><br><span class="line">    long info;</span><br><span class="line">    struct objc_ivar_list *ivars;</span><br><span class="line">    struct objc_method_list **methodLists;</span><br><span class="line">    struct objc_cache *cache;</span><br><span class="line">    struct objc_protocol_list *protocols;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p> 此结构存放类的“元数据”（metadata），例如类的实例实现了几个方法，具备多少个实例变量信息。此结构体的首个变量也是isa指针，这说明Class本身也是Objective-C对象。super_class变量定义了本类的超类。除此之外还有变量列表ivars，方法列表methodLists，协议列表protocols等。类对象所属的类型（也就是isa指针所指的类型）是另外一个类，叫做“元类”（metaclass），用来表述类对象本身所具备的元数据。“类方法”就定义在此处，因为这些方法可以理解成<strong>类对象的实例方法</strong>。**每个类仅有一个“类对象”，而每个“类对象”仅有一个与之相关的“元类”。<br> <img src="https://upload-images.jianshu.io/upload_images/1853063-c1521fc9f842523d.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/614/format/webp" alt><br> super_class指针确立了继承关系，而isa指针描述了实例所属的类。</p></li><li><code>isMemberOfClass:</code>能够判断出对象是否为某个特定类的实例，而<code>isKindOfClass:</code>则能够判断出对象是否为某类或其派生类的实例。</li><li>类对象是单例，在应用程序的范围内，每个类的Class仅有一个实例。因此可以用 == 来精确判断对象是否为某类实例<code>if ([object class] == [SomeClass class])</code></li></ol><h3 id="第15条：用前缀避免命名空间冲突"><a href="#第15条：用前缀避免命名空间冲突" class="headerlink" title="第15条：用前缀避免命名空间冲突"></a>第15条：用前缀避免命名空间冲突</h3><ol><li>Objective-C没有其他语言那种内置的命名空间机制。</li><li>命名冲突可能导致无法链接，或者令“动态加载器”（dynamic loader）遭遇“重名符号错误”（duplicate symbol error），令应用程序崩溃。</li><li>为所有名称都加上适当前缀来避免命名冲突。即便加了前缀，也难保不出现明明冲突，但是其几率要小很多。</li><li>Apple宣称其保留使用<strong>所有“两字母前缀”</strong>的权利，所以你自己选用的前缀应该是<strong>三字母</strong>的。</li><li>如果要为既有类新增“分类”，那么一定要给“分类”及“分类”中的方法加上前缀。</li><li>在编译好的目标文件中，类的实现文件中所用的纯C函数及全局变量是要算作“顶级符号”的。所以我们应该给这种C函数的名字加上前缀。</li><li>若自己所开发的程序库中用到了第三方库，则应为其中的名称加上前缀。</li></ol><h3 id="第16条：提供“全能初始化方法”"><a href="#第16条：提供“全能初始化方法”" class="headerlink" title="第16条：提供“全能初始化方法”"></a>第16条：提供“全能初始化方法”</h3><ol><li>可为对象提供必要信息以便其能完成工作的初始化方法叫做“全能初始化方法”（designated initializer)。</li><li>其他方法都要调用全能初始化方法。只有在全能初始化方法中，才会存储内部数据。</li><li>如果子类的全能初始化方法与超类方法的名称不同，那么总应覆写超类的全能初始化方法。</li><li>每个子类的全能初始化方法都应该调用其超类的对应方法，应该先调用超类的相关方法，然后再执行与本类有关的任务。</li></ol><h3 id="第17条：实现description方法"><a href="#第17条：实现description方法" class="headerlink" title="第17条：实现description方法"></a>第17条：实现description方法</h3><ol><li><code>debugDescription</code>方法是开发者在调试器中以控制台命令打印对象时才调用的。</li></ol><h3 id="第18条：尽量使用不可变对象"><a href="#第18条：尽量使用不可变对象" class="headerlink" title="第18条：尽量使用不可变对象"></a>第18条：尽量使用不可变对象</h3><ol><li>尽量把对外公布出来的属性设置为只读，而且只在确有必要时才将属性对外公布</li><li>使用KVC可以绕过类所提供的API，来设置只读属性的值</li><li>用类型查询功能查出属性所对应的实例变量在内存中的布局中的偏移量，以此来人为设置这个实例变量的值。</li><li>不要把可变的collection作为属性公开，而应提供相关方法，以此修改对象中的可变collection。</li></ol><h3 id="第19条：使用清晰而协调的命名方式"><a href="#第19条：使用清晰而协调的命名方式" class="headerlink" title="第19条：使用清晰而协调的命名方式"></a>第19条：使用清晰而协调的命名方式</h3><ol><li>不要吝于使用长方法名。然而方法名也不能长的太过分了。</li><li>应该为类与协议的名称加上前缀，以避免命名空间的冲突，而且应该像给方法起名时那样把词句组织好，使其从左至右读起来较为通顺。</li><li>命名方式应该协调一致。如果要从其他框架中继承子类，那么务必遵循其命名惯例。比如要从<code>UIView</code>类中继承自定义的子类，那么类名末尾的词必须是View。</li><li>若要创建自定义的委托协议，则其名称中应该包含委托方的名称，后面再跟上Delegate一词。</li></ol><h3 id="第20条：为私有方法名加前缀"><a href="#第20条：为私有方法名加前缀" class="headerlink" title="第20条：为私有方法名加前缀"></a>第20条：为私有方法名加前缀</h3><ol><li>给私有方法加前缀，这样可以很容易的将其同公共方法区分开。</li><li>不要单用一个下划线做私有方法的前缀，因为这种方法是预留给苹果公司用的。</li></ol><h3 id="第21条：理解Objective-C错误模型"><a href="#第21条：理解Objective-C错误模型" class="headerlink" title="第21条：理解Objective-C错误模型"></a>第21条：理解Objective-C错误模型</h3><ol><li>只在极其罕见的情况下抛出异常，异常抛出以后，无须考虑恢复问题，而且应用程序此时也应该退出。</li><li>不那么严重的错误出现时，令方法返回nil/0，或者使用<code>NSError</code>，以表明有错误发生。</li><li><code>NSError</code>的第一种常见用法是通过委托协议来传递此错误。<code>- (void)connection:(NSURLConnection *)connection didFailWithError:(NSError *)error</code></li><li><code>NSError</code>的另一种常见用法是：经由方法的“输出参数”返回给调用者。<code>- (BOOL)doSometion:(NSError **)error</code>。</li><li>使用ARC时，编译器会把方法签名中的<code>NSError **</code>转换成<code>NSError *__autoreleasing*</code>，也就是说，指针所指的对象会在方法执行完毕后自动释放。 <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">- (BOOL)doSomething:(NSError **)error &#123;</span><br><span class="line">    // Do something that may cause an error</span><br><span class="line">    if ( /* there was an error */) &#123;</span><br><span class="line">        if (error) &#123;</span><br><span class="line">            // Pass the &apos;error&apos; through the out-parameter</span><br><span class="line">            *error = [NSError errorWithDomain:domain code:code userInfo:userInfo];</span><br><span class="line">        &#125;</span><br><span class="line">        return NO; // Indicate failure</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">        return YES; // Indicate success</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ol><h3 id="第22条：理解NSCopying协议"><a href="#第22条：理解NSCopying协议" class="headerlink" title="第22条：理解NSCopying协议"></a>第22条：理解NSCopying协议</h3><ol><li>NSCopying协议：<code>- (id)copyWithZone:(NSZone *)zone</code></li><li>以前开发程序时，会据此把内存分成不同的“区”，而对象会创建在某个区里面。现在不用了，每个程序只有一个区：“默认区”。所以说，尽管必须实现这个方法，但是你不必担心其中的zone参数。</li><li>NSMutableCopying协议：<code>- (id)mutableCopyWithZone:(NSZone *)zone</code></li><li><p>对于不可变的<code>NSArray</code>与可变的<code>NSMutableArray</code>来说，下列关系总是成立的：</p> <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">- [NSMutableArray copy] =&gt; NSArray</span><br><span class="line">- [NSArray mutableCopy] =&gt; NSMutableArray</span><br></pre></td></tr></table></figure></li><li><p>深拷贝：在拷贝对象自身时，将其底层数据也一并复制过去。</p></li><li>Foundation框架中的所有collection类默认情况下都执行浅拷贝，即只拷贝容器对象自身，而不复制其中的数据。</li></ol>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;第13条：用“方法调配技术”调试“黑盒方法”&quot;&gt;&lt;a href=&quot;#第13条：用“方法调配技术”调试“黑盒方法”&quot; class=&quot;headerlink&quot; title=&quot;第13条：用“方法调配技术”调试“黑盒方法”&quot;&gt;&lt;/a&gt;第13条：用“方法调配技术”调试“黑盒方
      
    
    </summary>
    
      <category term="其他" scheme="http://www.iosprogrammer.tech/categories/%E5%85%B6%E4%BB%96/"/>
    
    
  </entry>
  
  <entry>
    <title>读《Effective Objective-C 2.0》（一）</title>
    <link href="http://www.iosprogrammer.tech/Read-Effective-Objective-C-2-0-1/"/>
    <id>http://www.iosprogrammer.tech/Read-Effective-Objective-C-2-0-1/</id>
    <published>2018-12-26T11:25:32.000Z</published>
    <updated>2020-12-08T09:45:23.505Z</updated>
    
    <content type="html"><![CDATA[<h3 id="第1条：了解Objective-C语言的起源"><a href="#第1条：了解Objective-C语言的起源" class="headerlink" title="第1条：了解Objective-C语言的起源"></a>第1条：了解Objective-C语言的起源</h3><ol><li>OC使用“消息结构”而非“函数调用”</li><li>使用消息结构的语言，其运行时所应执行的代码由运行环境来决定；而使用函数调用的语言，则由编译器决定。</li><li>对象所占内存总是分配在“堆空间”中，而绝不会分配在“栈”上。</li><li>分配在堆中的内存必须直接管理（由程序员管理），而分配在栈上的用于保存变量的内存则会在其栈针弹出时自动清理。</li></ol><h3 id="第2条：-在类的头文件中尽量少引入其他头文件"><a href="#第2条：-在类的头文件中尽量少引入其他头文件" class="headerlink" title="第2条： 在类的头文件中尽量少引入其他头文件"></a>第2条： 在类的头文件中尽量少引入其他头文件</h3><ol><li>将引入头文件的时机尽量延后，只在确有需要时才引入，这样就可以减少类的使用者所需引入的头文件数量。</li><li>如果要声明你写的类遵从某个协议，那么该协议必须有完整定义，且不能使用向前声明。</li><li>最好是把协议单独放在一个头文件中。</li><li>委托协议不用单独写一个头文件。</li></ol><h3 id="第3条：多用字面量语法，少用与之等价的方法"><a href="#第3条：多用字面量语法，少用与之等价的方法" class="headerlink" title="第3条：多用字面量语法，少用与之等价的方法"></a>第3条：多用字面量语法，少用与之等价的方法</h3><ol><li>用字面量语法创建数组时要注意，若数组元素对象中有nil，则会抛出异常。</li><li>用字面量语法创建字典时，如果有值为nil，则会抛出异常。</li></ol><h3 id="第4条：多用类型常量，少用-define预处理指令"><a href="#第4条：多用类型常量，少用-define预处理指令" class="headerlink" title="第4条：多用类型常量，少用#define预处理指令"></a>第4条：多用类型常量，少用<code>#define</code>预处理指令</h3><ol><li>若常量局限于某个“实现文件”之内，则在前面加字母<code>k</code>；若常量在类之外可见，则通常以类名为前缀。</li><li><code>const</code>表示变量不可变；<code>static</code>表示该变量仅在定义此变量的编译单元中可见。</li><li>如果一个变量既声明为<code>static</code>，又声明为<code>const</code>，那么编译器根本不会创建符号，而是会像<code>#define</code>预处理指令一样，把所有遇到的变量都替换为常值。</li></ol><h3 id="第5条：用枚举表示状态、选项、状态码"><a href="#第5条：用枚举表示状态、选项、状态码" class="headerlink" title="第5条：用枚举表示状态、选项、状态码"></a>第5条：用枚举表示状态、选项、状态码</h3><ol><li>凡是需要以按位或操作来组合的枚举都应该使用NS_OPTIONS定义。若是枚举不需要互相组合，则应使用NS_ENUM来定义。</li></ol><h3 id="第6条：理解“属性”这一概念"><a href="#第6条：理解“属性”这一概念" class="headerlink" title="第6条：理解“属性”这一概念"></a>第6条：理解“属性”这一概念</h3><ol><li>如果代码使用了编译期计算出来的偏移量，那么在修改类定义之后必须重新编译，否则就会出错。</li><li>OC把实例变量当作一种存储偏移量所用的“特殊变量”，交由“类对象”保管。偏移量会在运行期查找，如果类的定义变了，那么存储的偏移量也就变了。这就是<strong>应用程序二进制接口（ABI）</strong>。</li><li>使用点语法和直接调用存取方法之间没有丝毫差别。</li><li><code>weak</code>在属性所指的对象遭到摧毁时，属性值也会清空。<code>unsafe_unretained</code>当目标对象遭到摧毁时，属性值不会自动清空。</li><li><code>automic</code>特质的获取方法会通过锁定机制来确保其原子操作的原子性。如果两个线程读写同一属性，那么不论何时，总能看到有效的属性值。</li><li>iOS开发中，所有属性都声明为<code>nonatomic</code>的原因是，在iOS中使用同步锁的开销较大，这回带来性能问题。一般情况下并不要求属性必须是“原子的”，因为这并不能保证“线程安全”。例如，一个线程在连续多次读取某属性值的过程中有别的线程在同时改写该值，那么即便将属性声明为<code>atomic</code>，也还是会读到不通的属性值。</li></ol><h3 id="第7条：在对象内部尽量直接访问实例变量"><a href="#第7条：在对象内部尽量直接访问实例变量" class="headerlink" title="第7条：在对象内部尽量直接访问实例变量"></a>第7条：在对象内部尽量直接访问实例变量</h3><ol><li>建议：读取实例变量时采取直接访问的形式，而在设置实例变量的时候通过属性来做。</li><li>由于不经过OC的“方法派发”步骤，所以直接访问实例变量的速度当然比较快。这种情况下，编译器生成的代码会直接访问保存对象实例变量的那块内存。</li><li>直接访问实例变量时，不会调用其“设置方法”，这就饶过了为相关属性所定义的“内存管理语义”。</li><li>直接访问实例变量，不会触发”键值观察”通知。</li><li>在初始化方法中总是应该直接访问实例变量，因为子类可能“覆写”设置方法。</li><li>如果使用了“惰性初始化”技术，那么必须通过存取方法来访问属性。</li></ol><h3 id="第8条：理解“对象等同性“这一概念"><a href="#第8条：理解“对象等同性“这一概念" class="headerlink" title="第8条：理解“对象等同性“这一概念"></a>第8条：理解“对象等同性“这一概念</h3><ol><li><code>==</code>比较的是两个指针本身，而不是其所指的对象。</li><li>在OC中应该使用<code>isEqual:</code>来判断两个对象的等同性。</li><li>如果<code>isEqual:</code>方法判定两个对象相等，那么其<code>hash</code>方法也必须返回同一个值。反之，则不一定成立。</li><li>编写<code>hash</code>方法时，应该用当前的对象做做实验，以便在减少碰撞频度与降低运算复杂度之间取舍。</li><li><code>NSArray</code>等同性判定：先看两个数组所包含的对象个数是否相同，若相同，则在每个对应位置的两个对象上调用其“isEqual:”方法。如果对应位置上的对象均相等，那么这两个数组就相等，这叫做“深度等同性判定”。</li><li>如果把某对象放入set之后又修改其内容，那么后面的行为将很难预料。</li></ol><h3 id="第9条：以“类族模式”隐藏实现细节"><a href="#第9条：以“类族模式”隐藏实现细节" class="headerlink" title="第9条：以“类族模式”隐藏实现细节"></a>第9条：以“类族模式”隐藏实现细节</h3><ol><li>如果对象所属的类位于某个类族中，那么在查询其类信息时要注意。</li><li>使用<code>isKindOfClass:</code>来判断类族信息。</li><li><code>NSArray</code>本身只不过是包在其他隐藏对象外面的壳，它仅仅定义了所有数组都需具备的一些接口。</li></ol><h3 id="第10条：在既有类中使用关联对象存放自定义数据"><a href="#第10条：在既有类中使用关联对象存放自定义数据" class="headerlink" title="第10条：在既有类中使用关联对象存放自定义数据"></a>第10条：在既有类中使用关联对象存放自定义数据</h3><ol><li>关联对象和<code>NSDictionary</code>的区别：设置关联对象时用到的键是个“不透明的指针”（opaque pointer）。如果在两个键上调用“isEqual:”方法的返回值是YES，那么NSDictionary就认为二者相等；然而在设置关联对象值时，若想令两个键匹配到同一个值，则二者必须是完全相同的指针才行。鉴于此，在设置关联对象值时，通常使用静态全局变量做键。</li><li>只有在其他做法不可行时才应选用关联对象，因为这种做法通常会引入难于查找的bug。</li></ol><h3 id="第11条：理解objc-msgSend的作用"><a href="#第11条：理解objc-msgSend的作用" class="headerlink" title="第11条：理解objc_msgSend的作用"></a>第11条：理解objc_msgSend的作用</h3><ol><li>在底层，所有方法都是普通的C语言函数，然而对象收到消息之后，究竟该调用哪个方法则完全于运行期决定，甚至可以在程序运行时改变，这些特性使得OC成为一门真正的动态语言。</li><li><code>void objc_msgSend(id self, SEL cmd, ...)</code>是一个参数可变的函数。第一个参数代表接受者，第二个参数代表选择子。</li><li><code>objc_msgSend</code>函数会根据接受者与选择子的类型来调用适当的方法。为了实现此操作，该方法需要在接受者所属的类中搜索其“方法列表”，如果能找到与选择子名称相符的方法，就跳至其实现代码。若是找不到，那就沿着继承体系继续向上查找，等找到合适的方法之后再跳转。如果最终还是找不到相符的方法，那就执行“消息转发”操作。</li><li><code>objc_msgSend</code>会将匹配结果缓存在“快速映射表”里面，每个类都有这样一块缓存，若是稍后还向该类发送与选择子相同的消息，那么执行起来就很快了。</li><li>每个类都有一张表格，其中的指针都会指向这种函数，而选择子的名称则是查表时所用的“键”。<code>objc_msgSend</code>等函数正是通过这张表格来寻找应该执行的方法并跳转至其实现的。</li><li>如果某函数的最后一项操作是调用另外一个函数，那么就可以运用“尾调用优化”技术。编译器会生成跳转至另一函数所需的指令码，而且不会向调用堆栈中推入新的“栈针”。只有当某函数的最后一个操作仅仅是调用其他函数而不会将其返回值另作他用时，才能执行“尾调用优化”。</li></ol><h3 id="第12条：理解消息转发机制"><a href="#第12条：理解消息转发机制" class="headerlink" title="第12条：理解消息转发机制"></a>第12条：理解消息转发机制</h3><ol><li>消息转发的两个阶段：第一阶段先征询接收者，所属的类，看其是否能动态添加方法，以处理当前这个“未知选择子”，这叫做“动态方法解析”（dynamic method resolution）。第二阶段涉及“完整的消息转发机制”。</li><li>如果运行期系统已经把第一阶段执行完了，那么接收者自己就无法再以动态新增方法的手段来响应包含该选择子的消息了。此时，运行期系统会请求接收者以其他手段来处理与消息相关的方法调用。首先，请接收者看看有没有其他对象能处理这条消息。若有，则运行期系统会把消息转发给那个对象，于是消息转发过程结束，一切如常。若没有“备援的接收者”，则启动完整的消息转发机制，运行期系统会把与消息有关的全部细节都封装到<code>NSInvocation</code>对象中，再给接收者最后一次机会，令其设法解决当前还未处理的这条消息。<h4 id="动态解析"><a href="#动态解析" class="headerlink" title="动态解析"></a>动态解析</h4></li><li>动态方法解析：<code>+ (BOOL)resolveInstanceMethod:(SEL)selector</code>或<code>+ (BOOL)resolveClassMethod:(SEL)selector</code>。</li><li>该方法的参数就是那个未知的选择子，其返回值表示这个类是否能新增一个实例方法用以处理此选择子。</li><li><strong>使用这种方法的前提是：相关方法的实现代码已经写好。</strong><h4 id="备援接收者"><a href="#备援接收者" class="headerlink" title="备援接收者"></a>备援接收者</h4></li><li><code>- (id)forwardingTargetForSelector:(SEL)selector</code>。使用此方案可以模拟多重继承的某些特性。</li><li>我们无法操作经由这一步所转发的消息。若是想在发送给备援接收者之前修改消息内容，那就得通过完整的消息转发机制了。<h4 id="完整的消息转发"><a href="#完整的消息转发" class="headerlink" title="完整的消息转发"></a>完整的消息转发</h4></li><li><code>- (void)forwardInvocation:(NSInvocation *)invocation</code>。</li><li>在触发消息前，先以某种方式改变消息内容，比如追加另外一个参数，或者改变选择子。</li><li>消息转发流程图<br><img src="https://upload-images.jianshu.io/upload_images/424855-83a396fca4f6c206.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="msg_forward.png"></li><li>接收者在每一步中均有机会处理消息。步骤越往后，处理消息的代价就越大。最好能在第一步就处理完，这样的话，运行期系统就可以将此方法缓存起来。</li></ol>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;第1条：了解Objective-C语言的起源&quot;&gt;&lt;a href=&quot;#第1条：了解Objective-C语言的起源&quot; class=&quot;headerlink&quot; title=&quot;第1条：了解Objective-C语言的起源&quot;&gt;&lt;/a&gt;第1条：了解Objective-C语言的
      
    
    </summary>
    
      <category term="其他" scheme="http://www.iosprogrammer.tech/categories/%E5%85%B6%E4%BB%96/"/>
    
    
  </entry>
  
  <entry>
    <title>OC编程基础</title>
    <link href="http://www.iosprogrammer.tech/Programming-With-ObjC/"/>
    <id>http://www.iosprogrammer.tech/Programming-With-ObjC/</id>
    <published>2018-11-06T03:02:17.000Z</published>
    <updated>2020-12-08T09:42:05.104Z</updated>
    
    <content type="html"><![CDATA[<ul><li><code>+ (id)alloc</code>方法返回类型是<code>id</code>。这是Objective-C中的一个特殊的关键字，意味着“某种对象”。它是一个指向一个对象的指针（NSObject *），但它的特殊之处在于它不使用星号。</li><li><code>alloc</code>方法的另一个重要任务是通过把对象属性设置为0来清理为对象属性申请的内存。这避免了以前存储的包含垃圾内存的常见问题，但不足以完全初始化对象</li><li><code>- (id)init</code>方法也返回<code>id</code>。该方法被类用来确保它的属性在创建时具有合适的初始值。</li><li>创建对象时一定要把<code>alloc</code>嵌套在<code>init</code>中，就像<code>NSObject *newObject = [[NSObject alloc] init];</code>。因为<code>init</code>的返回对象可能和<code>alloc</code>返回的不相同</li><li><code>==</code>比较的是两个不同的指针是否指向相同的对象</li><li><code>isEqual:</code>是比较两个对象是否表示相同的数据</li><li>声明标量的时候指明一个初始值，<code>int number = 10;</code>，否则标量的初始值会包含之前栈内的垃圾内容</li><li>对象指针不需要设置初始值，因为会默认设置为nil。</li><li>nil是安全的，给nil发消息什么都不会发生。</li><li>实例变量的内存在对象首次创建时分配，并且当对象解除分配时释放。</li><li><code>@synthesize firstName;</code>的实例变量名称是<code>firstName</code>而不是<code>_firstName</code>。</li><li>你应该总是在initialization method中直接访问instance variable，因为在设置属性时，对象的其他部分可能还没有完全初始化。即时你确定没有提供自定义的访问器方法，并且你自己的类中没有任何副作用，但是你没办法保证将来的子类不会重写该方法。</li><li>当你要子类化一个带有多个<code>init</code>方法的类时，要么通过继承父类的指定初始化器来执行自己的初始化，要么加入自己的其他初始化器。无论哪种，你都应该在做自己的初始化前，调用父类的指定初始化器，来代替<code>[super init]</code>。</li><li>如果为一个readwrite的property实现了getter和setter，或者为readonly的property实现了getter，那么编译器就不会自动合成成员变量，如果需要成员变量，可以通过<code>@synthesize property = _property</code>来手动获取。</li><li>property默认是atomic。</li><li>atomic的属性要么同时自定义setter和getter，要么都由系统合成，如果只自定义一个会报编译器警告。</li><li><strong>Property atomicity is not synonymous with an object’s thread safety.</strong></li><li><strong>unsafe_unretained和weak类似都不会保持对象存活，但是</strong>unsafe_unretained在目标对象释放后不会把它设置成nil。这就意味着被已释放对象占用的那块内存现在是一个悬挂指针，如果给这个悬挂指针发送消息会崩溃。</li><li>class extension中声明的一个readwrite的属性，会在这个类的所有对象中生成setter方法，虽然不能直接使用点语法或调用setxxx:，但是可以使用<code>performSelect...</code>或<code>objc_msgSend...</code>来调用。即使这个属性在类的public接口中是readonly的。</li><li>编译器不会自动合成采用的协议中声明的属性。</li><li>如果是跨api传递值，比如方法或函数中的参数，则最好是使用跨平台的类型（NSInteger/CGFloat…)；对于局部变量，例如循环中的计数器，则可以使用基本C类型（int/float…）</li><li>collection并不是以某种方式维护每个对象的单独副本，而是使用强引用来跟踪其内容。这意味着，<strong>只要colletion没有被销毁，它里面的任何对象都将保持活动状态</strong></li><li>使用<code>arrayWithObjects:</code>和<code>initWithObjects:</code>创建数组时，最后要带上<code>nil</code>。</li><li>使用字面量语法创建数组时，不能包含<code>nil</code>，可以使用<code>NSNull</code>来代替<code>nil</code>。</li><li><code>NSArray</code>是有序的collection，会包含重复元素；<code>NSSet</code>是无序的collection，不包含重复元素。</li><li>不要在for循环里修改collection</li><li>block会捕获上下文</li><li>在block捕获上下文之后再修改上下文的内容不会改变block捕获的值。如果被捕获的变量使用<code>__block</code>修饰，则会被修改。</li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;ul&gt;
&lt;li&gt;&lt;code&gt;+ (id)alloc&lt;/code&gt;方法返回类型是&lt;code&gt;id&lt;/code&gt;。这是Objective-C中的一个特殊的关键字，意味着“某种对象”。它是一个指向一个对象的指针（NSObject *），但它的特殊之处在于它不使用星号。&lt;/li&gt;
&lt;l
      
    
    </summary>
    
      <category term="iOS" scheme="http://www.iosprogrammer.tech/categories/iOS/"/>
    
    
  </entry>
  
  <entry>
    <title>KVC/KVO 总结</title>
    <link href="http://www.iosprogrammer.tech/KVC-KVO/"/>
    <id>http://www.iosprogrammer.tech/KVC-KVO/</id>
    <published>2018-10-29T06:10:17.000Z</published>
    <updated>2020-12-08T09:43:26.212Z</updated>
    
    <content type="html"><![CDATA[<h1 id="KVC"><a href="#KVC" class="headerlink" title="KVC"></a>KVC</h1><h2 id="Key-Value-Coding基本原则"><a href="#Key-Value-Coding基本原则" class="headerlink" title="Key-Value Coding基本原则"></a>Key-Value Coding基本原则</h2><h3 id="访问对象属性"><a href="#访问对象属性" class="headerlink" title="访问对象属性"></a>访问对象属性</h3><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">@interface</span> <span class="title">BankAccount</span>: <span class="title">NSobject</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">@property</span> (<span class="keyword">nonatomic</span>) <span class="built_in">NSNumber</span> *currentBalance; <span class="comment">// An attribute</span></span><br><span class="line"><span class="keyword">@property</span> (<span class="keyword">nonatomic</span>) Person *owner; <span class="comment">// A to-one relation</span></span><br><span class="line"><span class="keyword">@property</span> (<span class="keyword">nonatomic</span>) <span class="built_in">NSArray</span> &lt;Transaction *&gt;*transactions; <span class="comment">// A to-many relation</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">@end</span></span><br></pre></td></tr></table></figure><p><code>currentBalance</code>/<code>owner</code>/<code>transactions</code>都是<code>BankAccount</code>的属性。<code>owner</code>属性是一个对象，和<code>BankAccount</code>构成一对一的关系，owner对象中的属性改变后并不会影响到owner本身。</p><p>为了保持封装，对象通常为其接口上的属性提供访问器方法（accessor methods）。在使用访问器方法时必须在编译之前将属性名称写入代码中。访问器方法的名称成为使用它的代码的静态部分。例如：<br><code>[myAccount setCurrentBalance:@(100.0)];</code><br>这样缺乏灵活性，KVC提供了使用字符串标识符访问对象属性的更通用的机制。</p><h4 id="使用key和key-path-标识对象的属性"><a href="#使用key和key-path-标识对象的属性" class="headerlink" title="使用key和key path 标识对象的属性"></a>使用key和key path 标识对象的属性</h4><p>key: 标识特定属性的字符串。通常表示属性的key是代码中显示的属性本身的名称。<br>key必须使用ASCII编码，可能不包含空格，并且通常是以小写字母开头（URL除外）。<br>上面的赋值过程使用KVC表示:<br><code>[myAccount setValue:@(100.0) forKey:@&quot;currentBalance&quot;];</code></p><p>key path: 用来指定要遍历的对象属性序列的一串使用“.”分隔的key。序列中的第一个键的属性是相对于接受者的，并且每个后续键是相对于前一个属性的值的。当需要使用一个方法来向下逐级获取对象层次结构时，key path特别有用。<br>例如，<code>owner.address.street</code>应用于银行账户实例的key path是指存储在银行账户所有者地址中的<code>street</code>字符串的值。</p><h4 id="使用key获取属性值"><a href="#使用key获取属性值" class="headerlink" title="使用key获取属性值"></a>使用key获取属性值</h4><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line">- (<span class="keyword">void</span>)getAttributeValuesUsingKeys &#123;</span><br><span class="line">    Account *myAccount = [[Account alloc] init];</span><br><span class="line">    myAccount.currBalance = @<span class="number">100</span>;</span><br><span class="line">    </span><br><span class="line">    Person *owner = [[Person alloc] init];</span><br><span class="line">    Address *address = [[Address alloc] init];</span><br><span class="line">    address.street = <span class="string">@"第三大道"</span>;</span><br><span class="line">    owner.address = address;</span><br><span class="line">    myAccount.owner = owner;</span><br><span class="line">    </span><br><span class="line">    Transaction *t1 = [[Transaction alloc] init];</span><br><span class="line">    Person *p1 = [[Person alloc] init];</span><br><span class="line">    p1.name = <span class="string">@"p1"</span>;</span><br><span class="line">    t1.payee = p1;</span><br><span class="line">    </span><br><span class="line">    Transaction *t2 = [[Transaction alloc] init];</span><br><span class="line">    Person *p2 = [[Person alloc] init];</span><br><span class="line">    p2.name = <span class="string">@"p2"</span>;</span><br><span class="line">    t2.payee = p2;</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">NSArray</span> *ts = @[t1, t2];</span><br><span class="line">    myAccount.transactions = ts;</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">NSNumber</span> *currBalance = [myAccount valueForKey:<span class="string">@"currBalance"</span>];</span><br><span class="line">    <span class="built_in">NSLog</span>(<span class="string">@"currBalance = %@"</span>, currBalance); <span class="comment">// currBalance = 100</span></span><br><span class="line">    </span><br><span class="line">    <span class="built_in">NSString</span> *street = [myAccount valueForKeyPath:<span class="string">@"owner.address.street"</span>];</span><br><span class="line">    <span class="built_in">NSLog</span>(<span class="string">@"street = %@"</span>, street); <span class="comment">// street = 第三大道</span></span><br><span class="line">    </span><br><span class="line">    <span class="built_in">NSDictionary</span> *values = [myAccount dictionaryWithValuesForKeys:@[<span class="string">@"currBalance"</span>, <span class="string">@"owner"</span>]];</span><br><span class="line">    <span class="built_in">NSLog</span>(<span class="string">@"values = %@"</span>, values); <span class="comment">// values = &#123;currBalance = 100; owner = "&lt;Person: 0x60000179af40&gt;";&#125;</span></span><br><span class="line">    </span><br><span class="line">    <span class="built_in">NSArray</span> *payees = [myAccount valueForKeyPath:<span class="string">@"transactions.payee.name"</span>];</span><br><span class="line">    <span class="built_in">NSLog</span>(<span class="string">@"payees = %@"</span>, payees); <span class="comment">// payees = (p1, p2)</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">// Terminating app due to uncaught exception 'NSUnknownKeyException', reason: '[&lt;Account 0x600002685ee0&gt; valueForUndefinedKey:]'</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">//    [myAccount valueForKey:@"owner.address.street"];</span></span><br><span class="line">    <span class="comment">//    [myAccount valueForKey:@"test"];</span></span><br><span class="line">    <span class="comment">//    [myAccount dictionaryWithValuesForKeys:@[@"currBalance", @"transactions.payee.name"]];</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="使用key设置属性值"><a href="#使用key设置属性值" class="headerlink" title="使用key设置属性值"></a>使用key设置属性值</h4><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">- (<span class="keyword">void</span>)settingAttributeValuesUsingKeys &#123;</span><br><span class="line">    Account *myAccount = [[Account alloc] init];</span><br><span class="line">    [myAccount setValue:@<span class="number">100.0</span> forKey:<span class="string">@"currBalance"</span>];</span><br><span class="line">    <span class="built_in">NSLog</span>(<span class="string">@"currBalance = %@"</span>, myAccount.currBalance); <span class="comment">// currBalance = 100</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">// operationTimes是非引用类型，这里进行了和NSNumber的自动转换</span></span><br><span class="line">    [myAccount setValue:@<span class="number">10</span> forKey:<span class="string">@"operationTimes"</span>];</span><br><span class="line">    <span class="built_in">NSLog</span>(<span class="string">@"operationTimes = %ld"</span>, myAccount.operationTimes); <span class="comment">// operationTimes = 10</span></span><br><span class="line">    </span><br><span class="line">    Person *owner = [[Person alloc] init];</span><br><span class="line">    Address *address = [[Address alloc] init];</span><br><span class="line">   </span><br><span class="line">    [myAccount setValue:address forKeyPath:<span class="string">@"owner.address"</span>]; <span class="comment">// 这时候owner还是null</span></span><br><span class="line">    <span class="built_in">NSLog</span>(<span class="string">@"address = %@"</span>, myAccount.owner.address); <span class="comment">// address = (null)</span></span><br><span class="line">    </span><br><span class="line">    [myAccount setValue:owner forKeyPath:<span class="string">@"owner"</span>];</span><br><span class="line">    [myAccount setValue:address forKeyPath:<span class="string">@"owner.address"</span>];</span><br><span class="line">    <span class="built_in">NSLog</span>(<span class="string">@"address = %@"</span>, myAccount.owner.address); <span class="comment">// address = &lt;Address: 0x600001a43550&gt;</span></span><br><span class="line">    </span><br><span class="line">    [myAccount setValuesForKeysWithDictionary:@&#123;<span class="string">@"currBalance"</span>: @<span class="number">200.0</span>, <span class="string">@"owner"</span>: owner&#125;];</span><br><span class="line">    <span class="built_in">NSLog</span>(<span class="string">@"currBalance = %@, owner = %@"</span>, myAccount.currBalance, myAccount.owner); <span class="comment">// currBalance = 200, owner = &lt;Person: 0x600001478ee0&gt;</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">// Terminating app due to uncaught exception 'NSUnknownKeyException', reason: '[&lt;Account 0x6000029c2490&gt; setValue:forUndefinedKey:]: xxx'</span></span><br><span class="line">    <span class="comment">//    [myAccount setValue:@"value" forUndefinedKey:@"undefinedKey"];</span></span><br><span class="line">    <span class="comment">//    [myAccount setValuesForKeysWithDictionary:@&#123;@"currBalance": @200.0, @"owner.address.street": @"第一大道"&#125;];</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="访问集合属性"><a href="#访问集合属性" class="headerlink" title="访问集合属性"></a>访问集合属性</h3><p>符合键值编码的对象以与公开其他属性相同的方式公开其多对多属性。您可以使用<code>valueForKey:</code>或<code>setValue:forKey:</code>来获取或设置集合属性。但是，当你想要操作这些集合内容的时候，使用协议定义的可变代理方法通常是最有效的。<br>该协议为集合对象访问定义了三种不同的代理方法，每种方法都有一个key和key path变量：</p><ul><li><code>mutableArrayValueForKey:</code>和<code>mutableArrayValueForKeyPath:</code> 返回一个行为类似<code>NSMutableArray</code>的代理对象</li><li><code>mutableSetValueForKey:</code>和<code>mutableSetValueFOrKeyPath:</code> 返回一个行为类似<code>NSMutableSet</code>的代理对象</li><li><code>mutableOrderedSetValueForKey:</code>和<code>mutableOrderedSetValueForKeyPath:</code> 返回一个行为类似<code>NSMutableOrderedSet</code>的代理对象<br>当您对代理对象进行操作，向对象添加元素，从中删除元素或者替换其中的元素时，协议的默认实现会相应地修改基础属性。这比使用<code>valueForKey:</code>获取一个不可变的集合对象，再创建一个可修改的集合，然后把修改后的集合通过<code>setValue:forKey:</code>更有效。在许多情况下，它比直接使用可变属性也是更有效的。这些方法为持有集合对象的对象们提供了维护KVO特性的好处。<figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">- (<span class="keyword">void</span>)accessingCollectionProperties &#123;</span><br><span class="line">    Transaction *t1 = [[Transaction alloc] init];</span><br><span class="line">    Transaction *t2 = [[Transaction alloc] init];</span><br><span class="line">    Account *myAccount = [[Account alloc] init];</span><br><span class="line">    </span><br><span class="line">    [myAccount addObserver:<span class="keyword">self</span> forKeyPath:<span class="string">@"transactions"</span> options:<span class="built_in">NSKeyValueObservingOptionOld</span> | <span class="built_in">NSKeyValueObservingOptionNew</span> context:<span class="literal">nil</span>];</span><br><span class="line">    </span><br><span class="line">    </span><br><span class="line">    [myAccount setValue:@[t1, t2] forKey:<span class="string">@"transactions"</span>];</span><br><span class="line">    <span class="built_in">NSLog</span>(<span class="string">@"1st transactions = %@"</span>, myAccount.transactions); <span class="comment">// 1st transactions = ("&lt;Transaction: 0x6000009d1400&gt;","&lt;Transaction: 0x6000009d1420&gt;")</span></span><br><span class="line">    <span class="built_in">NSMutableArray</span> &lt;Transaction *&gt;*transactions = [myAccount mutableArrayValueForKey:<span class="string">@"transactions"</span>];</span><br><span class="line">    </span><br><span class="line">    [transactions addObject:[[Transaction alloc] init]];</span><br><span class="line">    <span class="built_in">NSLog</span>(<span class="string">@"2nd transactions = %@"</span>, myAccount.transactions); <span class="comment">// 2nd transactions = ("&lt;Transaction: 0x6000009d1400&gt;","&lt;Transaction: 0x6000009d1420&gt;","&lt;Transaction: 0x6000009cabf0&gt;")</span></span><br><span class="line">    </span><br><span class="line">    [transactions removeLastObject];</span><br><span class="line">    <span class="built_in">NSLog</span>(<span class="string">@"3th transactions = %@"</span>, myAccount.transactions); <span class="comment">// 3th transactions = ("&lt;Transaction: 0x6000009d1400&gt;","&lt;Transaction: 0x6000009d1420")</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><h4 id="使用集合操作符"><a href="#使用集合操作符" class="headerlink" title="使用集合操作符"></a>使用集合操作符</h4><p>当您向<code>valueForKeyPath:</code>消息发送符合键值编码的对象时，可以在key path中嵌入集合运算符。集合运算符是一个小的关键字列表之一，前面是一个@符号，它指定了getter应该执行的操作，以便在返回之前以某种方式操作数据。<code>NSObject</code>为<code>valueForKeyPath:</code>提供了默认实现。<br>当key path包含集合运算符时，运算符之前的部分称为左键路径，指示相对于消息接受者操作的集合，当你直接向一个集合（例如<code>NSArray</code>）发送消息时左键路径或许可以省略。操作符之后的部分称为右键路径，指定操作符应处理的集合中的属性，除了<code>@count</code>之外的所有操作符都需要一个右键路径。<br><img src="http://image.iosprogrammer.hongbility.com/KVC_KVOkeypath.jpg" alt><br>集合运算符表现出三种基本类型的行为：</p><ul><li><strong>聚合运算符</strong>以某种方式合并集合的对象，并返回通常与右键路径中指定的属性的数据类型匹配的单个对象。<code>@count</code>是一个例外，它没有正确的关键路径并始终将返回一个<code>NSNumber</code>实例。包括：<code>@avg</code>/<code>@count</code>/<code>@max</code>/<code>@min</code>/<code>@sum</code>。</li><li><strong>数组运算符</strong>返回一个<code>NSArray</code>实例，该实例包含命名集合中保存的对象的某个子集。包含：<code>@distinctUnionOfObjects</code>/<code>@unionOfObjects</code>。</li><li><strong>嵌套运算符</strong>处理包含其他集合的集合，并根据操作符返回一个<code>NSArray</code>或<code>NSSet</code>实例，它以某种方式组合嵌套集合的对象。包含：<code>@distinctUnionOfArrays</code>/<code>@unionOfArrays</code>/<code>@distinctUnionOfSets</code>。</li></ul><h4 id="示例"><a href="#示例" class="headerlink" title="示例"></a>示例</h4><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br></pre></td><td class="code"><pre><span class="line">- (<span class="keyword">void</span>)usingCollectionOperators &#123;</span><br><span class="line">    Transaction *t1 = [Transaction transactionWithPayee:<span class="string">@"Green Power"</span> amount:@(<span class="number">120.00</span>) date:[<span class="built_in">NSDate</span> dateWithTimeIntervalSinceNow:<span class="number">100</span>]];</span><br><span class="line">    Transaction *t3 = [Transaction transactionWithPayee:<span class="string">@"Green Power"</span> amount:@(<span class="number">170.00</span>) date:[<span class="built_in">NSDate</span> dateWithTimeIntervalSinceNow:<span class="number">300</span>]];</span><br><span class="line">    Transaction *t5 = [Transaction transactionWithPayee:<span class="string">@"Car Loan"</span> amount:@(<span class="number">250.00</span>) date:[<span class="built_in">NSDate</span> dateWithTimeIntervalSinceNow:<span class="number">500</span>]];</span><br><span class="line">    Transaction *t6 = [Transaction transactionWithPayee:<span class="string">@"Car Loan"</span> amount:@(<span class="number">250.00</span>) date:[<span class="built_in">NSDate</span> dateWithTimeIntervalSinceNow:<span class="number">600</span>]];</span><br><span class="line">    Transaction *t13 = [Transaction transactionWithPayee:<span class="string">@"Animal Hospital"</span> amount:@(<span class="number">600.00</span>) date:[<span class="built_in">NSDate</span> dateWithTimeIntervalSinceNow:<span class="number">500</span>]];</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">NSArray</span> *transactions = @[t1, t3, t5, t6, t13];</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/* 聚合运算符</span></span><br><span class="line"><span class="comment">     * 聚合运算符可以处理数组或属性集，从而生成反映集合某些方面的单个值。</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="comment">// @avg 平均值</span></span><br><span class="line">    <span class="built_in">NSNumber</span> *transactionAverage = [transactions valueForKeyPath:<span class="string">@"@avg.amount"</span>];</span><br><span class="line">    <span class="built_in">NSLog</span>(<span class="string">@"transactionAverage = %@"</span>, transactionAverage); <span class="comment">// transactionAverage = 278</span></span><br><span class="line">    <span class="comment">// @count 个数</span></span><br><span class="line">    <span class="built_in">NSNumber</span> *numberOfTransactions = [transactions valueForKeyPath:<span class="string">@"@count"</span>];</span><br><span class="line">    <span class="built_in">NSLog</span>(<span class="string">@"numberOfTransactions = %@"</span>, numberOfTransactions); <span class="comment">// numberOfTransactions = 5</span></span><br><span class="line">    <span class="comment">// @max 最大值 使用compare:进行比较</span></span><br><span class="line">    <span class="built_in">NSDate</span> *latestDate = [transactions valueForKeyPath:<span class="string">@"@max.date"</span>];</span><br><span class="line">    <span class="built_in">NSLog</span>(<span class="string">@"latestDate = %@"</span>, latestDate); <span class="comment">// latestDate = Thu Nov  1 15:05:59 2018</span></span><br><span class="line">    <span class="comment">// @min 最小值 使用compare:进行比较</span></span><br><span class="line">    <span class="built_in">NSDate</span> *earliestDate = [transactions valueForKeyPath:<span class="string">@"@min.date"</span>];</span><br><span class="line">    <span class="built_in">NSLog</span>(<span class="string">@"earliestDate = %@"</span>, earliestDate);<span class="comment">// earliestDate = Thu Nov  1 14:57:39 2018</span></span><br><span class="line">    <span class="comment">// @sum 总和</span></span><br><span class="line">    <span class="built_in">NSNumber</span> *amountSum = [transactions valueForKeyPath:<span class="string">@"@sum.amount"</span>];</span><br><span class="line">    <span class="built_in">NSLog</span>(<span class="string">@"amountSum = %@"</span>, amountSum); <span class="comment">// amountSum = 1390</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">/* 数组运算符</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * 数组运算符导致valueForKeyPath:返回与右键路径指示的特定对象集相对应的对象数组。</span></span><br><span class="line"><span class="comment">     * 如果使用数组运算符时任何叶对象为nil，则valueForKeyPath：方法会引发异常。</span></span><br><span class="line"><span class="comment">     **/</span></span><br><span class="line">    <span class="comment">// @distinctUnionOfObjects 创建并返回一个数组，该数组包含与右键路径指定的属性对应的集合的不同对象。会删除重复对象。</span></span><br><span class="line">    <span class="built_in">NSArray</span> *distinctPayees = [transactions valueForKeyPath:<span class="string">@"@distinctUnionOfObjects.payee"</span>];</span><br><span class="line">    <span class="built_in">NSLog</span>(<span class="string">@"distinctPayees = %@"</span>, distinctPayees); <span class="comment">// distinctPayees = ("Green Power", "Animal Hospital", "Car Loan")</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">// @unionOfObjects 创建并返回一个数组，该数组包含与右键路径指定的属性对应的集合的所有对象。不删除重复对象</span></span><br><span class="line">    <span class="built_in">NSArray</span> *payees = [transactions valueForKeyPath:<span class="string">@"@unionOfObjects.payee"</span>];</span><br><span class="line">    <span class="built_in">NSLog</span>(<span class="string">@"payees = %@"</span>, payees); <span class="comment">// payees = ("Green Power", "Green Power", "Car Loan", "Car Loan", "Animal Hospital")</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">/** 嵌套运算符</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * 嵌套运算符对嵌套集合进行操作，集合中的每个条目都包含一个集合。</span></span><br><span class="line"><span class="comment">     * 如果使用数组运算符时任何叶对象为nil，则valueForKeyPath：方法会引发异常。</span></span><br><span class="line"><span class="comment">     **/</span></span><br><span class="line">    Transaction *moreT1 = [Transaction transactionWithPayee:<span class="string">@"General Cable - Cottage"</span> amount:@(<span class="number">120.00</span>) date:[<span class="built_in">NSDate</span> dateWithTimeIntervalSinceNow:<span class="number">10</span>]];</span><br><span class="line">    Transaction *moreT2 = [Transaction transactionWithPayee:<span class="string">@"General Cable - Cottage"</span> amount:@(<span class="number">1550.00</span>) date:[<span class="built_in">NSDate</span> dateWithTimeIntervalSinceNow:<span class="number">3</span>]];</span><br><span class="line">    Transaction *moreT7 = [Transaction transactionWithPayee:<span class="string">@"Hobby Shop"</span> amount:@(<span class="number">600.00</span>) date:[<span class="built_in">NSDate</span> dateWithTimeIntervalSinceNow:<span class="number">160</span>]];</span><br><span class="line">    <span class="built_in">NSArray</span> *moreTransactions = @[moreT1, moreT2, moreT7];</span><br><span class="line">    <span class="built_in">NSArray</span> *arrayOfArrays = @[transactions, moreTransactions];</span><br><span class="line">    <span class="comment">// @distinctUnionOfArrays  指定@distinctUnionOfArrays运算符时，valueForKeyPath:创建并返回一个数组，该数组包含与右键路径指定的属性对应的所有集合的组合的不同对象。</span></span><br><span class="line">    <span class="built_in">NSArray</span> *collectedDistinctPayees = [arrayOfArrays valueForKeyPath:<span class="string">@"@distinctUnionOfArrays.payee"</span>];</span><br><span class="line">    <span class="built_in">NSLog</span>(<span class="string">@"collectedDistinctPayees = %@"</span>, collectedDistinctPayees); <span class="comment">// collectedDistinctPayees = ( "General Cable - Cottage", "Animal Hospital", "Hobby Shop", "Green Power", "Car Loan")</span></span><br><span class="line">    <span class="comment">// @unionOfArrays 与@distinctUnionOfArrays 不同的是不会删除相同的元素</span></span><br><span class="line">    <span class="built_in">NSArray</span> *collectedPayees = [arrayOfArrays valueForKeyPath:<span class="string">@"@unionOfArrays.payee"</span>];</span><br><span class="line">    <span class="built_in">NSLog</span>(<span class="string">@"collectedPayees = %@"</span>, collectedPayees); <span class="comment">// collectedPayees = ("Green Power", "Green Power", "Car Loan", "Car Loan", "Animal Hospital", "General Cable - Cottage", "General Cable - Cottage", "Hobby Shop")</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">// @distinctUnionOfSets 与@distinctUnionOfArrays作用相同，只是用于NSSet对象而不是NSArray</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="访问者搜索模式"><a href="#访问者搜索模式" class="headerlink" title="访问者搜索模式"></a>访问者搜索模式</h3><p>NSObject提供的NSkeyValueCoding协议的默认实现使用明确定义的规则集将基于键的访问器调用映射到对象的基础属性。这些协议方法使用“key”在其自己的对象实例中搜索访问器、实例变量以及遵循某个命名规则的相关方法。虽然您很少修改此默认搜索，但了解它的工作方式会有所帮助，既可以跟踪键值编码对象的行为，也可以使您自己的对象兼容KVC。</p><h4 id="Getter的搜索模式"><a href="#Getter的搜索模式" class="headerlink" title="Getter的搜索模式"></a>Getter的搜索模式</h4><p><code>valueForKey:</code>的默认实现是，给定<code>key</code>参数作为输入，通过下面的过程，在接收<code>valueForKey:</code>调用的类实例中操作。</p><ol><li>按顺序搜索访问器方法<code>get&lt;Key&gt;</code>/<code>&lt;key&gt;</code>/<code>is&lt;Key&gt;</code>/<code>_&lt;key&gt;</code>。如果找到，调用该方法并且带着方法的调用结果调转到第5步执行；否则，继续下一步。</li><li>如果没有找到简单的访问方法，搜索其名称匹配某些模式的方法的实例。其中匹配模式包含<code>countOf&lt;Key&gt;</code>，<code>objectIn&lt;Key&gt;AtIndex:</code>（对应于<code>NSArray</code>定义的基本方法），和<code>&lt;key&gt;AtIndexs:</code>（对应于<code>NSArray</code>的方法<code>objectsAtIndexs:</code>）<br>一旦找到第一个和其他两个中的至少一个，则创建一个响应所以<code>NSArray</code>方法并返回该方法的集合代理对象。否则，执行第3步。<br>代理对象随后将任何<code>NSArray</code>接收到的一些组合的消息。**实际上，与符合键值编码对象一起工作的代理对象允许底层属性的行为就像它是<code>NSArray</code>一样，即便它不是。</li><li>如果没有找到简单的访问器方法或数组访问方法组，则寻找三个方法<code>countOf&lt;Key&gt;</code>/<code>enumeratorOf&lt;Key&gt;</code>/<code>memberOf&lt;Key&gt;:</code>，对应<code>NSSet</code>类的基本方法。<br>如果三个方法全找到了，则创建一个集合代理对象来响应所有的NSSet方法并返回。否则，执行第4步。</li><li>如果上面的方法都没有找到，并且接受者的类方法<code>accessInstanceVariablesDirectly</code>返回<code>YES</code>（默认YES），则按序搜索以下实例变量：<code>_&lt;key&gt;</code>/<code>_is&lt;Key&gt;</code>/<code>&lt;key&gt;</code>/<code>is&lt;Key&gt;</code>。如果找到其中之一，直接获取实例变量的值并跳转到第5步；否则执行第6步。</li><li>如果检索到的属性值是对象指针，则只返回结果；如果值是受<code>NSNumber</code>支持的标量，则将其存储在<code>NSNumber</code>实例中并返回；如果结果是<code>NSNumber</code>不支持的标量，则转换成<code>NSValue</code>对象并返回</li><li>如果以上所有的尝试都失败了，则调用<code>valueForUndefinedKey:</code>，这个方法默认抛出异常，<code>NSObject</code>的子类可以重写来自定义行为。</li></ol><h4 id="Setter的搜索模式"><a href="#Setter的搜索模式" class="headerlink" title="Setter的搜索模式"></a>Setter的搜索模式</h4><p><code>setValue:forKey:</code>的默认实现是给定<code>key</code>和<code>value</code>作为参数输入，尝试把<code>value</code>设置给以<code>key</code>命名的属性。过程如下：</p><ol><li>按序搜索<code>set&lt;Key&gt;:</code>或<code>_set&lt;Key&gt;</code>，如果找到，则使用输入参数调用并结束。</li><li>如果没有找到简单的访问器方法，并且如果类方法<code>accessInstanceVariablesDirectly</code>返回<code>YES</code>（默认为YES），则按序搜索以下实例变量: <code>_&lt;key&gt;</code>/<code>_is&lt;Key&gt;</code>/<code>&lt;key&gt;</code>/<code>is&lt;Key&gt;</code>，如果找到了则直接进行赋值并结束。</li><li>以上方法皆失败则调用<code>setValue:forUndefinedKey:</code>，这个方法默认抛出异常，<code>NSObject</code>的子类可以自定义。</li></ol><h1 id="KVO"><a href="#KVO" class="headerlink" title="KVO"></a>KVO</h1><p>Key-value observing提供了一种机制，允许对象把自身属性的更改通知给其他属性。它对应用程序中model和controller层之间的通信特别有用。通常，控制器对象观察模型对象的属性，视图对象通过控制器观察模型对象的属性。另外，一个模型对象或许会观察另一个模型对象（通常用与确认从属值何时改变）或甚至自身（再次确认从属值何时改变）。<br>你可以观察属性，包括简单属性，一对一关系和多对多关系。多对多关系的观察者被告知所作出的改变的类型——以及改变中涉及哪些对象。</p><h2 id="注册KVO"><a href="#注册KVO" class="headerlink" title="注册KVO"></a>注册KVO</h2><ul><li>使用<code>addObserver:forKeyPath:options:content:</code>方法来给observer注册一个observed object</li><li>在observer内部实现<code>observerValueForKeyPath:ofObject:change:context:</code>来接收更改的通知消息。</li><li>当不再应该接收消息时，使用<code>removeObserver:forKeyPath:</code>方法来反注册观察者。起码也要在observer被移除前调用这个方法。</li></ul><h3 id="注册Observer"><a href="#注册Observer" class="headerlink" title="注册Observer"></a>注册Observer</h3><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">addObserver:forKeyPath:options:content:</span><br></pre></td></tr></table></figure><h4 id="options"><a href="#options" class="headerlink" title="options"></a>options</h4><p>options参数指定了一个按位<code>OR</code>的常量选项，会影响通知中提供的更改字典的内容和生成通知的方式。<br>你可以选择使用<code>NSKeyValueObservingOptionOld</code>选项，在被观察的属性修改前收到旧值；也可以使用<code>NSKeyValueObservingOptionNew</code>来获取修改后的新值。通过<code>NSKeyValueObservingOptionOld | NSKeyValueObservingOptionNew</code>获取两者。<br>使用<code>NSKeyValueObservingOptionInitial</code>选项，让被观察的属性在<code>addObserver:forKeyPath:options:context</code>方法返回前发送即时通知。你可以使用此附加的一次性通知来在观察者中建立属性的初始值。<br>通过包含<code>NSKeyValueObservingOptionPrior</code>来指示被观察对象在属性更改之前发送通知（除了在更改之后发送通知）。在更改之前发送的通知中的<code>change</code>字典始终包含<code>NSKeyValueChangeNotificationIsPriorKey</code>，其值是包含布尔值YES的NSNumber对象，但不包含<code>NSKeyValueChangeNewKey</code>的内容。如果指定此选项，则更改后发送的通知中的<code>change</code>字典的内容和未指定此选项时包含的内容相同。当观察者自己的键值观察兼容性要求它为自己的一个属性调用-willChangexxx方法之一时，可以使用此选项，并且该属性的值取决于被观察对象的属性的值。</p><h4 id="context"><a href="#context" class="headerlink" title="context"></a>context</h4><p><code>addObserver:forKeyPath:options:context:</code>消息中的上下文指针包含将在相应的更改通知中传递回观察者的任意数据。您可以使用NULL来完全指定并依赖于<code>key path</code>字符串来确定更改通知的来源，但是这种方法可能会导致其超类也因不同原因观察到相同密钥路径的对象出现问题。</p><p>一个更安全且具有扩展性的方法是使用<code>content</code>来确保你收到的通知就是发给你的而不是超类的。</p><p>类中唯一命名的静态（static）变量的地址是一个很好的content。在超类或子类中以类似的方式选择的上下文不太可能重叠。您可以为整个类选择同一个上下文，并根据通知消息中的key path字符串来确定更改的内容；或者，您可以为每个观察到的密钥路径创建不同的上下文，从而完全绕过字符串比较的需要，从而实现更有效的通知解析。<br><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">- (<span class="keyword">void</span>)registerAsObserver &#123;</span><br><span class="line">    BankAccount *myAccount = [[BankAccount alloc] init];</span><br><span class="line">    [myAccount addObserver:<span class="keyword">self</span> forKeyPath:<span class="string">@"currBalance"</span> options:<span class="built_in">NSKeyValueObservingOptionInitial</span> | <span class="built_in">NSKeyValueObservingOptionNew</span> | <span class="built_in">NSKeyValueObservingOptionOld</span> | <span class="built_in">NSKeyValueObservingOptionPrior</span> context:PersonAccountBalanceContext];</span><br><span class="line">    myAccount.currBalance = @<span class="number">100</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>注意，<strong>键值观察<code>addObserver:forKeyPath:options:context:</code>方法不对观察者、被观察的对象、上下文保持强引用。如需要，你应该对它们保持强引用。</strong></p><h3 id="接受改变的通知"><a href="#接受改变的通知" class="headerlink" title="接受改变的通知"></a>接受改变的通知</h3><p>当对象的被观察属性值改变的时候，观察者对象会收到<code>observeValueForKeyPath:ofObject:change:context:</code>消息。所有的观察者必须实现这个方法。</p><p>观察对象提供触发通知的key path，自身作为<code>object</code>，<code>change</code>字典包含改变的细节，并且<code>context</code>指针就是观察者被注册时提供的。</p><p><code>NSKeyValueChangeKindKey</code>提供改变类型的信息。<code>NSKeyValueChangeKindKey</code>表示观察对象的值已更改。如果观察的属性是一个对多的关系，<code>NSKeyValueChangeInsertion</code>/<code>NSKeyValueChangeRemoval</code>/<code>NSKeyValueChangeReplacement</code>分别表示集合的插入、删除、替换操作。<code>NSKeyValueChangeIndexesKey</code>表示集合中已更改内容的<code>NSIndexSet</code>。<br><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">- (<span class="keyword">void</span>)observeValueForKeyPath:(<span class="built_in">NSString</span> *)keyPath ofObject:(<span class="keyword">id</span>)object change:(<span class="built_in">NSDictionary</span>&lt;<span class="built_in">NSKeyValueChangeKey</span>,<span class="keyword">id</span>&gt; *)change context:(<span class="keyword">void</span> *)context &#123;</span><br><span class="line">    <span class="keyword">if</span> (context == PersonAccountBalanceContext) &#123;</span><br><span class="line">        <span class="built_in">NSLog</span>(<span class="string">@"PersonAccountBalanceContext 对应的属性改变了"</span>);</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (context == PersonAccountTransactionContext) &#123;</span><br><span class="line">        <span class="keyword">if</span> ([change[<span class="built_in">NSKeyValueChangeKindKey</span>] unsignedIntValue] == <span class="built_in">NSKeyValueChangeSetting</span>) &#123;</span><br><span class="line">            <span class="built_in">NSLog</span>(<span class="string">@"集合内容赋值 索引为：%@"</span>, change[<span class="built_in">NSKeyValueChangeIndexesKey</span>]);</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> ([change[<span class="built_in">NSKeyValueChangeKindKey</span>] unsignedIntValue] == <span class="built_in">NSKeyValueChangeInsertion</span>) &#123;</span><br><span class="line">            <span class="built_in">NSLog</span>(<span class="string">@"集合内容插入 索引为：%@"</span>, change[<span class="built_in">NSKeyValueChangeIndexesKey</span>]);</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> ([change[<span class="built_in">NSKeyValueChangeKindKey</span>] unsignedIntValue] == <span class="built_in">NSKeyValueChangeRemoval</span>) &#123;</span><br><span class="line">            <span class="built_in">NSLog</span>(<span class="string">@"集合内容删除 索引为：%@"</span>, change[<span class="built_in">NSKeyValueChangeIndexesKey</span>]);</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> ([change[<span class="built_in">NSKeyValueChangeKindKey</span>] unsignedIntValue] == <span class="built_in">NSKeyValueChangeReplacement</span>) &#123;</span><br><span class="line">            <span class="built_in">NSLog</span>(<span class="string">@"集合内容替换 索引为：%@"</span>, change[<span class="built_in">NSKeyValueChangeIndexesKey</span>]);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h3 id="移除观察者对象"><a href="#移除观察者对象" class="headerlink" title="移除观察者对象"></a>移除观察者对象</h3><p>通过想观察者发送<code>removeObserver:forKeyPath:context</code>消息来移除观察者对象。收到该消息后，观察者对象将不再接收任何<code>observerValueForKeyPath:ofObject:change:context</code>中指定key path/object的消息。</p><p>删除观察者时，注意：</p><ul><li><strong>移除和添加的方法要保持对称</strong>，否则会引发异常。如果无法保持对称，则把移除的方法放到try/catch块中。</li><li>对象释放时，不会自动把自己从观察者中移除，此时被观察者继续发送通知。但是就像任何其他消息一样，改变的通知发送给了已经释放的对象会触发内存访问异常。因此，<strong>务必在观察者从内存中消失前，将其移除</strong></li><li>协议没有提供方法来查询一个对象是否是观察者或被观察者。你必须在代码中自行避免错误。典型的方案是在观察者初始化期间（init或dealloc）注册为观察者，并在释放时（dealloc）注销。</li></ul><h2 id="兼容KVO"><a href="#兼容KVO" class="headerlink" title="兼容KVO"></a>兼容KVO</h2><p>为了让特定属性符合KVO标准，class必须满足一下内容：</p><ul><li>该类必须是符合该属性的KVC</li><li>该类会为该属性触发KVO通知</li><li>相关的key已经被成功注册</li></ul><p>有两种技术可确保发出KVO通知。NSObject提供自动支持，默认情况下可用于符合键值编码的类的所有属性。通常，如果你遵守Cocoa编码和命名约定，则可以使用自动通知，而不必编写任何代码。</p><p>手动方式为通知触发时提供了更多的控制权，并且需要额外编码。你可以通过实现<code>automaticallyNotifiesObserversForKey:</code>来控制子类属性的自动通知。</p><h3 id="自动通知"><a href="#自动通知" class="headerlink" title="自动通知"></a>自动通知</h3><p>下列方法列举了会触发自动通知的一些场景：<br><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//调用访问器方法。</span></span><br><span class="line">[account setName：@“Savings”];</span><br><span class="line"> </span><br><span class="line"><span class="comment">//使用setValue：forKey：。</span></span><br><span class="line">[account setValue：@“Savings”forKey：@“name”];</span><br><span class="line"> </span><br><span class="line"><span class="comment">//使用密钥路径，其中'account'是'document'的kvc兼容属性。</span></span><br><span class="line">[document setValue：@“Savings”forKeyPath：@“account.name”];</span><br><span class="line"> </span><br><span class="line"><span class="comment">//使用mutableArrayValueForKey：检索关系代理对象。</span></span><br><span class="line">Transaction * newTransaction = &lt;＃为帐户＃&gt;创建新交易;</span><br><span class="line"><span class="built_in">NSMutableArray</span> * transactions = [account mutableArrayValueForKey：@“transactions”];</span><br><span class="line">[transactions addObject：newTransaction];</span><br></pre></td></tr></table></figure></p><h3 id="手动通知"><a href="#手动通知" class="headerlink" title="手动通知"></a>手动通知</h3><p>有些情况下，你可能想要控制通知的过程，例如，最大限度减少因应用程序特定原因而不必要的触发通知，或把一组通知整合到一个。</p><p>手动通知和自动通知不是互斥的。手动和自动的通知可以同时触发。如果你只想要手动触发，则需要通过重写<code>automaticallyNotifiesObserversForKey:</code>方法来禁止自动通知。<br><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">+ (<span class="built_in">BOOL</span>)automaticNotifiesObserversForKey:(<span class="built_in">NSString</span> *)theKey &#123;</span><br><span class="line">    <span class="built_in">BOOL</span> automatic = <span class="literal">NO</span>;</span><br><span class="line">    <span class="keyword">if</span> ([theKey isEqualToString：@“balance”]) &#123;</span><br><span class="line">        automatic = <span class="literal">NO</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">        automatic = [<span class="keyword">super</span> automaticNotifiesObserversForKey: theKey];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> automatic;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>**要实现手动观察者通知，你要在值改变前调用<code>willChangeValueForKey:</code>，并在值改变后调用<code>didChangeValueForKey:</code>。有三组类似的方法：</p><ul><li><code>willChangeValueForKey:</code>和<code>didChangeValueForKey:</code>。用于单个对象</li><li><code>willChange:valuesAtIndexes:forKey:</code>和<code>didChange:valuesAtIndexes:forKey:</code>。用于有序集合</li><li><code>willChangeValueForKey:withSetMutation:usingObjects:</code>和<code>willChangeValueForKey:withSetMutation:usingObjects:</code>。用于无须集合</li></ul><p>下面在访问器方法中手动触发：<br><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">- (<span class="keyword">void</span>)setBalance:(<span class="keyword">double</span>)theBalance &#123;</span><br><span class="line">    [<span class="keyword">self</span> willChangeValueForKey:<span class="string">@"balance"</span>];</span><br><span class="line">    _balance = theBalance;</span><br><span class="line">    [<span class="keyword">self</span> didChangeValueForKey:<span class="string">@"balance"</span>];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>为了减少不必要的通知，可以先检查值是否改变了，然后决定是否发通知：<br><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">- (<span class="keyword">void</span>)setBalance:(<span class="keyword">double</span>)theBalance &#123;</span><br><span class="line">    <span class="keyword">if</span> (theBalance != _balance) &#123;</span><br><span class="line">        [<span class="keyword">self</span> willChangeValueForKey:<span class="string">@"balance"</span>];</span><br><span class="line">        _balance = theBalance;</span><br><span class="line">        [<span class="keyword">self</span> didChangeValueForKey:<span class="string">@"balance"</span>];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>如果一个操作导致多个key发生改变，必须嵌套发送通知：<br><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">- (<span class="keyword">void</span>)setBalance:(<span class="keyword">double</span>)theBalance &#123;</span><br><span class="line">    [<span class="keyword">self</span> willChangeValueForKey:<span class="string">@"balance"</span>];</span><br><span class="line">    [<span class="keyword">self</span> willChangeValueForKey:<span class="string">@"itemChanged"</span>];</span><br><span class="line">    _balance = theBalance;</span><br><span class="line">    _itemChanged = _itemChanged+<span class="number">1</span>;</span><br><span class="line">    [<span class="keyword">self</span> didChangeValueForKey:<span class="string">@"itemChanged"</span>];</span><br><span class="line">    [<span class="keyword">self</span> didChangeValueForKey:<span class="string">@"balance"</span>];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>在有序的to-many关系中，除了指定更改的key，还不许指定更改的类型和所涉及对象的索引。<br><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">- (<span class="keyword">void</span>)removeTransactionsAtIndexes:(<span class="built_in">NSIndexSet</span> *)indexes &#123;</span><br><span class="line">    [<span class="keyword">self</span> willChange:<span class="built_in">NSKeyValueChangeRemoval</span></span><br><span class="line">        valuesAtIndexes:indexes forKey:<span class="string">@"transactions"</span>];</span><br><span class="line"> </span><br><span class="line">    <span class="comment">// Remove the transaction objects at the specified indexes.</span></span><br><span class="line"> </span><br><span class="line">    [<span class="keyword">self</span> didChange:<span class="built_in">NSKeyValueChangeRemoval</span></span><br><span class="line">        valuesAtIndexes:indexes forKey:<span class="string">@"transactions"</span>];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h2 id="注册从属keys"><a href="#注册从属keys" class="headerlink" title="注册从属keys"></a>注册从属keys</h2><p>在许多情况下，一个属性的值取决于另一个对象中的一个或多个其他属性的值。如果一个属性的值发生更改，则还应标记派生属性的值以进行更改。</p><h3 id="To-One-关系"><a href="#To-One-关系" class="headerlink" title="To-One 关系"></a>To-One 关系</h3><p>要为一对一关系自动触发通知，应该重写<code>keyPathsForValuesAffectingValueForKey</code>或实现一个合适的方法，该方法遵循它为注册依赖键定义的模式。</p><p>例如，<code>fullName</code>取决于<code>firstName</code>和<code>lastName</code>。返回<code>fullName</code>的方法可以写成如下：<br><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">- （<span class="built_in">NSString</span> *）fullName &#123;</span><br><span class="line">    <span class="keyword">return</span> [<span class="built_in">NSString</span> stringWithFormat：@“％@％@”，firstName，lastName];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>当<code>firstName</code>或<code>lastName</code>发生改变时，必须通知观察<code>fullName</code>属性的程序，因为它们影响这个属性的值。</p><p>一个解决方案是重写<code>keyPathsForValuesAffectingValueForKey</code>来指定<code>fullName</code>属性依赖于<code>lastName</code>和<code>firstName</code>。<br><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">+ (<span class="built_in">NSSet</span> *)keyPathsForValuesAffectingValueForKey:(<span class="built_in">NSString</span> *)key &#123;</span><br><span class="line"> </span><br><span class="line">    <span class="built_in">NSSet</span> *keyPaths = [<span class="keyword">super</span> keyPathsForValuesAffectingValueForKey:key];</span><br><span class="line"> </span><br><span class="line">    <span class="keyword">if</span> ([key isEqualToString:<span class="string">@"fullName"</span>]) &#123;</span><br><span class="line">        <span class="built_in">NSArray</span> *affectingKeys = @[<span class="string">@"lastName"</span>, <span class="string">@"firstName"</span>];</span><br><span class="line">        keyPaths = [keyPaths setByAddingObjectsFromArray:affectingKeys];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> keyPaths;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>重写通常应该调用super并返回一个集合，以免影响超类中对此方法的重写。</p><p>通过重写<code>keyPathsForValuesAffecting&lt;Key&gt;</code>也可以达到相同的效果。<br><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">+ (<span class="built_in">NSSet</span> *)keyPathsForValuesAffectingFullName &#123;</span><br><span class="line">    <span class="keyword">return</span> [<span class="built_in">NSSet</span> setWithObjects:<span class="string">@"lastName"</span>, <span class="string">@"firstName"</span>, <span class="literal">nil</span>];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h3 id="To-many-关系"><a href="#To-many-关系" class="headerlink" title="To-many 关系"></a>To-many 关系</h3><p><code>keyPathsForValuesAffectingValueForKey:</code>方法不支持to-many关系的key paths。可以使用下面两种方案来处理to-many 关系：</p><ol><li><p>使用key-value observing注册父项作为子项的相关属性观察者。当子对象添加到关系或从关系中删除的时候，你必须添加或删除父对象。在<code>observeValueForKeyPath:ofObject:change:context:</code>方法中，你可以更新依赖值以相应更改，如下：</p><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">[<span class="keyword">self</span> addObserver:<span class="keyword">self</span> forKeyPath:<span class="string">@"transactions"</span> options:<span class="built_in">NSKeyValueObservingOptionNew</span> context:<span class="literal">NULL</span>];</span><br><span class="line"></span><br><span class="line">- (<span class="keyword">void</span>)observeValueForKeyPath:(<span class="built_in">NSString</span> *)keyPath ofObject:(<span class="keyword">id</span>)object change:(<span class="built_in">NSDictionary</span>&lt;<span class="built_in">NSKeyValueChangeKey</span>,<span class="keyword">id</span>&gt; *)change context:(<span class="keyword">void</span> *)context &#123;</span><br><span class="line">    <span class="built_in">NSLog</span>(<span class="string">@"amount = %@"</span>, [<span class="keyword">self</span> valueForKeyPath:<span class="string">@"transactions.@sum.amount"</span>]);</span><br><span class="line">    [<span class="keyword">self</span> setTotalConsumption:[<span class="keyword">self</span> valueForKeyPath:<span class="string">@"transactions.@sum.amount"</span>]];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>在Core Data中，则可以将父项作为其托管对象上下文的观察者注册到应用程序的通知中心。父项应以类似于键值观察的方式回应孩子们发布的相关变更通知。</p></li></ol><h2 id="Key-Value-Observing-的实现细节"><a href="#Key-Value-Observing-的实现细节" class="headerlink" title="Key-Value Observing 的实现细节"></a>Key-Value Observing 的实现细节</h2><p>自动key-value observing 是使用一种叫做<em>isa-swizzling</em>的技术实现的。</p><p><em>isa</em>指针指向维护一个调度表（dispatch table）的对象的类。该调度表包含了指向该类实现的方法的指针，以及其他数据。</p><p>当观察者注册对象的属性时，观察对象的isa指针被修改，指向中间类而不是真正的类。因此，isa指针的值不一定反映实例的实际类。</p><p>永远不要依赖isa指针来确定类成员。而应该使用<code>class</code>方法来决定实例所属的类。</p><h1 id="参考连接"><a href="#参考连接" class="headerlink" title="参考连接"></a>参考连接</h1><p><a href="https://github.com/shizhiang/KVC_KVO-Tutorial" target="_blank" rel="noopener">示例代码</a></p><p><a href="https://developer.apple.com/library/archive/documentation/Cocoa/Conceptual/KeyValueCoding/index.html#//apple_ref/doc/uid/10000107-SW1" target="_blank" rel="noopener">KVC</a></p><p><a href="https://developer.apple.com/library/archive/documentation/Cocoa/Conceptual/KeyValueObserving/KeyValueObserving.html#//apple_ref/doc/uid/10000177-BCICJDHA" target="_blank" rel="noopener">KVO</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;KVC&quot;&gt;&lt;a href=&quot;#KVC&quot; class=&quot;headerlink&quot; title=&quot;KVC&quot;&gt;&lt;/a&gt;KVC&lt;/h1&gt;&lt;h2 id=&quot;Key-Value-Coding基本原则&quot;&gt;&lt;a href=&quot;#Key-Value-Coding基本原则&quot; class=&quot;
      
    
    </summary>
    
      <category term="iOS" scheme="http://www.iosprogrammer.tech/categories/iOS/"/>
    
    
  </entry>
  
  <entry>
    <title>程序员读《增长黑客》</title>
    <link href="http://www.iosprogrammer.tech/Growth-Hacker-FanBing/"/>
    <id>http://www.iosprogrammer.tech/Growth-Hacker-FanBing/</id>
    <published>2018-10-21T02:57:35.000Z</published>
    <updated>2020-12-08T09:43:09.790Z</updated>
    
    <content type="html"><![CDATA[<p><img src="http://image.iosprogrammer.hongbility.com/Books/%E3%80%8A%E5%A2%9E%E9%95%BF%E9%BB%91%E5%AE%A2%E3%80%8B%E5%B0%81%E9%9D%A2.jpg-200" alt="封面"></p><h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>增长黑客，一群以数据驱动营销、以市场指导产品，通过<strong>技术手段</strong>贯彻增长目标的人。既然增长黑客把技术作为达成目标的工具，那作为一个以技术为生的程序员当然需要了解这一行业。</p><p>增长黑客最早在2010年由Qualaroo的创始人兼首席执行官肖恩·埃利斯提出，之后由安德鲁·陈在2012年4月发表的《Growth Hacker is the new VP Marketing》后引起业界广泛关注与交流，之后在国外尤其是硅谷的各家创业公司中开始设置类似职位并为各公司的发展提供了不可估量的作用。</p><p>但是在国内增长黑客的概念一直没有得到广泛的认识和发展，范冰的《增长黑客》一书正是作为一本启蒙书的形式被广泛认可。作为一名混迹互联网公司略有年头的技术人员，笔者有幸拜读此书并通过本文将书中内容总结出来作为“读后感”。希望为一些想要扩展视野的同行提供些许的帮助。</p><h1 id="内容简介"><a href="#内容简介" class="headerlink" title="内容简介"></a>内容简介</h1><p>根据书中章节和一些重点内容整理的思维导图：<br><img src="http://image.iosprogrammer.hongbility.com/Books/增长黑客.png-small" alt="思维导图"></p><p>《增长黑客》以互联网行业九死一生的环境为开端。“在国内，中小企业的平均寿命只有3.7年，小微企业还不到3年。至于创业门槛相对较低的互联网行业，能够幸存的比例甚至更低。”让读者深切体会到行业的残酷、活下去的艰难。并且直言众多互联网创业失败的原因在产品问世伊始就已经注定了。之后借助Hotmail仅仅通过在每封邮件的末尾加上一句“快来Hotmail申请你的免费邮箱”便在实现三周获取了30万用户的奇迹，来证明在互联网使用低成本驱动产品的方法是存在的，而发明这些方法的人就是<strong>增长黑客</strong>。</p><p>之后对增长黑客下了定义：增长黑客是一群以数据驱动营销、以市场指导产品，通过技术化手段贯彻增长目标的人。或许，《Growth Hacker is the new VP Marketing》一书中则定义了增长黑客们的工作内容：增长黑客们试图用更聪明的方式解答产品得以增长的奥秘，并使之成为助力产品增长的长效机制。他们通常采用的手段包括A/B测试、搜索引擎优化、电子邮件召回、病毒营销等，而页面加载速度、注册转化率、E-mail到达水平、病毒因子这些指标成为他们日常关注的对象。从中可以看出，增长黑客离不开对技术的使用，因此<strong>程序员可能是最接近和容易成为增长黑客的一群人</strong>。</p><p>紧接着提出了“AARRR”转化漏斗模型，即：Acquisition（获取用户）、Activiation（激发活跃）、Retention（提高留存）、Revenue（增加收入）、Referral（传播推荐）。后面的几章正是按照这个模型进行谋篇布局的。这个模型也贯穿了一个互联网产品的整个生命周期，并且在任何一个阶段都可能让一个产品折戟沉沙。</p><h2 id="创造正确的产品"><a href="#创造正确的产品" class="headerlink" title="创造正确的产品"></a>创造正确的产品</h2><p>任何营销、推广都是围绕着产品进行的，<strong>一款定位准确、可靠的产品是一切的开端和基石</strong>。</p><p>任何一款互联网产品被创造出来都只有一个目的那就是满足用户需求，PMF（产品与市场契合状态）就是用来描述产品对需求的满足程度的。最小化可行产品（MVP）是验证产品设想的不二之选。</p><p>最小化可行产品除了包含整个产品闭环的核心功能外，还需要为用户提供反馈渠道、方便查看的官方公告模块。其中核心功能比较难把握，在这里说一下我的理解，所谓核心功能应该是刚好可以满足产品闭环的基础功能，比如淘宝的核心功能应该就是浏览商品、下单，至于评价、物流，甚至购物车、搜索都不是核心功能；微信的核心功能就是加好友、文字聊天。通过对核心功能的梳理可以看出，真正的核心功能也正是一个产品的核心价值，它们也回答了一个产品是什么、是做什么的。</p><p>MVP提炼的好可以节省很多前期投入、更快的验证想法，但是在这个过程中也一定不能放松对产品质量的要求，可以不花哨一定要耐用。至于反馈渠道和官方公告就是为了让用户能够便捷的和产品沟通，提升用户的参与感，也能帮助产品更快更好的找到PMF。</p><p>“咕咚小区”在产品还没有满足PMF的前提下就花费大笔资金铺广告最后惨淡收场的例子恰好从反面证明了PMF的重要性。</p><p>用户调研的结果不可尽信。用户调研贯穿于产品的任何一个节点，形式是多种多样的，对产品的影响也是至关重要的。但是由于用户质量的参差不齐、目的不一，就造成用研的结果可能并不能真正反映用户在未来的做法。不要看用户说了什么，要看他们做了什么。</p><h2 id="获取用户"><a href="#获取用户" class="headerlink" title="获取用户"></a>获取用户</h2><p>获取用户，<strong>让潜在用户首次接触到产品</strong>。</p><p>首先获取的范围是潜在用户。应该根据产品的定位来寻找潜在用户，一款定位是年轻女性的产品，男性和大龄女性就不应该是潜在用户，不通物流的地区的用户就不是淘宝的潜在用户。抖音的潜在用户可以是所有的互联网用户，但是在产品早期应该把范围缩小到最容易传播、网络条件较好、网费较便宜的一批用户。</p><p>潜在的种子用户使用产品的过程称为产品的“冷启动”，它是在产品尚不具备完善的生态体系并<strong>能够提供足够多可消费内容</strong>的情况下，从零开始第一批用户和制造内容的过程。这个过程的前提是需要产品的提供方准备足够多的可供种子用户消费的内容，这些内容为种子用户将来要提供的内容的一个基调，种子用户提供的内容又会奠定产品在随后发展过程中的“逼格”，因此产品方既要提供足够多的内容供消费又要保证内容的质量。</p><p>给种子用户设置一定的门槛可能会有意想不到的效果。知乎早期的邀请码和小米的饥饿营销都为用户的入驻和体验设置了更高的门槛，但是却使产品获得了快速的传播，种子用户也为产品提供了一批优质的内容和良好的口碑。</p><p>在获取种子用户的过程中，需要警惕“产品蝗虫的出现”，这批用户是指那些产品目标以外的围观群体，他们可能是单纯好奇的观光客、寻找项目的投资人或是来做竞品调研的产品经理。由于产品前期的用户体量较小，“蝗虫”又有很强的嗅觉，就可能导致产品中出现大量的垃圾内容而影响正常用户的使用。社交产品最可能成为重灾区，早期的微信和子弹短信都曾被黄、赌的蝗虫充斥。</p><p>书中例举了很多获取用户的方法：利用社交网络、内容营销、搜索引擎和应用商店优化、饥饿营销、地推、海外扩张。其中有一些方案可能是被人嗤之以鼻的，比如无良小编的耸动标题、刷榜，但是这些方法却都是行之有效的。</p><h2 id="激发活跃"><a href="#激发活跃" class="headerlink" title="激发活跃"></a>激发活跃</h2><p>潜在用户接触产品后，获取用户的职责也就结束了，这时候用户对平台的忠诚度还很低，只有让用户参与到平台中来，他们才会拥护平台，平台才能出现生机。在MVP中留下反馈建议的入口也是为了让用户参与到平台的建设中来，往往能够为平台提意见的用户就是对平台最忠诚的。</p><p>LinkedIn通过优化新用户注册后邀请用户的数量、给好友发邮件的文案和导入邮箱通讯录的方式来一步步的激发了用户活跃，之后又加入了“声誉”系统把不活跃的用户调动起来，才建立了遍布全球的职场平台。</p><p>A/B测试是一种可以从多个备选方案选出较优的一种的解决方法，它常用于减少页面障碍、提升转化率、确定改版方案、新功能的小范围测试。</p><p>在产品中增加游戏化的元素是一种激发活跃的有效手段。现在产品中随处可见的签到、徽章、积分等元素正是游戏化的例证。这些方案不仅促进了用户的活跃度，而且用户也喜欢分享这些游戏化的“里程碑”，从而又能让产品利用社交化的渠道来获取用户。</p><p>此外，除了工具类的产品外，用户之间都会产生交互，这对于一个用户量不够大的产品是一个硬伤，很多产品也都倒在了这里。自动化脚本，或许是一种解决方案，它可以利用提前准备好的程序来和真实的用户沟通。游戏里面的“机器人”、微博等平台的“僵尸粉”都是活生生的例子，但是对脚本的使用也要把握好，不然会让用户产生反感。</p><h2 id="提高留存"><a href="#提高留存" class="headerlink" title="提高留存"></a>提高留存</h2><p>一鸟在手，胜过双鸟在林。在商业社会中5%的客户留存率增长意味着公司利润30%的增长，把产品卖给老客户的概率是卖给新客户的3倍。</p><p>造成用户留存率低的原因包括：</p><ol><li>存在程序漏洞、性能瓶颈。影响正常使用流程的程序漏洞是最容易引发客户流失的原因。淘宝为了满足海量用户的访问需求耗时几年建设了阿里云，12306至今没有完美解决宕机的问题等等。其中，连接超时、卡顿、黑屏、网络卡顿、交互性能差、CPU使用率高、内存泄漏、耗电过多等问题，都会让用户产生反感。</li><li>用户被频繁骚扰。微博在一段时间内对用户频繁推送轰炸，引起一片骂声，现在大多数推送内容都是关注的内容。即刻的出现也是为了解决信息过量的问题。但是，推送和关注量挂钩也对用户的关注行为产生了负面影响，为了避免过多的推送用户不得不谨小慎微的发起关注。经调查，女性用户对推送的容忍度要高于男性。</li><li>话题产品的热度减退。复仇者联盟的上映带火了一批以此为主题的游戏，但是随着话题产品的热度减退，类似产品的热度也会下降，用户又去追寻另一个热点了。</li><li>有更好的替代品。谷歌在国内最终被百度打败，eBay也因为水土不服败给淘宝，小咖秀、美拍等老牌短视频平台被抖音、快手两个后起之秀秒杀等例子先后上演。随着互联网用户增长的乏力，对已有用户的争夺战更加趋于白热化。</li><li>游戏通关、设备遗失、需求不再存在、产品生命周期终结等其他因素。</li></ol><p>留存率的衡量标准：次日留存率、7日留存率、30日留存率，分别反映了不同的含义。渠道留存，反映了在不同渠道的推广效果。</p><p>提高留存的方案：</p><ol><li>优化产品性能。由于网络和设备的性能千差万别，同一款产品在不同设备上的表现可能大相径庭，为了让产品能够在性能较差的设备上表现出较好的体验就需要团队不断优化。</li><li>有损服务。随着用户量的增加，产品所提供的服务容量越来越捉襟见肘，团队的预算也不是无限的，这就要求产品的生产者不得不舍弃一些特性。</li><li>引导新用户快速上手。对刚接触产品的新用户来说，获取产品内容的路径应该是尽量短的，注册、登录的流程应尽量简洁，尤其是首页的布局应该尽量清晰、突出主要功能。社区型产品适当引导新用户关注一些高质量的内容避免空白的瀑布流。</li><li>召回老用户。最有效的方式当属短信、邮件的唤回，内容包括 提供奖励、告知进展、个性化推荐、用户社交互动展示。探探会给老用户发送一条”近期被N个美女喜欢的短息”；招聘类网站会发送正有N个Boss查看JD的短信或邮件。</li></ol><h2 id="增加收入"><a href="#增加收入" class="headerlink" title="增加收入"></a>增加收入</h2><p>我们每天所需的食物和饮料，不是出自屠户、酿酒师或面包师的恩惠，而是出于他们自利的打算。我们不要求助于他们的爱他心，只要求助于他们的自爱心。我们不要向他们说我们必需，只说他们有利。这句出自《国富论》的经典语句，和《影响力》中的论点不谋而合。完美的诠释了“天下熙熙皆为利来，天下攘攘皆为利往”。</p><p>在完全竞争市场，长期产品的市场出清价格等于该产品的边际成本。互联网产品的边际成本极低甚至可以趋近于零。正因为如此，很多产品都采用免费策略来吸引用户。</p><p>免费产品的赚钱方式包括：增值付费、交叉补贴、广告、公司上市或被收购。</p><p>免费模式固然容易被用户接受，但是也这个因为用户的体验成本太低造成了对产品的低忠诚度和低迁移成本。当免费模式获取到过多的用户时，就造成了更多的维护和营销成本，但是纵然有很多的变现模式，想让用户掏第一分钱确是最难的。</p><p>找不到好的变现模式最终可能会拖垮一个产品。陌陌、抖音、豆瓣这些“国民级”的产品都还在变现的道路上艰难摸索，既要维持用户的脆弱心理又要获取盈利的两难局面很难平衡。</p><p>对于一些小而美的产品来说，用户量并不是最主要的，养活自己才是第一要务，因此它们选择了付费模式。在App Store的付费下载中有一些活的很滋润的付费产品。付费产品的门槛高也促进了用户对平台的忠诚度更高，产品拿了用户的钱也有更强的动力为用户提供更好的服务。</p><h2 id="病毒传播"><a href="#病毒传播" class="headerlink" title="病毒传播"></a>病毒传播</h2><p>病毒传播的两大核心指标是K因子和病毒循环周期。K因子=感染率*转化率，感染率是指某个用户向其他人传播产品的程度，转化率是指被感染人转化成新用户的比例。病毒循环周期是指从用户发出邀请，到新用户完成转化所花费的时间。</p><p>病毒传播中的用户心理把握</p><ol><li>人们总是比较愿意答应自己认识和喜欢的人提出的请求，还乐意主动传播自己喜爱的事物。这一点促使一些产品花重金请明星大咖做广告，或引导用户把内容分享到社交群。</li><li>逐利。趣头条的读新闻奖现金就是很好的利用了这一点。</li><li>互惠。拼多多。</li><li>求助。微信小游戏的分享泛滥。</li><li>炫耀。Keep健身打卡分享、英语流利说完成关卡分享、王者荣耀高光时刻分享。</li><li>稀缺。小米的饥饿营销。</li><li>害怕失去或错过。双十一、618。</li></ol><h1 id="个人感悟"><a href="#个人感悟" class="headerlink" title="个人感悟"></a>个人感悟</h1><ol><li>书中多次提高了Hotmail等邮件公司的创业，这些公司最终发展都不错，但是在中国却很少听说独立的邮件公司，或许是因为邮件的沟通方式在美国和中国的地位截然不同，国内互联网起步较晚，跨过了以邮件为主要沟通方式的阶段而直接买入了IM的形式</li><li>看到产品的人中有很少的一部分会成为用户，又会有更少的一部分会留下来，产品最终的收入来自更少的一部分用户。</li><li>从书中描述来看，Facebook为第三方平台提供的信息要比微信等国内平台所提供的丰富的多，这也促成了很多国外的产品借助社交平台发展壮大。从这点来看国内的大平台自信不足。</li><li>流量越来越便宜促进了直播、短视频行业的兴起。</li><li>作为程序员应该尽力优化产品的性能。据亚马逊的统计数据表明，网站的打开时间每多延迟100毫秒，就意味着多造成100万美元的营收损失，这都是真金白银啊。</li><li>书中多次提到了A/B测试和灰度发布，使用这些手段可以有效的避免对大面积用户的影响。作为一名程序员不应该因为这些工作看上去是无用功而产生排斥心理。证明不可行和证明可行同样重要。</li></ol><h1 id="附"><a href="#附" class="headerlink" title="附"></a>附</h1><p><a href="http://image.iosprogrammer.hongbility.com/Books/增长黑客.png" target="_blank" rel="noopener">思维导图大图</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;&lt;img src=&quot;http://image.iosprogrammer.hongbility.com/Books/%E3%80%8A%E5%A2%9E%E9%95%BF%E9%BB%91%E5%AE%A2%E3%80%8B%E5%B0%81%E9%9D%A2.jpg-20
      
    
    </summary>
    
      <category term="其他" scheme="http://www.iosprogrammer.tech/categories/%E5%85%B6%E4%BB%96/"/>
    
    
  </entry>
  
  <entry>
    <title>iOS内存管理</title>
    <link href="http://www.iosprogrammer.tech/iOS-Memory-Management/"/>
    <id>http://www.iosprogrammer.tech/iOS-Memory-Management/</id>
    <published>2018-10-03T04:42:21.000Z</published>
    <updated>2020-07-09T05:24:30.476Z</updated>
    
    <content type="html"><![CDATA[<p>本文内容是对<a href="https://developer.apple.com/library/archive/documentation/Cocoa/Conceptual/MemoryMgmt/Articles/MemoryMgmt.html#//apple_ref/doc/uid/10000011-SW1" target="_blank" rel="noopener">Advanced Memory Management Programming Guide</a>中重点内容的总结</p><h2 id="内存管理策略"><a href="#内存管理策略" class="headerlink" title="内存管理策略"></a>内存管理策略</h2><h3 id="基本内存管理规则"><a href="#基本内存管理规则" class="headerlink" title="基本内存管理规则"></a>基本内存管理规则</h3><p>内存管理模型基于对象所有权的。任何对象可能有一个或多个所有者。对象只要有超过一个所有者就会继续存在；如果一个对象没有所有者了，运行时系统就会把它销毁。为了让开发者清楚自己什么时候拥有/不拥有对象，Cocoa设置了一些规则：</p><ul><li>你拥有你创建的对象 - You own any object you create<blockquote><p>使用以”alloc”, “new”, “copy”, “mutableCopy”开头的方法创建对象</p></blockquote></li><li>你可以使用retain来获取对象的所有权<blockquote><p>可以在两种情况下使用<code>retain</code>：（1）在存储器方法的实现或者<code>init</code>方法中，获取要作为属性值存储的对象的所有权；（2）避免某些操作的副作用造成对象不可用</p></blockquote></li><li>当你不再需要的时候，一定要放弃对象所有权<blockquote><p>给对象发送<code>release</code>/<code>autorelease</code>消息来放弃所有权。因此，在Cocoa术语中，把放弃所有权称为”releasing”一个对象</p></blockquote></li><li>一定不能放弃你没有所有权的对象</li></ul><h2 id="内存管理实战"><a href="#内存管理实战" class="headerlink" title="内存管理实战"></a>内存管理实战</h2><h3 id="使用存储器方法来使内存管理更容易"><a href="#使用存储器方法来使内存管理更容易" class="headerlink" title="使用存储器方法来使内存管理更容易"></a>使用存储器方法来使内存管理更容易</h3><p>如果你的类有一个对象属性，你必须确保被设置的对象在使用过程中不会被释放。因此在它被设置的时候，你必须声明对它的所有权。并且你必须确保之后放弃对当前持有值的所有权。虽然这样做有时候是冗长乏味的，但是如果你坚持这种方法，就可以显著减少内存管理问题。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">@interface Counter : NSObject</span><br><span class="line">@property (nonatomic, retain) NSNumber *count;</span><br><span class="line">@end;</span><br></pre></td></tr></table></figure><blockquote><p>这个<code>property</code>声明了一对存取器方法。通常，我们应当让编译器合成这些方法；但是，看一下它们是怎么实现的会很有意义。</p></blockquote><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">- (<span class="built_in">NSNumber</span> *)count &#123;</span><br><span class="line">    <span class="keyword">return</span> _count;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>“get”存取器只是返回了合成的实例变量并不需要<code>retain</code>或者<code>release</code></p></blockquote><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">- (<span class="keyword">void</span>)setCount:(<span class="built_in">NSNumber</span> *)newCount &#123;</span><br><span class="line">    [newCount <span class="keyword">retain</span>];</span><br><span class="line">    [_count release];</span><br><span class="line">    <span class="comment">// Make the new assignment.</span></span><br><span class="line">    _count = newCount;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>“set”存取器需要先<code>retain</code>新值，之后<code>release</code>旧值，最后进行赋值操作。为了避免前后是同一个对象的情况下出现意外的问题，必须要在<code>realse</code>之前调用<code>retain</code>。</p></blockquote><h3 id="不要在初始化和dealloc方法中使用存取器方法"><a href="#不要在初始化和dealloc方法中使用存取器方法" class="headerlink" title="不要在初始化和dealloc方法中使用存取器方法"></a>不要在初始化和dealloc方法中使用存取器方法</h3><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">- init &#123;</span><br><span class="line">    <span class="keyword">self</span> = [<span class="keyword">super</span> init];</span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">self</span>) &#123;</span><br><span class="line">        _count = [[<span class="built_in">NSNumber</span> alloc] initWithInteger:<span class="number">0</span>];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">self</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- initWithCount:(<span class="built_in">NSNumber</span> *)startingCount &#123;</span><br><span class="line">    <span class="keyword">self</span> = [<span class="keyword">super</span> init];</span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">self</span>) &#123;</span><br><span class="line">        _count = [startingCount <span class="keyword">copy</span>];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">self</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (<span class="keyword">void</span>)dealloc &#123;</span><br><span class="line">    [_count release];</span><br><span class="line">    [<span class="keyword">super</span> dealloc];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="使用弱引用来避免循环引用"><a href="#使用弱引用来避免循环引用" class="headerlink" title="使用弱引用来避免循环引用"></a>使用弱引用来避免循环引用</h3><p>只有当对象的所有强引用都释放后对象才能被释放，如果两个对象互相强引用了彼此，那么它们都不会被释放，这样就造成了<strong>循环引用</strong><br><img src="https://developer.apple.com/library/archive/documentation/Cocoa/Conceptual/MemoryMgmt/Art/retaincycles_2x.png" alt="循环引用"><br>弱引用可以解决循环引用的问题。弱引用是<em>non-owning</em>的关系。为了保持对象至少有一个引用而不被释放，不能把所有引用都设置成弱引用。因此，Cocoa建立了一个惯例，“parent”对象对“children”对象持有强引用，而children对象弱引用parent对象。如上图表示的一样。</p><p>当向弱引用的对象发送消息时一定要消息。如果向已经释放的兑现发送消息时会引起崩溃。这里特别注意的是：通知中心。当向NotificationCenter注册观察者时，通知中心会持有观察者的弱引用，如果观察者释放时没有主动从通知中心移除自己，通知中心会在之后向被释放掉的观察者发送消息，这时候会引起崩溃。（文档中还提到了delegate，但是在ARC下我们使用weak来修饰，就不会引起问题了。）</p><h3 id="避免正在使用的对象被释放"><a href="#避免正在使用的对象被释放" class="headerlink" title="避免正在使用的对象被释放"></a>避免正在使用的对象被释放</h3><p>下面两种情况是需要特别注意的：</p><ol><li><p>当一个对象从集合中移除的时候：</p><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">heisenObject = [array objectAtIndex:n];</span><br><span class="line">[array removeObjectAtIndex:n];</span><br><span class="line"><span class="comment">// heisenObject could now be invalid.</span></span><br></pre></td></tr></table></figure><blockquote><p>对象从集合中移除的时候，会收到<code>release</code>消息（而不是<code>autorelease</code>）。如果集合是对象的唯一持有者，这个对象会被立即释放。</p></blockquote></li><li><p>“parent object”释放</p><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">id</span> parent = &lt;<span class="meta">#create a parent object#&gt;;</span></span><br><span class="line"><span class="comment">// ...</span></span><br><span class="line">heisenObject = [parent child] ;</span><br><span class="line">[parent release]; <span class="comment">// Or, for example: self.parent = nil;</span></span><br><span class="line"><span class="comment">// heisenObject could now be invalid.</span></span><br></pre></td></tr></table></figure><blockquote><p>一个对象是由另一个对象生成的，之后直接或者间接的释放了父对象。如果这个释放导致了父对象的销毁，并且父对象是子对象的唯一持有者，那么子对象也会同时被销毁。</p></blockquote></li></ol><p>要想避免这些情况，我们可以<code>retain heisenObject</code>。比如：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">heisenObject = [[array objectAtIndex:n] retain];</span><br><span class="line">[array removeObjectAtIndex:n];</span><br><span class="line">// Use heisenObject...</span><br><span class="line">[heisenObject release];</span><br></pre></td></tr></table></figure></p><h3 id="不要使用dealloc管理稀缺资源"><a href="#不要使用dealloc管理稀缺资源" class="headerlink" title="不要使用dealloc管理稀缺资源"></a>不要使用dealloc管理稀缺资源</h3><p>不要在<code>dealloc</code>方法中管理文件描述符、网络连接、缓存或者缓冲区等稀有资源。特别是，类中的<code>dealloc</code>方法不是你认为会调用的时候就会调用。<code>dealloc</code>的调用可能会由于bug或者应用“tear-down”造成延迟或者不调用。</p><p>相反地，如果你有一个类的实例来管理稀缺资源，你应该把你的应用设计成当资源不在需要的时候调用“clean up”方法来清理资源，之后释放实例，<code>dealloc</code>会紧接着调用，这样的话，即使<code>dealloc</code>没有调用也不会引起其他问题。</p><p>如果在<code>dealloc</code>中管理稀缺资源可能会引起几个问题：</p><ol><li>对象图拆卸的顺序依赖性<br> 对象图的拆卸链是没有固定顺序的。</li><li>不回收稀缺资源<br> 内存泄露是应该被解决的bug，但是他们不会立即致命。如果稀缺资源没有按照预先设计的正常释放，可能会引起更严重的问题。比如，如果应用程序的文件描述符耗尽了，用户可能将无法保存数据。</li><li>在错误的线程上执行清理逻辑<br> 如果一个对象在意外时间自动释放，它将在它碰巧所在的任何线程的自动释放池块中被释放。对于只能从一个线程触及的资源，这中情况是非常严重的问题。</li></ol><h3 id="集合拥有它们包含的对象"><a href="#集合拥有它们包含的对象" class="headerlink" title="集合拥有它们包含的对象"></a>集合拥有它们包含的对象</h3><p>当把一个对象放到集合中（例如array，dictionary，set），集合会持有这个对象。当对象从集合中移除或者集合本身被释放的时候，集合会放弃所有权。因此，如果你想要创建一个“numbers”的数组时，可以这样做：<br><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">NSMutableArray</span> *array = &lt;<span class="meta">#Get a mutable array#&gt;;</span></span><br><span class="line"><span class="built_in">NSUInteger</span> i;</span><br><span class="line"><span class="comment">// ...</span></span><br><span class="line"><span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++) &#123;</span><br><span class="line">    <span class="built_in">NSNumber</span> *convenienceNumber = [<span class="built_in">NSNumber</span> numberWithInteger:i];</span><br><span class="line">    [array addObject:convenienceNumber];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>这样做，你没有调用<code>alloc</code>，因此不需要调用<code>release</code>。这里也不需要“retain”这些新的numbers，因为数组会这样做。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">NSMutableArray *array = &lt;#Get a mutable array#&gt;;</span><br><span class="line">NSUInteger i;</span><br><span class="line">// ...</span><br><span class="line">for (i = 0; i &lt; 10; i++) &#123;</span><br><span class="line">    NSNumber *allocedNumber = [[NSNumber alloc] initWithInteger:i];</span><br><span class="line">    [array addObject:allocedNumber];</span><br><span class="line">    [allocedNumber release];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>这种方式需要在<code>for</code>循环内<code>[allocedNumber release]</code>来匹配<code>alloc</code>，否则的话<code>allocedNumber</code>对象的引用计数就无法匹配了。</p><h3 id="所有权策略是使用引用计数来实现的"><a href="#所有权策略是使用引用计数来实现的" class="headerlink" title="所有权策略是使用引用计数来实现的"></a>所有权策略是使用引用计数来实现的</h3><ul><li>创建对象的时候，引用计数为1</li><li>向对象发送<code>retain</code>消息时，引用计数+1</li><li>向对象发送<code>release</code>消息时，引用计数-1。向对象发送<code>autorelease</code>消息时，对象的引用计数会在autorelease pool block的结尾处-1</li><li>引用计数减到0时，对象被销毁</li></ul><blockquote><p>不要使用<code>retainCount</code>来确定对象的引用计数，它是不准确的。应该使用引用计数规则结合代码来判断对象的引用计数。</p></blockquote><h2 id="使用Autorelease-Pool-Blocks"><a href="#使用Autorelease-Pool-Blocks" class="headerlink" title="使用Autorelease Pool Blocks"></a>使用Autorelease Pool Blocks</h2><p>自动释放池提供了一个可以用来<strong>废弃所有权而且又可以避免对象被立即销毁</strong>的机制。通常情况下，我们不需要创建自动释放吃，但是有些情况下必须使用或者如果使用了会提供一些益处。</p><h3 id="关于自动释放池"><a href="#关于自动释放池" class="headerlink" title="关于自动释放池"></a>关于自动释放池</h3><p>自动释放池是使用<code>@autoreleasepool</code>标记的<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">@autoreleasepool &#123;</span><br><span class="line">    // Code that creates autorelease objects.</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>在自动释放池的结尾，所有收到<code>autorelease</code>消息的对象会被发送<code>release</code>消息。</p><p>和其他的block类似，自动释放池也能够嵌套<br><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">@autoreleasepool</span> &#123;</span><br><span class="line">    <span class="comment">// . . .</span></span><br><span class="line">    <span class="keyword">@autoreleasepool</span> &#123;</span><br><span class="line">        <span class="comment">// . . .</span></span><br><span class="line">    &#125;</span><br><span class="line">    . . .</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>嵌套的自动释放池遵循就近原则。</p><p>Cocoa总是认为所有的代码会在自动释放池的范围内执行，否则的话自动释放的对象就无法被释放了，这样会导致内存泄露。如果有这种情况，Cocoa会打印出适当的错误信息。AppKit和UIKit框架中的事件循环迭代（例如鼠标点击或者用户触摸）都是在自动释放池内的。因此通常情况下，你不需要创建自动释放池。但是，下面的三种情况下，需要自己创建自动释放池：</p><ul><li>编写非UI framework程序时，例如命令行工具</li><li>在需要创建很多临时对象的循环中。在循环中使用自动释放池可以减少内存峰值</li><li>创建第二线程</li></ul><h3 id="使用自动释放池来降低内存峰值"><a href="#使用自动释放池来降低内存峰值" class="headerlink" title="使用自动释放池来降低内存峰值"></a>使用自动释放池来降低内存峰值</h3><p>有些代码需要创建一些自动释放的临时对象。这些对象直到自动释放池结尾处一直都在内存中。有时候这样做不会造成过多的内存提高；有时候这些对象过大就会造成过多的内存提升，而不得不尽快的释放这些临时对象。对于后一种情况，我们可以创建自己的自动释放池，在自动释放池的结尾这些占用内存的对象都会被销毁来节省内存。<br><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">NSArray</span> *urls = &lt;<span class="meta"># An array of file URLs #&gt;;</span></span><br><span class="line"><span class="keyword">for</span> (<span class="built_in">NSURL</span> *url <span class="keyword">in</span> urls) &#123;</span><br><span class="line"> </span><br><span class="line">    <span class="keyword">@autoreleasepool</span> &#123;</span><br><span class="line">        <span class="built_in">NSError</span> *error;</span><br><span class="line">        <span class="built_in">NSString</span> *fileContents = [<span class="built_in">NSString</span> stringWithContentsOfURL:url</span><br><span class="line">                                         encoding:<span class="built_in">NSUTF8StringEncoding</span> error:&amp;error];</span><br><span class="line">        <span class="comment">/* Process the string, creating and autoreleasing more objects. */</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p><code>for</code>循环每次都处理一个文件。在自动释放池中<code>fileContents</code>对象是“autoreleased”，当到达自动释放池的结尾会自动释放。每次都会自动回收内存，就避免了内存占用过多的问题。</p><p>切记，自动释放的对象只要超出最近的自动释放池范围后就会被释放。也就是说，自动释放的对象被释放后就无法继续使用了，不要向这些对象发送消息，也不要把它们作为返回值。例如下面的这种情况：<br><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">– (<span class="keyword">id</span>)findMatchingObject:(<span class="keyword">id</span>)anObject &#123;</span><br><span class="line"> </span><br><span class="line">    <span class="keyword">id</span> match;</span><br><span class="line">    <span class="keyword">while</span> (match == <span class="literal">nil</span>) &#123;</span><br><span class="line">        <span class="keyword">@autoreleasepool</span> &#123;</span><br><span class="line"> </span><br><span class="line">            <span class="comment">/* Do a search that creates a lot of temporary objects. */</span></span><br><span class="line">            match = [<span class="keyword">self</span> expensiveSearchForObject:anObject];</span><br><span class="line"> </span><br><span class="line">            <span class="keyword">if</span> (match != <span class="literal">nil</span>) &#123;</span><br><span class="line">                [match <span class="keyword">retain</span>]; <span class="comment">/* Keep match around. */</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    <span class="keyword">return</span> [match autorelease];   <span class="comment">/* Let match go and return it. */</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>向自动释放池内的<code>match</code>对象发送<code>retain</code>消息来延长它的生命期，这样我们就可以把自动释放池内的对象作为返回值了，同时使用<code>autorelease</code>标记返回值是为了匹配<code>retain</code>的引用计数。</p><h3 id="自动释放池和线程"><a href="#自动释放池和线程" class="headerlink" title="自动释放池和线程"></a>自动释放池和线程</h3><p>每一个Cocoa的应用程序都有自己的自动释放池栈。如果你正在编写只包含Foundation框架的程序，或者自己创建了一个线程，你需要自己创建自动释放池。</p><p>如果应用或线程是长久保存的并且潜在的生成了很多自动释放的对象，这时应该定期的清空并且创建自动释放池（就像 Application Kit 在主线程中做的那样）；否则，对象的积累会增加内存的占用。如果，独立的线程并没有使用 Cocoa 的调用，你没有必要去创建一个自动释放池。</p><blockquote><p>如果使用了 POSIX 线程 APIS 而不是 NSThread 对象来创建线程，你不能使用 Cocoa，包括 NSautoreleasePool，除非 Cocoa 是在多线程模式下，Cocoa 进入了多线程模式只有在首次创建 NSThread 对象的时候，为了在第二个 POSIX 线程中使用 Cocoa ，你的应用必须首先至少创建了一个独立的 NSThread 对象，这个对象可以立即退出。你可以通过 NSThread 类方法 isMultiTheraded 来测试 Cocoa 是否在多线程模式下。</p></blockquote>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;本文内容是对&lt;a href=&quot;https://developer.apple.com/library/archive/documentation/Cocoa/Conceptual/MemoryMgmt/Articles/MemoryMgmt.html#//apple_ref
      
    
    </summary>
    
      <category term="iOS" scheme="http://www.iosprogrammer.tech/categories/iOS/"/>
    
    
  </entry>
  
  <entry>
    <title>Objective-C 消息转发</title>
    <link href="http://www.iosprogrammer.tech/Objective-C-Message-Forward/"/>
    <id>http://www.iosprogrammer.tech/Objective-C-Message-Forward/</id>
    <published>2018-09-19T14:08:34.000Z</published>
    <updated>2020-12-08T09:43:38.965Z</updated>
    
    <content type="html"><![CDATA[<h4 id="一些概念"><a href="#一些概念" class="headerlink" title="一些概念"></a>一些概念</h4><p><strong>静态绑定</strong>：在编译期就能决定运行时所应调用的函数。代表语言：C、C++等<br><strong>动态绑定</strong>：所要调用的函数直到运行期才能确定。代表语言：OC、swift等<br><strong>消息传递</strong>：对象正常解读消息，传递过去<br><strong>消息转发</strong>：对象无法解读消息，之后进行消息转发</p><h4 id="消息处理流程"><a href="#消息处理流程" class="headerlink" title="消息处理流程"></a>消息处理流程</h4><ol><li>OC中调用方法<code>[a method]</code>后都是在执行<code>id objc_msgSend(id receiver, SEL op, ...)</code><blockquote><p><code>id objc_msgSend(id self, SEL op, ...)</code>是一个参数个数可变的函数，第一参数代表接受者，第二个参数代表选择子（OC函数名），之后的参数就是消息中传入的参数。</p></blockquote></li><li>当消息发送给对象时，消息函数跟随对象的isa指针找到类结构，并尝试在cache中搜索类中是否有对应的<code>SEL</code>，如果找到在cache中找到了则直接调用，这种情况下消息发送的耗时和函数调用相差无几</li><li>若cache中搜索失败，则到该类对应的<code>dispatch table</code>中搜寻方法，如果能找到这个跟选择子名称相同的方法，就跳转到其实现代码，往下执行。</li><li>该类的<code>dispatch table</code>中没有找到则继续沿着类层级向上寻找直到NSObject，找到后则进行方法调用并缓存。</li><li>如果最终还是找不到，那就进入消息转发的流程去进行处理。</li></ol><h4 id="消息转发流程"><a href="#消息转发流程" class="headerlink" title="消息转发流程"></a>消息转发流程</h4><p><img src="https://upload-images.jianshu.io/upload_images/424855-83a396fca4f6c206.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="msg_forward.png"></p><ol><li>调用resolveInstanceMethod：征询接受者（所属的类）是否可以添加方法以处理未知的选择子？(此过程称为动态方法解析）若有，转发结束。若没有，走第二步。</li><li>调用forwardingTargetForSelector：询问接受者是否有其他对象能处理此消息。若有，转发结束，一切如常。若没有，走第三步。</li><li>调用forwardInvocation：运行期系统将消息封装到NSInvocation对象中，再给接受者一次机会。</li><li>以上三步还不行，就抛出异常：unrecognized selector sent to instance xxxx</li></ol><h4 id="消息转发实例"><a href="#消息转发实例" class="headerlink" title="消息转发实例"></a>消息转发实例</h4><ol><li><p>在ViewController的头文件中声明一个方法，但是不要在ViewController.m中实现</p> <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">ViewController.h</span><br><span class="line"></span><br><span class="line">#import &lt;UIKit/UIKit.h&gt;</span><br><span class="line"></span><br><span class="line">@interface ViewController : UIViewController</span><br><span class="line"></span><br><span class="line">- (void)testForwardMethod;</span><br><span class="line"></span><br><span class="line">@end</span><br></pre></td></tr></table></figure></li><li><p>在AppDelegate中调用ViewController的<code>testForwardMethod</code>方法</p> <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">AppDelegate.m</span><br><span class="line"></span><br><span class="line">[[[ViewController alloc] init] testForwardMethod];</span><br></pre></td></tr></table></figure></li><li><p>这时候编译没有问题，但是运行会出现<code>-[ViewController testForwardMethod]: unrecognized selector sent to instance 0x10581bfe0</code></p></li><li><p>在ViewController.m中增加消息转发的方法</p> <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">ViewController.m</span><br><span class="line"></span><br><span class="line">- (id)forwardingTargetForSelector:(SEL)aSelector</span><br><span class="line">&#123;</span><br><span class="line">    NSLog(@&quot;ViewController forwardingTargetForSelector&quot;);</span><br><span class="line">    return [[TestView alloc] init];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// 如果有方法的实现，所有消息转发的过程都不会进行</span><br><span class="line">//- (void)testForwardMethod</span><br><span class="line">//&#123;</span><br><span class="line">//    NSLog(@&quot;ViewController testForwardMethod&quot;);</span><br><span class="line">//&#125;</span><br><span class="line"></span><br><span class="line">TestView.m</span><br><span class="line"></span><br><span class="line">- (void)testForwardMethod</span><br><span class="line">&#123;</span><br><span class="line">    NSLog(@&quot;TestView testForwardMethod&quot;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><ul><li>(id)forwardingTargetForSelector:(SEL)aSelector; 把aSelector转发给其他类对象。</li></ul></blockquote></li><li><p>在ViewController.m中增加两个消息转发的方法</p> <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">ViewController.m</span><br><span class="line">  </span><br><span class="line">- (NSMethodSignature *)methodSignatureForSelector:(SEL)aSelector</span><br><span class="line">&#123;</span><br><span class="line">    NSLog(@&quot;ViewController methodSignatureForSelector&quot;);</span><br><span class="line">    if (aSelector == @selector(testForwardMethod))</span><br><span class="line">    &#123;</span><br><span class="line">        NSLog(@&quot;ViewController methodSignatureForSelector equal&quot;);</span><br><span class="line">        return [NSMethodSignature signatureWithObjCTypes:&quot;v@:&quot;];</span><br><span class="line">    &#125;</span><br><span class="line">    return [super methodSignatureForSelector:aSelector];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">-  (void)forwardInvocation:(NSInvocation *)anInvocation</span><br><span class="line">&#123;</span><br><span class="line">    NSLog(@&quot;ViewController forwardInvocation:&quot;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><ol><li><code>- (NSMethodSignature *)methodSignatureForSelector:(SEL)aSelector</code>返回一NSMethodSignature对象，该对象包含给定选择器标识的方法的描述。在方法转发过程中如果需要使<code>NSInvocation</code>则就需要使用这个方法<br>2.<code>signatureWithObjCTypes:</code>是用C字符串来创建<code>NSMethodSignature</code>对象，详细的描述以看<a href="https://blog.csdn.net/bigtiger1648/article/details/51084957" target="_blank" rel="noopener">这篇文章</a></li></ol></blockquote></li></ol><h4 id="避开动态绑定"><a href="#避开动态绑定" class="headerlink" title="避开动态绑定"></a>避开动态绑定</h4><p>要想不使用OC的动态绑定，唯一的方案是获取到方法地址直接调用。 <strong>这种方案仅适用于 对一个方法重复多次调用，并且对性能敏感 的情况 </strong></p><ol><li>通过<code>NSObject</code>的<code>methodForSelector</code>获取到方法实现的地址</li><li><p>使用指针直接调用方法<br>下面是以<code>setFilled:</code>方法为例</p> <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">void (*setter)(id, SEL, BOOL);</span><br><span class="line">int i;</span><br><span class="line"></span><br><span class="line">setter = (void (*)(id, SEL, BOOL))[target</span><br><span class="line">    methodForSelector:@selector(setFilled:)];</span><br><span class="line">for ( i = 0 ; i &lt; 1000 ; i++ )</span><br><span class="line">    setter(targetList[i], @selector(setFilled:), YES);</span><br></pre></td></tr></table></figure><blockquote><p><code>methodForSelector</code>不是Objective-C的特性，而是由Cocoa runtime system提供</p></blockquote></li></ol>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h4 id=&quot;一些概念&quot;&gt;&lt;a href=&quot;#一些概念&quot; class=&quot;headerlink&quot; title=&quot;一些概念&quot;&gt;&lt;/a&gt;一些概念&lt;/h4&gt;&lt;p&gt;&lt;strong&gt;静态绑定&lt;/strong&gt;：在编译期就能决定运行时所应调用的函数。代表语言：C、C++等&lt;br&gt;&lt;stron
      
    
    </summary>
    
      <category term="iOS" scheme="http://www.iosprogrammer.tech/categories/iOS/"/>
    
    
  </entry>
  
  <entry>
    <title>跟我一起学习React Native之调用原生模块</title>
    <link href="http://www.iosprogrammer.tech/learn-react-native-with-me-call-native/"/>
    <id>http://www.iosprogrammer.tech/learn-react-native-with-me-call-native/</id>
    <published>2018-09-12T08:18:46.000Z</published>
    <updated>2020-07-09T05:24:30.477Z</updated>
    
    <content type="html"><![CDATA[<h4 id="写在前面"><a href="#写在前面" class="headerlink" title="写在前面"></a>写在前面</h4><p>这篇文章是“<a href="http://www.iosprogrammer.tech/categories/react-native/">跟我一起学react-native</a>”系列文章的第四篇。这系列文章会随着这个新闻项目的进行更新。想要跟我一起学习React Native的朋友可以关注我的微信公众号<strong>iOS进阶指南</strong>，或者<a href="https://tech.us18.list-manage.com/subscribe?u=340bfbe6219cff7b854f892c2&amp;id=ec1d8e7ba3" target="_blank" rel="noopener">订阅</a>我的<a href="http://www.iosprogrammer.tech">个人博客</a>。</p><h4 id="效果图"><a href="#效果图" class="headerlink" title="效果图"></a>效果图</h4><p><img src="https://upload-images.jianshu.io/upload_images/424855-d0105c3529fc4c43.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/180" alt="Share_WebView.png"></p><h4 id="加载WebView"><a href="#加载WebView" class="headerlink" title="加载WebView"></a>加载WebView</h4><p>通过<a href="https://facebook.github.io/react-native/docs/webview" target="_blank" rel="noopener">官方文档</a>可以查看WebView组件的详情。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&lt;WebView</span><br><span class="line">  source=&#123;&#123; uri: &apos;https://www.baidu.com/ &#125;&#125;</span><br><span class="line">  injectedJavaScript=&apos;window.postMessage(document.title)&apos;</span><br><span class="line">  onMessage=&#123;this.handleMessage&#125;</span><br><span class="line">/&gt;</span><br></pre></td></tr></table></figure></p><blockquote><p><code>source</code>: 要加载的资源；<br><code>injectedJavaScript</code>: 当资源加载完成后要执行的JS<strong>字符串</strong>；<br><code>window.postMessage()</code>会发出一个带有’data’参数的消息；<br><code>onMessage</code>来处理postMessage发出的消息，这里是把页面的title作为navigationBar的title。</p></blockquote><h4 id="调用iOS原生模块"><a href="#调用iOS原生模块" class="headerlink" title="调用iOS原生模块"></a>调用iOS原生模块</h4><p>建议先阅读<a href="https://facebook.github.io/react-native/docs/native-modules-ios" target="_blank" rel="noopener">官方文档</a>。这里以调用原生的友盟分享为例。（集成友盟分享和项目中info.plist中的相关设置不是这里的主要内容，有需要的可以百度一下。）</p><ol><li>项目中新建UShare类作为和RN的桥接类。<img src="https://upload-images.jianshu.io/upload_images/424855-a73f85b5f47019ac.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="UShare_Class.png"></li><li>UShare.m<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line">#import &quot;UShare.h&quot;</span><br><span class="line">#import &lt;UMSocialCore/UMSocialCore.h&gt;</span><br><span class="line">#import &lt;React/RCTBridgeModule.h&gt;</span><br><span class="line"></span><br><span class="line">@interface UShare () &lt;RCTBridgeModule&gt;</span><br><span class="line"></span><br><span class="line">@end</span><br><span class="line"></span><br><span class="line">@implementation UShare</span><br><span class="line">// 把UShare模块名暴露给JS</span><br><span class="line">RCT_EXPORT_MODULE();</span><br><span class="line"></span><br><span class="line">// platform: 0 QQ 1 QQ空间 2 微信 3 朋友圈 4 微博</span><br><span class="line">RCT_EXPORT_METHOD(shareToPlatform:(int)platform content:(NSString *)content)</span><br><span class="line">&#123;</span><br><span class="line">  UMSocialPlatformType type = UMSocialPlatformType_UnKnown;</span><br><span class="line">  switch (platform)</span><br><span class="line">  &#123;</span><br><span class="line">    case 0:</span><br><span class="line">      type = UMSocialPlatformType_QQ;</span><br><span class="line">      break;</span><br><span class="line">    case 1:</span><br><span class="line">      type = UMSocialPlatformType_Qzone;</span><br><span class="line">      break;</span><br><span class="line">    case 2:</span><br><span class="line">      type = UMSocialPlatformType_WechatSession;</span><br><span class="line">      break;</span><br><span class="line">    case 3:</span><br><span class="line">      type = UMSocialPlatformType_WechatTimeLine;</span><br><span class="line">      break;</span><br><span class="line">    case 4:</span><br><span class="line">      type = UMSocialPlatformType_Sina;</span><br><span class="line">      break;</span><br><span class="line">  &#125;</span><br><span class="line">// 分享一个纯文本内容作为示例</span><br><span class="line">  UMSocialMessageObject *msgObj = [UMSocialMessageObject messageObject];</span><br><span class="line">  msgObj.text = content;</span><br><span class="line">  [[UMSocialManager defaultManager] shareToPlatform:type messageObject:msgObj currentViewController:[[UIApplication sharedApplication] keyWindow].rootViewController completion:^(id result, NSError *error) &#123;</span><br><span class="line">    </span><br><span class="line">  &#125;];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">@end</span><br></pre></td></tr></table></figure></li></ol><blockquote><ol><li>桥接类必须遵守<code>RCTBridgeModule</code>协议</li><li>在类的.m文件中添加<code>RCT_EXPORT_MODULE()</code>，这个宏是用来指定暴露给JS的模块名，如果宏中没有参数则使用OC类名，如果OC类名以RCT开头，JS的模块名会去掉前缀。</li><li><code>RCT_EXPORT_METHOD</code>：把OC方法暴露给JS模块的宏。注意：OC方法暴露给JS后，JS的方法名是OC方法名中第一个冒号前面的部分，在这里就是<code>shareToPlatform</code>，而不是<code>shareToPlatform: content :</code>，并且暴露给JS的方法都被认为返回<code>void</code>，如果要返回内容需要使用回调。</li><li>JS中调用<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">import &#123; NativeModules &#125; from &apos;react-native&apos;</span><br><span class="line"></span><br><span class="line">var share = NativeModules.UShare</span><br><span class="line">share.shareToPlatform(platform, &quot;分享测试&quot;)</span><br></pre></td></tr></table></figure></li></ol></blockquote><p><strong>如果这篇文章能为你提供些许的帮助，我将不胜荣幸。如果你能慷慨的点个赞或者关注我，我将万分感激。</strong></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h4 id=&quot;写在前面&quot;&gt;&lt;a href=&quot;#写在前面&quot; class=&quot;headerlink&quot; title=&quot;写在前面&quot;&gt;&lt;/a&gt;写在前面&lt;/h4&gt;&lt;p&gt;这篇文章是“&lt;a href=&quot;http://www.iosprogrammer.tech/categories/react-
      
    
    </summary>
    
      <category term="react-native" scheme="http://www.iosprogrammer.tech/categories/react-native/"/>
    
    
  </entry>
  
  <entry>
    <title>跟我一起学习React Native之我的和设置</title>
    <link href="http://www.iosprogrammer.tech/learn-react-native-with-me-mine-and-settings/"/>
    <id>http://www.iosprogrammer.tech/learn-react-native-with-me-mine-and-settings/</id>
    <published>2018-06-20T07:16:21.000Z</published>
    <updated>2020-07-09T05:24:30.477Z</updated>
    
    <content type="html"><![CDATA[<h4 id="写在前面"><a href="#写在前面" class="headerlink" title="写在前面"></a>写在前面</h4><p>这篇文章是“<a href="http://www.iosprogrammer.tech/categories/react-native/">跟我一起学react-native</a>”系列文章的第三篇。这系列文章会随着这个新闻项目的进行更新。想要跟我一起学习React Native的朋友可以关注我的微信公众号<strong>iOS进阶指南</strong>，或者订阅我的<a href="http://www.iosprogrammer.tech">个人博客</a>。</p><h4 id="效果图"><a href="#效果图" class="headerlink" title="效果图"></a>效果图</h4><p><img src="https://upload-images.jianshu.io/upload_images/424855-f451b6cc1f588e6e.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="我的和设置 效果图"></p><h4 id="“我的”界面"><a href="#“我的”界面" class="headerlink" title="“我的”界面"></a>“我的”界面</h4><ol><li>使用sectionList实现类似iOS中group类型的tableView<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">render() &#123;</span><br><span class="line">  return (</span><br><span class="line">    &lt;SectionList style=&#123;&#123; backgroundColor: &apos;#eeeeee&apos; &#125;&#125;</span><br><span class="line">      renderItem=&#123;this._renderItem&#125;</span><br><span class="line">        renderSectionHeader=&#123;(&#123; section: &#123; title &#125; &#125;) =&gt; (</span><br><span class="line">          &lt;View style=&#123;styles.sectionHeader&#125; /&gt;</span><br><span class="line">        )&#125;</span><br><span class="line">        ItemSeparatorComponent=&#123;() =&gt;</span><br><span class="line">          &lt;View style=&#123;&#123; height: 0.5, backgroundColor: &apos;#999999&apos; &#125;&#125; /&gt;</span><br><span class="line">        &#125;</span><br><span class="line">        sections=&#123;[</span><br><span class="line">          &#123; data: [&#123; id: 0 &#125;] &#125;,</span><br><span class="line">          &#123; data: [&#123; id: 10, name: &apos;关注的新闻&apos;, photo: require(&apos;../../img/news.png&apos;) &#125;] &#125;,</span><br><span class="line">          &#123;</span><br><span class="line">            data: [&#123; id: 20, name: &apos;反馈和建议&apos;, photo: require(&apos;../../img/feedback.png&apos;) &#125;,</span><br><span class="line">            &#123; id: 21, name: &apos;设置&apos;, photo: require(&apos;../../img/setting.png&apos;) &#125;]</span><br><span class="line">          &#125;,</span><br><span class="line">        ]&#125;</span><br><span class="line">        keyExtractor=&#123;(item) =&gt; item.id&#125;</span><br><span class="line">    /&gt;</span><br><span class="line">  )</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ol><p>renderItem：渲染每一行；renderSectionHeader：渲染组头视图；  ItemSeparatorComponent：每一行之间的分割线，类似iOS中的separator；sections：数据源。id用来区分不同的行。</p><ol><li>渲染一行<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line">_renderItem(info) &#123;</span><br><span class="line">  if (info.item.id == 0) &#123;</span><br><span class="line">    return (</span><br><span class="line">      &lt;TouchableHighlight onPress=&#123;() =&gt; self.onPress(info.item)&#125;&gt;</span><br><span class="line">        &lt;View style=&#123;styles.personInfo&#125;&gt;</span><br><span class="line">          &lt;Image</span><br><span class="line">            style=&#123;styles.avatar&#125;</span><br><span class="line">              source=&#123;&#123; uri: &apos;http://image.iosprogrammer.hongbility.com/react-native/problem-1.png&apos; &#125;&#125;</span><br><span class="line">                resizeMode=&apos;cover&apos;</span><br><span class="line">          /&gt;</span><br><span class="line">          &lt;View style=&#123;styles.nickname&#125;&gt;</span><br><span class="line">            &lt;View style=&#123;&#123; flex: 1, justifyContent: &apos;center&apos; &#125;&#125;&gt;</span><br><span class="line">              &lt;Text&gt;登录/注册&lt;/Text&gt;</span><br><span class="line">            &lt;/View&gt;</span><br><span class="line">            &lt;View style=&#123;&#123; flex: 1, justifyContent: &apos;center&apos; &#125;&#125;&gt;</span><br><span class="line">              &lt;Text style=&#123;&#123; color: &apos;#999999&apos; &#125;&#125;&gt;查看个人主页&lt;/Text&gt;</span><br><span class="line">            &lt;/View&gt;</span><br><span class="line">          &lt;/View&gt;</span><br><span class="line">          &lt;Image</span><br><span class="line">            style=&#123;styles.rightArrow&#125;</span><br><span class="line">            source=&#123;require(&apos;../../img/right_arrow.png&apos;)&#125;</span><br><span class="line">          /&gt;</span><br><span class="line">        &lt;/View&gt;</span><br><span class="line">      &lt;/TouchableHighlight&gt;</span><br><span class="line">    )</span><br><span class="line">  &#125; else &#123;</span><br><span class="line">    return (</span><br><span class="line">      &lt;View style=&#123;styles.cell&#125;&gt;</span><br><span class="line">        &lt;SimpleCell</span><br><span class="line">          title=&#123;info.item.name&#125;</span><br><span class="line">          photo=&#123;info.item.photo&#125;</span><br><span class="line">          onPress=&#123;() =&gt; self.onPress(info.item)&#125;</span><br><span class="line">        /&gt;</span><br><span class="line">      &lt;/View&gt;</span><br><span class="line">    )</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ol><p>从效果图可以看出，第一组第一行的内容和其他行不相同，因此分开来处理。<br><br>TouchableHighlight：这个组件用来接收用户的点击事件。<strong><em>只能有一个子节点。否则会报错</em></strong><br><strong>注意：</strong>onPress={() =&gt; self.onPress(info.item)} 这里用的是<strong>self</strong>而不是this。self的来源是：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">constructor(props) &#123;</span><br><span class="line">  super(props)</span><br><span class="line">  self = this</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>不用this的原因是这里的this表示的不是当前的MeScreen对象，所以如果用this就无法调用到onPress事件。</p><h4 id="“SimpleCell”组件"><a href="#“SimpleCell”组件" class="headerlink" title="“SimpleCell”组件"></a>“SimpleCell”组件</h4>  <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">export default class SimpleCell extends React.Component &#123;</span><br><span class="line">  render() &#123;</span><br><span class="line">    let logo = this.props.photo ? &lt;Image style=&#123;styles.logo&#125; source=&#123;this.props.photo&#125;/&gt; : null</span><br><span class="line">    let detail = this.props.detail ? &lt;View style=&#123;styles.detail&#125;&gt; </span><br><span class="line">    &lt;Text style=&#123;&#123;color: &apos;#999999&apos;&#125;&#125;&gt;&#123;this.props.detail&#125;&lt;/Text&gt; &lt;/View&gt; : null</span><br><span class="line">    return (</span><br><span class="line">      &lt;TouchableHighlight underlayColor=&apos;#999&apos; onPress=&#123;this.props.onPress&#125;&gt;</span><br><span class="line">        &lt;View style=&#123;styles.container&#125;&gt;</span><br><span class="line">          &#123;logo&#125;</span><br><span class="line">          &lt;View style=&#123;styles.titleView&#125;&gt;</span><br><span class="line">            &lt;Text&gt;&#123;this.props.title&#125;&lt;/Text&gt;</span><br><span class="line">          &lt;/View&gt;</span><br><span class="line">          &#123;detail&#125;</span><br><span class="line">          &lt;Image style=&#123;styles.rightArrow&#125;</span><br><span class="line">            source=&#123;require(&apos;../../img/right_arrow.png&apos;)&#125;</span><br><span class="line">          /&gt;</span><br><span class="line">        &lt;/View&gt;</span><br><span class="line">      &lt;/TouchableHighlight&gt;</span><br><span class="line">    )</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>“我的”中的cell前面有icon，“设置”里面没有，因此这里根据条件判断是否显示。</p><p>如遇到问题可以参考<a href="http://www.iosprogrammer.tech/learn-react-native-with-me-questions">遇到的问题和解决方案</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h4 id=&quot;写在前面&quot;&gt;&lt;a href=&quot;#写在前面&quot; class=&quot;headerlink&quot; title=&quot;写在前面&quot;&gt;&lt;/a&gt;写在前面&lt;/h4&gt;&lt;p&gt;这篇文章是“&lt;a href=&quot;http://www.iosprogrammer.tech/categories/react-
      
    
    </summary>
    
      <category term="react-native" scheme="http://www.iosprogrammer.tech/categories/react-native/"/>
    
    
  </entry>
  
  <entry>
    <title>跟我一起学React Native之项目结构搭建</title>
    <link href="http://www.iosprogrammer.tech/learn-react-native-with-me-project-instruction/"/>
    <id>http://www.iosprogrammer.tech/learn-react-native-with-me-project-instruction/</id>
    <published>2018-06-12T12:59:58.000Z</published>
    <updated>2020-07-09T05:24:30.477Z</updated>
    
    <content type="html"><![CDATA[<h4 id="写在前面"><a href="#写在前面" class="headerlink" title="写在前面"></a>写在前面</h4><p>这篇文章是“<a href="http://www.iosprogrammer.tech/categories/react-native/">跟我一起学react-native</a>”系列文章的第二篇。这系列文章会随着这个新闻项目的进行更新。想要跟我一起学习React Native的朋友可以关注我的微信公众号<strong>iOS进阶指南</strong>，或者订阅我的<a href="http://www.iosprogrammer.tech">个人博客</a>。</p><p><a href="[http://www.iosprogrammer.tech/learn-react-native-with-me-construction/](http://www.iosprogrammer.tech/learn-react-native-with-me-construction/">上一篇文章</a>)讲了React Native的环境搭建过程，本篇文章将讨论“水滴新闻”项目结构的搭建。</p><h4 id="最终效果"><a href="#最终效果" class="headerlink" title="最终效果"></a>最终效果</h4><p><img src="https://upload-images.jianshu.io/upload_images/424855-c3242548a1c76b6b.gif?imageMogr2/auto-orient/strip" alt="效果"></p><h4 id="项目文件结构"><a href="#项目文件结构" class="headerlink" title="项目文件结构"></a>项目文件结构</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">rn_shuidi</span><br><span class="line">　| - - - - - - - App.js</span><br><span class="line">　| - - - - - - - app.json</span><br><span class="line">　| - - - - - - - index.js</span><br><span class="line">　| - - - - - - - node_modules</span><br><span class="line">　| - - - - - - - shuidi</span><br><span class="line">　　| - - - - - - - home</span><br><span class="line">　　　| - - - - - - - HomeScreen.js</span><br><span class="line">　　　| - - - - - - - NodeScreen.js</span><br><span class="line">　　| - - - - - - - attention</span><br><span class="line">　　| - - - - - - - me</span><br><span class="line">　| - - - - - - - android</span><br><span class="line">　| - - - - - - - ios</span><br><span class="line">　| - - - - - - - img</span><br><span class="line">　　| - - - - - - - home_normal.png</span><br><span class="line">　　| - - - - - - - home_selected.png</span><br><span class="line">　| - - - - - - - package.json</span><br></pre></td></tr></table></figure><h4 id="react-navigation"><a href="#react-navigation" class="headerlink" title="react-navigation"></a>react-navigation</h4><p>因为项目中包含多个页面，页面之间切换要使用TabBar和Navigation，因此要使用react-navigation这个框架。<br>安装react-navigation<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">cd rn_shuidi</span><br><span class="line">npm install react-navigation</span><br></pre></td></tr></table></figure></p><h4 id="Navigation"><a href="#Navigation" class="headerlink" title="Navigation"></a>Navigation</h4><p>下面以“主页为例”创建navigation<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">App.js</span><br><span class="line"></span><br><span class="line">import &#123; createStackNavigator, createBottomTabNavigator &#125; from &apos;react-navigation&apos;</span><br><span class="line">import HomeScreen from &apos;./shuidi/home/HomeScreen&apos;</span><br><span class="line">import NodeScreen from &apos;./shuidi/home/NodeScreen&apos;</span><br><span class="line"></span><br><span class="line">const HomeStack = createStackNavigator(&#123;</span><br><span class="line">    Home: &#123; screen: HomeScreen &#125;,</span><br><span class="line">    Nodes: &#123; screen: NodeScreen &#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure></p><p>StackNavigation可类比为iOS中的UINavigation，是一种栈类型的导航结构。<br><br><br>Home和Nodes分别是导航中的两个页面（控制器）。这里的名字会在执行导航行为的时候使用到。<br><br><br>screen参数是要放在导航中的页面。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">HomeScreen.js</span><br><span class="line">constructor(props) &#123;</span><br><span class="line">    super(props)</span><br><span class="line">    this.state = &#123; text: &apos;old&apos; &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">static navigationOptions = &#123;</span><br><span class="line">    title: &apos;主页&apos;,</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">&lt;Text&gt;&#123;this.state.text&#125;&lt;/Text&gt;</span><br><span class="line"></span><br><span class="line">&lt;Button</span><br><span class="line">    title=&quot;Go to NodeScreen&quot;</span><br><span class="line">    onPress=&#123;() =&gt; &#123;</span><br><span class="line">            this.props.navigation.navigate(&apos;Nodes&apos;, &#123;</span><br><span class="line">           title: &apos;测试节点&apos;, callback: ((data) =&gt; &#123;</span><br><span class="line">           this.setState(&#123; text: data &#125;)</span><br><span class="line">         &#125;)</span><br><span class="line">      &#125;)</span><br><span class="line">   &#125;&#125;</span><br><span class="line">/&gt;</span><br></pre></td></tr></table></figure></p><p>navigationOptions是对导航的配置，这里设置了title。相当于<code>self.title=&quot;主页&quot;</code></p><p>点击“Go to NodeScreen”这个<code>Button</code>后会跳转到标签为“Nodes”的页面，如果App.js的<code>HomeStack</code>中不包含“Nodes”标签则不会跳转。</p><p>title和callback分别是传递到“Nodes”页面的参数。其中callback是一个回调，用来进行反向传值。当“Nodes”页面以“data”为参数回调callback之后，<code>this.setState</code>保存接受到的参数，当前页面就会随之改变。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">NodeScreen.js</span><br><span class="line"></span><br><span class="line">static navigationOptions = (&#123; navigation &#125;) =&gt; &#123;</span><br><span class="line">    return &#123;</span><br><span class="line">        title: navigation.getParam(&apos;title&apos;, &apos;节点&apos;),</span><br><span class="line">    &#125;;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">const callback = navigation.getParam(&apos;callback&apos;)</span><br><span class="line"></span><br><span class="line">&lt;Button</span><br><span class="line">    title=&quot;反向传值测试&quot;</span><br><span class="line">    onPress=&#123;() =&gt; &#123;</span><br><span class="line">        this.props.navigation.goBack(),</span><br><span class="line">        callback(&apos;我是反向传值&apos;)</span><br><span class="line">    &#125;&#125;</span><br><span class="line">/&gt;</span><br></pre></td></tr></table></figure><p><code>navigation.getParam(&#39;title&#39;, &#39;节点&#39;)</code>获取<code>navigation</code>中的<code>title</code>参数。</p><p>点击“反向传值测试”，回到上一级页面，之后调用callback，把字符串“我是反向传值”传递到上一级页面。</p><p><strong>TabBar</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line">App.js</span><br><span class="line"></span><br><span class="line">createBottomTabNavigator(</span><br><span class="line">  &#123;</span><br><span class="line">    Home: HomeStack,</span><br><span class="line">    Attention: AttentionStack,</span><br><span class="line">    Me: MeStack</span><br><span class="line">  &#125;,</span><br><span class="line">  navigationOptions: (&#123; navigation &#125;) =&gt; (&#123;</span><br><span class="line">    tabBarLabel: (&#123;focused, tintColor&#125;) =&gt; &#123;</span><br><span class="line">      const &#123; routeName &#125; = navigation.state</span><br><span class="line">      var title = &apos;&apos;</span><br><span class="line">      if (routeName === &apos;Home&apos;) &#123;</span><br><span class="line">        title = &apos;主页&apos;</span><br><span class="line">      &#125; else if (routeName === &apos;Attention&apos;) &#123;</span><br><span class="line">        title = &apos;关注&apos;</span><br><span class="line">      &#125; else &#123;</span><br><span class="line">        title = &apos;我&apos;</span><br><span class="line">      &#125;</span><br><span class="line">      return &lt;Text&gt;&#123;title&#125;&lt;/Text&gt;</span><br><span class="line">    &#125;,</span><br><span class="line">    tabBarIcon: (&#123; focused, tintColor &#125;) =&gt; &#123;</span><br><span class="line">      const &#123; routeName &#125; = navigation.state;</span><br><span class="line">      var iconName = &apos;&apos;;</span><br><span class="line">      if (routeName === &apos;Home&apos;) &#123;</span><br><span class="line">        iconName = focused ? require(&apos;./img/home_selected.png&apos;) : requi(&apos;./img/home_normal.png&apos;)</span><br><span class="line">      &#125; else if (routeName === &apos;Attention&apos;) &#123;</span><br><span class="line">        iconName = focused ? require(&apos;./img/attention_selected.png&apos;) : requi(&apos;./img/attention_normal.png&apos;)</span><br><span class="line">      &#125; else &#123;</span><br><span class="line">        iconName = focused ? require(&apos;./img/me_selected.png&apos;) : requi(&apos;./img/me_normal.png&apos;)</span><br><span class="line">      &#125;</span><br><span class="line">      return &lt;Image </span><br><span class="line">        source=&#123;iconName&#125;</span><br><span class="line">        style=&#123;&#123; width: 26, height: 26 &#125;&#125;</span><br><span class="line">      &gt;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;),</span><br><span class="line">  tabBarOptions: &#123;</span><br><span class="line">    activeTintColor: &apos;blue&apos;,</span><br><span class="line">    inactiveTintColor: &apos;black&apos;,</span><br><span class="line">  &#125;</span><br><span class="line">)</span><br></pre></td></tr></table></figure><p><code>tabBarLabel</code>和<code>tabBarIcon</code>分别是当前标签页显示的标题和图片，其中图片根据<code>focused</code>展示不同内容。</p><h4 id="在navigationbar的子页面中隐藏tabbar"><a href="#在navigationbar的子页面中隐藏tabbar" class="headerlink" title="在navigationbar的子页面中隐藏tabbar"></a>在navigationbar的子页面中隐藏tabbar</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">HomeStack.navigationOptions = (&#123; navigation &#125;) =&gt; &#123;</span><br><span class="line">let tabBarVisible = true;</span><br><span class="line">if (navigation.state.index &gt; 0) &#123;</span><br><span class="line">tabBarVisible = false;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">return &#123;</span><br><span class="line">tabBarVisible,</span><br><span class="line">&#125;;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>至此，项目结构搭建完成了。这个过程中如遇到问题可以参考<a href="http://www.iosprogrammer.tech/learn-react-native-with-me-questions">遇到的问题和解决方案</a>🎉🎉🎉</p><p>因为MarkDown解析的问题，排版不好，请见谅。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h4 id=&quot;写在前面&quot;&gt;&lt;a href=&quot;#写在前面&quot; class=&quot;headerlink&quot; title=&quot;写在前面&quot;&gt;&lt;/a&gt;写在前面&lt;/h4&gt;&lt;p&gt;这篇文章是“&lt;a href=&quot;http://www.iosprogrammer.tech/categories/react-
      
    
    </summary>
    
      <category term="react-native" scheme="http://www.iosprogrammer.tech/categories/react-native/"/>
    
    
  </entry>
  
  <entry>
    <title>跟我一起学习React Native之遇到的问题和解决方法</title>
    <link href="http://www.iosprogrammer.tech/learn-react-native-with-me-questions/"/>
    <id>http://www.iosprogrammer.tech/learn-react-native-with-me-questions/</id>
    <published>2018-06-11T03:44:22.000Z</published>
    <updated>2020-07-09T05:24:30.477Z</updated>
    
    <content type="html"><![CDATA[<p>这篇文章是“<a href="http://www.iosprogrammer.tech/categories/react-native/">跟我一起学react-native</a>”系列文章的答疑篇。这系列文章会持续更新。想要跟我一起学习RN的朋友可以关注我的微信公众号iOS进阶指南，或者订阅<a href="http://www.iosprogrammer.tech">我的个人博客</a>。</p><ol><li>No bundle URL present.<br><br><br> <img src="http://image.iosprogrammer.hongbility.com/react-native/problem-1.png" alt="No bundle URL present"><br><br><blockquote><ul><li>Run “react-native run-ios”</li><li>When the error appears, run “npm install”</li><li>Then run “react-native run-ios” again.</li></ul></blockquote></li><li>isMounted(…) is deprecated in plain JavaScript React classes…</li><li><p>Class RCTCxxModule was not exported. Did you forget to use RCT_EXPORT_MODULE()?<br>这两个目前没找到好的解决办法，暂时隐藏警告吧，以后找到好的办法再更新。<br>这个问题在react-navigation的github主页里面有一个<a href="https://github.com/react-navigation/react-navigation/issues/3956" target="_blank" rel="noopener">专门的issue</a>，但是根据react-navigation的开发者说这个是react-native内部调用了废弃的方法所至。<br>目前大家的统一解决办法是在index.js文件中添加</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">import &#123; YellowBox &#125; from &apos;react-native&apos;;</span><br><span class="line">YellowBox.ignoreWarnings([&apos;Warning: isMounted(...) is deprecated&apos;, &apos;Module RCTImageLoader&apos;]);</span><br><span class="line">YellowBox.ignoreWarnings([&apos;Class RCTCxxModule&apos;]);</span><br></pre></td></tr></table></figure></li><li><p>Image加载不出来，onload不执行的问题。<br>iOS 8以上，默认不支持HTTP。需要在info.plist中设置App Transport Security Settings -&gt; Allow Arbitray Loads = YES</p></li><li>RCTBridge required dispatch_sync to load RCTDevLoadingView. This may lead to deadlocks.<br>APPDelegate.m<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line">...</span><br><span class="line">#if RCT_DEV</span><br><span class="line">#import &lt;React/RCTDevLoadingView.h&gt;</span><br><span class="line">#endif</span><br><span class="line"></span><br><span class="line">@implementation AppDelegate</span><br><span class="line"></span><br><span class="line">- (BOOL)application:(UIApplication *)application didFinishLaunchingWithOptions:(NSDictionary *)launchOptions</span><br><span class="line">&#123;</span><br><span class="line">  NSURL *jsCodeLocation;</span><br><span class="line"></span><br><span class="line">  jsCodeLocation = [[RCTBundleURLProvider sharedSettings] jsBundleURLForBundleRoot:@&quot;index&quot; fallbackResource:nil];</span><br><span class="line">  </span><br><span class="line">  RCTBridge *bridge = [[RCTBridge alloc] initWithBundleURL:jsCodeLocation</span><br><span class="line">                                            moduleProvider:nil</span><br><span class="line">                                             launchOptions:launchOptions];</span><br><span class="line">#if RCT_DEV</span><br><span class="line">  [bridge moduleForClass:[RCTDevLoadingView class]];</span><br><span class="line">#endif</span><br><span class="line"></span><br><span class="line">  RCTRootView *rootView = [[RCTRootView alloc] initWithBridge:bridge moduleName:@&quot;rn_shuidi&quot; initialProperties:launchOptions];</span><br><span class="line">  rootView.backgroundColor = [[UIColor alloc] initWithRed:1.0f green:1.0f blue:1.0f alpha:1];</span><br><span class="line"></span><br><span class="line">  self.window = [[UIWindow alloc] initWithFrame:[UIScreen mainScreen].bounds];</span><br><span class="line">  UIViewController *rootViewController = [UIViewController new];</span><br><span class="line">  rootViewController.view = rootView;</span><br><span class="line">  self.window.rootViewController = rootViewController;</span><br><span class="line">  [self.window makeKeyAndVisible];</span><br><span class="line">  return true;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ol>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;这篇文章是“&lt;a href=&quot;http://www.iosprogrammer.tech/categories/react-native/&quot;&gt;跟我一起学react-native&lt;/a&gt;”系列文章的答疑篇。这系列文章会持续更新。想要跟我一起学习RN的朋友可以关注我的微信公众号
      
    
    </summary>
    
      <category term="react-native" scheme="http://www.iosprogrammer.tech/categories/react-native/"/>
    
    
  </entry>
  
  <entry>
    <title>跟我一起学习React Native之环境搭建</title>
    <link href="http://www.iosprogrammer.tech/learn-react-native-with-me-construction/"/>
    <id>http://www.iosprogrammer.tech/learn-react-native-with-me-construction/</id>
    <published>2018-06-11T03:40:03.000Z</published>
    <updated>2020-07-09T05:24:30.477Z</updated>
    
    <content type="html"><![CDATA[<p>这篇文章是“<a href="http://www.iosprogrammer.tech/categories/react-native/">跟我一起学react-native</a>”系列文章的第一篇。这系列文章会持续更新。想要跟我一起学习React Native的朋友可以关注我的微信公众号<strong>iOS进阶指南</strong>，或者订阅<a href="http://www.iosprogrammer.tech">我的个人博客</a>。</p><h3 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h3><p>最近想要做一款新闻类的App，主要特点是把新闻事件按照时间线整理出来方便跟踪事情的发展。</p><p>作为一个雷（xia）厉（bi）风（dao）行（gu）的程序员肯定说干就干。</p><p>俗话说不想火的应用不是好App，想要更多的用户肯定不能只局限于一个平台，那就要让这个应用同时登陆安卓和iOS两个平台。但是我作为一个万年iOSer，现在从头开始学安卓恐怕有点不赶趟了。</p><p>根据当前敌我态势和恶劣的环境，跨平台开发成为了最优选择。</p><p>那怎么样达到跨平台开发的目的呢？根据百度爸爸的指导和以往的所见所闻，就要在阿里的weex和Facebook的react-native中二选一了。</p><p>从这篇文章的标题来看，大家肯定知道要选rn，其实最开始我选的是weex，奈何经过三四天的奋战和四处求教，我实在是没有搞定环境，在这里不得不说weex的官方文档真的可以称为简陋，当然我可能是因为我前几天手贱把Mac的系统升级到了Mojave。</p><p>在不得不放弃weex以后，只能🙏RN能给点面子。多亏上天眷顾，环境稍微折腾了一下就搞定了。</p><h3 id="环境搭建"><a href="#环境搭建" class="headerlink" title="环境搭建"></a>环境搭建</h3><ol><li><p>安装Node和Watchman</p> <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">brew install node</span><br><span class="line">brew install watchman</span><br></pre></td></tr></table></figure><p> 其中，node需要是8或者更新的版本。Watchman是Facebook用来监视文件系统更改的工具，RN强烈建议使用。</p></li><li><p>安装React Native command line interface.</p> <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm install -g react-native-cli</span><br></pre></td></tr></table></figure></li><li><p>创建项目</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">react-native init rn-test</span><br></pre></td></tr></table></figure></li><li><p>运行项目</p> <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">cd rn-test</span><br><span class="line">react-native run-ios</span><br></pre></td></tr></table></figure><p> 项目默认会在iPhone 6的模拟器上运行。<br><br> <img src="http://image.iosprogrammer.hongbility.com/react-native/new-project-screenshot.png" alt="iPhone 6 Screenshot"><br><br> 至此，环境搭建完成，这个过程中如遇到问题可以参考<a href="http://www.iosprogrammer.tech/learn-react-native-with-me-questions">遇到的问题和解决方案</a></p></li></ol>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;这篇文章是“&lt;a href=&quot;http://www.iosprogrammer.tech/categories/react-native/&quot;&gt;跟我一起学react-native&lt;/a&gt;”系列文章的第一篇。这系列文章会持续更新。想要跟我一起学习React Native的朋友可
      
    
    </summary>
    
      <category term="react-native" scheme="http://www.iosprogrammer.tech/categories/react-native/"/>
    
    
  </entry>
  
</feed>

<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>iOS开发栈 - 专注于分享iOS开发相关知识</title>
  
  <subtitle>关注公众号【iOS开发栈】及时免费获取更多iOS开发知识</subtitle>
  <link href="http://www.iosprogrammer.tech/atom.xml" rel="self"/>
  
  <link href="http://www.iosprogrammer.tech/"/>
  <updated>2021-05-10T05:38:54.142Z</updated>
  <id>http://www.iosprogrammer.tech/</id>
  
  <author>
    <name>施治昂</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>iOS项目入口的演变过程（2021）</title>
    <link href="http://www.iosprogrammer.tech/ios/application-entry-point-changes/"/>
    <id>http://www.iosprogrammer.tech/ios/application-entry-point-changes/</id>
    <published>2021-05-05T13:47:33.000Z</published>
    <updated>2021-05-10T05:38:54.142Z</updated>
    
    <content type="html"><![CDATA[<p><code>UISceneDelegate</code>是什么，它和<code>AppDelegate</code>有什么关系，Swift中的<code>@main</code>又是什么，本文将带你一一了解。</p><p>这篇文章将主要讲解下面几点内容：</p><ol><li>iOS13之前的<code>AppDelegate</code>启动项目的流程</li><li><code>UISceneDelegate</code>的多窗口实现逻辑</li><li><code>UISceneDelegate</code>和<code>AppDelegate</code>的关系</li><li><code>int main()</code>和<code>@main</code></li></ol><a id="more"></a><div class="note info"><p>到公众号【iOS开发栈】学习更多SwiftUI、iOS开发相关内容。</p></div><p><img src="../../images/scene-delegate/first.png"></p><h1 id="单Window的AppDelegate"><a href="#单Window的AppDelegate" class="headerlink" title="单Window的AppDelegate"></a>单Window的AppDelegate</h1><p>在iOS13之前iPhone上的项目都是单windows的，AppDelegate中的<code>- (BOOL)application:(UIApplication *)application didFinishLaunchingWithOptions:(NSDictionary *)launchOptions</code>就是iOS项目启动后第一个会被调用的函数。</p><h2 id="纯代码在AppDelegate中启动App"><a href="#纯代码在AppDelegate中启动App" class="headerlink" title="纯代码在AppDelegate中启动App"></a>纯代码在AppDelegate中启动App</h2><p>AppDelegate中有一个<code>window</code>属性，需要自己来给windows指定一个<code>rootViewController</code>，在不使用storyboard或者xib的情况下，最简单的AppDelegate代码大概是下面这样子：</p><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// AppDelegate.h</span></span><br><span class="line"><span class="class"><span class="keyword">@interface</span> <span class="title">AppDelegate</span> : <span class="title">UIResponder</span> &lt;<span class="title">UIApplicationDelegate</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">@property</span> (<span class="keyword">nonatomic</span>) <span class="built_in">UIWindow</span> *window;</span><br><span class="line"></span><br><span class="line"><span class="keyword">@end</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// AppDelegate.m</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#import <span class="meta-string">&quot;AppDelegate.h&quot;</span></span></span><br><span class="line"><span class="meta">#import <span class="meta-string">&quot;ViewController.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">@interface</span> <span class="title">AppDelegate</span> ()</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">@end</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">@implementation</span> <span class="title">AppDelegate</span></span></span><br><span class="line"></span><br><span class="line">- (<span class="built_in">BOOL</span>)application:(<span class="built_in">UIApplication</span> *)application didFinishLaunchingWithOptions:(<span class="built_in">NSDictionary</span> *)launchOptions &#123;</span><br><span class="line">    <span class="comment">// Override point for customization after application launch.</span></span><br><span class="line">    <span class="keyword">self</span>.window = [[<span class="built_in">UIWindow</span> alloc] initWithFrame:[<span class="built_in">UIScreen</span> mainScreen].bounds];</span><br><span class="line">    <span class="keyword">self</span>.window.rootViewController = [[ViewController alloc] init];</span><br><span class="line">    <span class="keyword">self</span>.window.backgroundColor = [<span class="built_in">UIColor</span> whiteColor];</span><br><span class="line">    [<span class="keyword">self</span>.window makeKeyAndVisible];</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">YES</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">@end</span></span><br></pre></td></tr></table></figure><p><code>AppDelegate</code>遵守了<code>UIApplicationDelegate</code>协议，其中window是协议里规定的一个属性，所以这里必须在.h中声明这个属性，否则会报错<mark class="label danger">-[AppDelegate setWindow:]: unrecognized selector sent to instance</mark>；而如果放在.m中会报重复声明的错误<mark class="label danger">Illegal redeclaration of property in class extension AppDelegate (attribute must be readwrite, while its primary must be readonly)</mark>。</p><p>在<code>didFinishLaunchingWithOptions</code>中初始化window并设置它的<code>rootViewController</code>之后调用<code>makeKeyAndVisible</code>。</p><h2 id="Storyboard在AppDelegate中启动App"><a href="#Storyboard在AppDelegate中启动App" class="headerlink" title="Storyboard在AppDelegate中启动App"></a>Storyboard在AppDelegate中启动App</h2><p>如果是使用storyboard作为项目入口的话，AppDelegate就更简单了：</p><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">- (<span class="built_in">BOOL</span>)application:(<span class="built_in">UIApplication</span> *)application didFinishLaunchingWithOptions:(<span class="built_in">NSDictionary</span> *)launchOptions &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">YES</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>如果项目是使用Xcode11创建的那么要想试验这种方法需要 1. 删除info.plist中的<code>Application Scene Manifest</code> 2. 删除<code>SceneDelegate.h</code>和<code>SceneDelegate.m</code> 3. 删除<code>AppDelegate.m</code>中的两个SceneDelegate相关函数<code>application(_:configurationForConnecting:options:)</code>和<code>application(_:didDiscardSceneSessions:)</code> 4. 此时Xcode不会自动从Main.storyboard加载视图，我们需要通过修改<code>didFinishLaunchingWithOptions</code>来展示界面。</p></blockquote><h1 id="SceneDelegate"><a href="#SceneDelegate" class="headerlink" title="SceneDelegate"></a>SceneDelegate</h1><p>从Xcode11开始，创建新的iOS项目的模版中会带有<code>SceneDelegate</code>类，并且在plist文件中会有一个<code>Application Scene Manifest</code>配置，<code>AppDelegate.m</code>中新增了两个管理SceneDelegate的函数<code>application(_:configurationForConnecting:options:)</code>和<code>application(_:didDiscardSceneSessions:)</code>。</p><h2 id="iOS应用的进程生命周期和UI生命周期"><a href="#iOS应用的进程生命周期和UI生命周期" class="headerlink" title="iOS应用的进程生命周期和UI生命周期"></a>iOS应用的进程生命周期和UI生命周期</h2><p>App的进程生命周期包括App启动、App终止等，主要涉及的协议有：</p><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* UIApplicationDelegate */</span></span><br><span class="line">- (<span class="keyword">void</span>)applicationDidFinishLaunching:(<span class="built_in">UIApplication</span> *)application;</span><br><span class="line">- (<span class="built_in">BOOL</span>)application:(<span class="built_in">UIApplication</span> *)application willFinishLaunchingWithOptions:(<span class="keyword">nullable</span> <span class="built_in">NSDictionary</span>&lt;<span class="built_in">UIApplicationLaunchOptionsKey</span>, <span class="keyword">id</span>&gt; *)launchOptions API_AVAILABLE(ios(<span class="number">6.0</span>));</span><br><span class="line">- (<span class="built_in">BOOL</span>)application:(<span class="built_in">UIApplication</span> *)application didFinishLaunchingWithOptions:(<span class="keyword">nullable</span> <span class="built_in">NSDictionary</span>&lt;<span class="built_in">UIApplicationLaunchOptionsKey</span>, <span class="keyword">id</span>&gt; *)launchOptions API_AVAILABLE(ios(<span class="number">3.0</span>));</span><br><span class="line">- (<span class="keyword">void</span>)applicationWillTerminate:(<span class="built_in">UIApplication</span> *)application;</span><br></pre></td></tr></table></figure><p>App退到后台或者重新进入前台的过程属于UI生命周期，其中主要涉及的协议有：</p><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* UIApplicationDelegate */</span></span><br><span class="line">- (<span class="keyword">void</span>)applicationDidBecomeActive:(<span class="built_in">UIApplication</span> *)application;</span><br><span class="line">- (<span class="keyword">void</span>)applicationWillResignActive:(<span class="built_in">UIApplication</span> *)application;</span><br></pre></td></tr></table></figure><h2 id="SceneDelegate是什么"><a href="#SceneDelegate是什么" class="headerlink" title="SceneDelegate是什么"></a>SceneDelegate是什么</h2><p><img src="../../images/scene-delegate/ios12-appdelegate.png" alt="iOS12之前AppDelegate的作用"></p><p>在iOS13之前，iOS项目只有一个主Window，那时候的进程生命周期和UI生命周期都在<code>APPDelegate</code>中进行管理。</p><p>在iOS13之后，为了增强iOS项目的可用性一个App可以有多个window来显示不同或相同的内容。双击设备的Home键后每一个window会独立展示。</p><p><img src="../../images/scene-delegate/sample-image.png" alt="sceneDelegate示例"></p><p><strong>多窗口特性只有在iPad上才可以用</strong>，iPhone上面是不行的。具体的使用方法和例子可以查看这篇<a href="https://developer.apple.com/documentation/uikit/uiscenedelegate/supporting_multiple_windows_on_ipad">苹果的官方文档</a>。</p><p>为了管理不同窗口的生命周期，苹果添加了<code>UIWindowSceneDelegate</code>协议，而<code>SceneDelegate</code>类实现了这个协议的方法，因此<strong>SceneDelegate类是用来管理iOS应用窗口的生命周期的</strong>，也就是应用界面的生命周期。</p><h2 id="SceneDelegate和AppDelegate的关系"><a href="#SceneDelegate和AppDelegate的关系" class="headerlink" title="SceneDelegate和AppDelegate的关系"></a>SceneDelegate和AppDelegate的关系</h2><p>在推出<code>SceneDelegate</code>之前，整个应用的生命周期和UI生命周期都是依赖AppDelegate进行管理，在这之后，UI生命周期交给了SceneDelegate来管理，而AppDelegate就用来管理应用的生命周期和SceneDelegate的生命周期。</p><p><img src="../../images/scene-delegate/appdelegate-scenedelegate.png" alt="AppDelegate和SceneDelegate的关系"></p><p>App的启动和杀死的回调仍然在AppDelegate中，除此之外在创建iOS项目的模版中，AppDelegate中增加了对SceneDelegate管理的两个方法：</p><ul><li><code>application:configurationForConnectingSceneSession:options:</code> 当窗口建立是会被调用</li><li><code>application:didDiscardSceneSessions:sceneSessions</code>。 当窗口被永久销毁是被调用</li></ul><p>SceneDelegate中对App的某个窗口的动作进行管理：</p><table><thead><tr><th></th><th></th></tr></thead><tbody><tr><td><code>scene:willConnectToSession:options:connectionOptions</code></td><td><code>sceneDidDisconnect:</code></td></tr><tr><td><code>sceneDidBecomeActive:</code></td><td><code>sceneWillResignActive:</code></td></tr><tr><td><code>sceneWillEnterForeground:</code></td><td><code>sceneDidEnterBackground:</code></td></tr></tbody></table><p>这里的方法都是对称出现的，基本也都是和之前在AppDelegate中的相关功能的方法很类似。</p><p><strong>SceneDelegate承接了部分AppDelegate的功能，而AppDelegate重点用来对应用生命周期就进行管理，SceneDelegate用来管理UI生命周期。</strong></p><h1 id="int-main-和-main"><a href="#int-main-和-main" class="headerlink" title="int main()和@main"></a><code>int main()</code>和<code>@main</code></h1><p>在Objc项目中存在一个<code>main.m</code>文件，里面的main函数是项目的启动函数。</p><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> main(<span class="keyword">int</span> argc, <span class="keyword">char</span> * argv[]) &#123;</span><br><span class="line">    <span class="built_in">NSString</span> * appDelegateClassName;</span><br><span class="line">    <span class="keyword">@autoreleasepool</span> &#123;</span><br><span class="line">        <span class="comment">// Setup code that might create autoreleased objects goos here.</span></span><br><span class="line">        appDelegateClassName = <span class="built_in">NSStringFromClass</span>([AppDelegate <span class="keyword">class</span>]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">UIApplicationMain</span>(argc, argv, <span class="literal">nil</span>, appDelegateClassName);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在Swift中，项目入口使用<code>@main</code>作为标记，作用和上面的C语言函数是一样的。</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* AppDelegate.swift */</span></span><br><span class="line"><span class="keyword">@main</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">AppDelegate</span></span></span><br></pre></td></tr></table></figure><p>通过添加<code>@main</code>标记，编译器会自动生成项目入口相关代码，并把<code>AppDelegate</code>的类名传递进去。</p><div class="note info"><p>到公众号【iOS开发栈】学习更多SwiftUI、iOS开发相关内容。</p></div><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>这篇文章我们对iOS项目的启动入口进行了一次回顾和深入了解，相信你对iOS项目的发展有了一个更加清晰的认识。</p><p>感谢你的阅读💗。</p>]]></content>
    
    
    <summary type="html">&lt;p&gt;&lt;code&gt;UISceneDelegate&lt;/code&gt;是什么，它和&lt;code&gt;AppDelegate&lt;/code&gt;有什么关系，Swift中的&lt;code&gt;@main&lt;/code&gt;又是什么，本文将带你一一了解。&lt;/p&gt;
&lt;p&gt;这篇文章将主要讲解下面几点内容：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;iOS13之前的&lt;code&gt;AppDelegate&lt;/code&gt;启动项目的流程&lt;/li&gt;
&lt;li&gt;&lt;code&gt;UISceneDelegate&lt;/code&gt;的多窗口实现逻辑&lt;/li&gt;
&lt;li&gt;&lt;code&gt;UISceneDelegate&lt;/code&gt;和&lt;code&gt;AppDelegate&lt;/code&gt;的关系&lt;/li&gt;
&lt;li&gt;&lt;code&gt;int main()&lt;/code&gt;和&lt;code&gt;@main&lt;/code&gt;&lt;/li&gt;
&lt;/ol&gt;</summary>
    
    
    
    
    <category term="iOS" scheme="http://www.iosprogrammer.tech/tags/iOS/"/>
    
  </entry>
  
  <entry>
    <title>推荐！iOS应用使用Assets.xcassets进行图片国际化的2种方法</title>
    <link href="http://www.iosprogrammer.tech/xcode/localize-images/"/>
    <id>http://www.iosprogrammer.tech/xcode/localize-images/</id>
    <published>2021-05-01T06:38:38.000Z</published>
    <updated>2021-05-01T09:52:27.955Z</updated>
    
    <content type="html"><![CDATA[<p>iOS应用的国际化除了文字以外还需要对一些本地使用的资源进行国际化，这篇文章将分享一些关于Image图片国际化的方案。</p><p>主要包括iOS应用图片国际化有两种方法：</p><ol><li>Assets.xcassets中同一个ImageSet包含不同的本地化图片</li><li>使用名称不同的ImageSet</li></ol><a id="more"></a><div class="note info"><p>到公众号【iOS开发栈】学习更多SwiftUI、iOS开发相关内容。</p></div><p><img src="../../images/image-localize/first.png"></p><h1 id="同一个ImageSet包含不同的本地化图片"><a href="#同一个ImageSet包含不同的本地化图片" class="headerlink" title="同一个ImageSet包含不同的本地化图片"></a>同一个ImageSet包含不同的本地化图片</h1><p><img src="../../images/image-localize/1.png" alt="iOS图片本地化设置"></p><p>按照正常流程把一张png图片添加到Assets.xcassets中以后，选中其中任意一张图片然后就可以在Inspector的第四栏Attribute Inspector中看到<strong>Localization</strong>选项，点击后会出现项目中已经国际化的语言。<em>（添加语言的方法可以查看<a href="https://www.iosprogrammer.tech/xcode/language-internalization-ib/#%E5%AE%8C%E6%95%B4%E4%BA%86%E8%A7%A3%E5%9B%BD%E9%99%85%E5%8C%96%E6%AD%A5%E9%AA%A4">完整了解国际化步骤</a>）</em></p><p>在<em>Localization</em>中选中的语言就是要单独设置图片的语言，如果单独设置的语言图片是空的就会自动选择用第一个（Universal）的图片。</p><p>我的这个项目里有简体中文和英文两种语言，并且对avatar这个图片的中文设置了单独图片。当我在设置中切换简体中文和英文时图片就会被切换了。</p><h1 id="使用名称不同的ImageSet"><a href="#使用名称不同的ImageSet" class="headerlink" title="使用名称不同的ImageSet"></a>使用名称不同的ImageSet</h1><p>在Assets.xcassets中分别创建两个ImageSet，然后在ImageNamed中使用NSLocalizedString来设置图片名字。</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">avatarImageView.image <span class="operator">=</span> <span class="type">UIImage</span>(named: <span class="type">NSLocalizedString</span>(<span class="string">&quot;avatarImageName&quot;</span>, comment: <span class="string">&quot;This is the avatar image&#x27;s name&quot;</span>))</span><br></pre></td></tr></table></figure><p><code>NSLocalizedString()</code>宏中的第一个参数是多语言的key，而comment是用来生成多语言注释的，更深入的了解可以查看<a href="https://www.iosprogrammer.tech/xcode/international-user-facing-text/#%E6%A0%87%E8%AE%B0%E9%9C%80%E8%A6%81%E6%9C%AC%E5%9C%B0%E5%8C%96%E7%9A%84%E6%96%87%E6%9C%AC">标记需要本地化的文本</a></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; Localization.strings(English)</span><br><span class="line">&quot;avatarImageName&quot; &#x3D; &quot;avatar-en&quot;;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; Localization.strings((Chinese, Simplified))</span><br><span class="line">&quot;avatarImageName&quot; &#x3D; &quot;avatar-ch&quot;;</span><br></pre></td></tr></table></figure><p>分别在中文简体和英文的Localization.strings的多语言文件中添加对应的图片文件名。</p><p>之后分别在不同的语言环境下运行项目就可以看到不同的图片了。</p><div class="note info"><p>到公众号【iOS开发栈】学习更多SwiftUI、iOS开发相关内容。</p></div><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>通过上面的2种方法可以将图片进行本地化处理，其中第二种方法也可以用于<code>UIImage(contentsOfFile:)</code>方法。</p>]]></content>
    
    
    <summary type="html">&lt;p&gt;iOS应用的国际化除了文字以外还需要对一些本地使用的资源进行国际化，这篇文章将分享一些关于Image图片国际化的方案。&lt;/p&gt;
&lt;p&gt;主要包括iOS应用图片国际化有两种方法：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;Assets.xcassets中同一个ImageSet包含不同的本地化图片&lt;/li&gt;
&lt;li&gt;使用名称不同的ImageSet&lt;/li&gt;
&lt;/ol&gt;</summary>
    
    
    
    
    <category term="Xcode" scheme="http://www.iosprogrammer.tech/tags/Xcode/"/>
    
    <category term="国际化" scheme="http://www.iosprogrammer.tech/tags/%E5%9B%BD%E9%99%85%E5%8C%96/"/>
    
  </entry>
  
  <entry>
    <title>你应该知道的！关于SwiftUI中导航栏的4点知识</title>
    <link href="http://www.iosprogrammer.tech/swiftui/swiftui-navigate-get-start-tutorial/"/>
    <id>http://www.iosprogrammer.tech/swiftui/swiftui-navigate-get-start-tutorial/</id>
    <published>2021-04-23T00:44:11.000Z</published>
    <updated>2021-04-23T07:54:35.832Z</updated>
    
    <content type="html"><![CDATA[<p>得益于SwiftUI的声明式编程方式进行页面切换是非常方便的，这篇文章将对SwiftUI中的导航功能进行一个全面的了解，主要会涉及到这几个方面：</p><ol><li>NavigatinView的使用方法以及对应API的讲解</li><li>NavigationLink的使用方法</li><li>实现POP会上一级页面的效果</li><li>Xcode12的实时预览导航栏</li></ol><a id="more"></a><div class="note info"><p>到公众号【iOS开发栈】学习更多SwiftUI、iOS开发相关内容。</p></div><p><img src="../../images/first/swiftui-navigate.png"></p><h1 id="NavigationView"><a href="#NavigationView" class="headerlink" title="NavigationView"></a>NavigationView</h1><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">NavigationView</span> &#123;</span><br><span class="line">    <span class="type">Text</span>(<span class="string">&quot;Hellow World&quot;</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如上所示，将一个View包裹在<code>NavigationView</code>中，当前这个body就是一个“导航控制器”了，关于这种写法的说明可以查看我之前的<a href="https://www.iosprogrammer.tech/swiftui/swiftui-concept-essential/">学习SwiftUI，必须掌握的3个知识点</a>中的View部分。</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">NavigationView</span> &#123;</span><br><span class="line">    <span class="type">Text</span>(<span class="string">&quot;Hellow World&quot;</span>)</span><br><span class="line">        .navigationTitle(<span class="string">&quot;公众号：iOS开发栈&quot;</span>) <span class="comment">// 或者使用 navigationBarTitle</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>通过给NavagationView内部的Content设置<em>navigationTitle</em>修改器可以设置导航栏的标题。</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">.navigationBarTitleDisplayMode(.inline)</span><br></pre></td></tr></table></figure><p>通过设置<code>navigationBarTitleDisplayMode</code>修改器可以更改导航栏标题的展现样式，<em>inline</em>是居中展示并且导航栏高度是固定的44pt；<em>large</em>是在iOS前几个版本新引入的样式，这种样式默认是把标题显示在左上角并且字体加粗加大，随着屏幕的滚动导航栏的高度也会变化；<code>automic</code>是会和导航栈的上一个页面保持相同。</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">.navigationBarTitle(<span class="string">&quot;公众号：iOS开发栈&quot;</span>, displayMode: .inline)</span><br></pre></td></tr></table></figure><p>通过设置<code>navigationBarTitle</code>修改器可以将上面两个修改器合并成一个。</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">.navigationBarHidden()</span><br></pre></td></tr></table></figure><p>通过使用<code>navigationBarHidden</code>可以动态控制是否展示导航栏，结合<code>@State</code>的使用可以实现动态显示或者隐藏导航栏的效果了。</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">.navigationBarItems(leading:, trailing:)</span><br></pre></td></tr></table></figure><p>使用<code>navigationBarItems</code>可以给导航栏的左、右添加按钮，而且因为leading和trailing的类型都是View的，所以你可以很方便的添加文字、图片、图文等。</p><h1 id="NavigationLink"><a href="#NavigationLink" class="headerlink" title="NavigationLink"></a>NavigationLink</h1><p>上面创建出了一个navigationView了，下面来看一下怎么实现跳转。</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">NavigationLink</span>(<span class="string">&quot;界面跳转&quot;</span>, destination: <span class="type">Text</span>(<span class="string">&quot;公众号：iOS开发栈&quot;</span>))</span><br><span class="line">                </span><br><span class="line"><span class="type">NavigationLink</span>(destination: <span class="type">Text</span>(<span class="string">&quot;公众号：iOS开发栈&quot;</span>), label: &#123;</span><br><span class="line">        <span class="type">Text</span>(<span class="string">&quot;界面跳转&quot;</span>)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><p>这两种创建方式的效果是一样的，最终都是通过点击“界面跳转”的文字以后跳转到一个只有“公众号：iOS开发栈”的新页面。</p><h1 id="实现POP回上一级页面的效果"><a href="#实现POP回上一级页面的效果" class="headerlink" title="实现POP回上一级页面的效果"></a>实现POP回上一级页面的效果</h1><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// ContentView.swift</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">ContentView</span>: <span class="title">View</span> </span>&#123;</span><br><span class="line">    <span class="meta">@State</span> <span class="keyword">var</span> pushActive <span class="operator">=</span> <span class="literal">false</span></span><br><span class="line">    <span class="keyword">var</span> body: <span class="keyword">some</span> <span class="type">View</span> &#123;</span><br><span class="line">        <span class="type">NavigationView</span> &#123;</span><br><span class="line">            <span class="type">VStack</span> &#123;</span><br><span class="line">                <span class="type">NavigationLink</span>(<span class="string">&quot;跳转并返回&quot;</span>, destination: <span class="type">SecondView</span>(pushActive: <span class="variable">$pushActive</span>), isActive: <span class="variable">$pushActive</span>)</span><br><span class="line">            &#125;</span><br><span class="line">            .navigationTitle(<span class="string">&quot;公众号：iOS开发栈&quot;</span>)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// SecondView.swift</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">SecondView</span>: <span class="title">View</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Binding</span> <span class="keyword">var</span> pushActive: <span class="type">Bool</span></span><br><span class="line">    <span class="keyword">var</span> body: <span class="keyword">some</span> <span class="type">View</span> &#123;</span><br><span class="line">        <span class="type">Button</span>(<span class="string">&quot;返回&quot;</span>) &#123;</span><br><span class="line">            pushActive <span class="operator">=</span> <span class="literal">false</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>使用一个@State属性绑定到<code>NavigationLink</code>的初始化方法中的<code>isActive</code>参数，这样就会根据<code>pushActive</code>的Bool值来push和pop视图，如果默认设置成true那启动app后就会直接切换到SecondView。</p><p>把pushActive参数传递到SecondView以后通过在SecondView中修改这个参数的值，就可以实现返回上一级的效果。其中关于@State和@Bind的用法可以看一下<a href="(https://www.iosprogrammer.tech/swiftui/swiftui-data-flow">详解SwiftUI数据流是怎么在View间传递的</a>。</p><h1 id="Xcode12的实时预览导航栏"><a href="#Xcode12的实时预览导航栏" class="headerlink" title="Xcode12的实时预览导航栏"></a>Xcode12的实时预览导航栏</h1><p>在Xcode12中，对于SwiftUI的文件，我们可以通过打开Cavas（option+cmd+enter）来查看实时预览的界面，这是一个非常好用的功能。虽然有很多的局限性，不够也终于让iOS开发者品尝到了Web或者Android待遇了。感谢苹果爸爸🙏</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">SecondView_Previews</span>: <span class="title">PreviewProvider</span> </span>&#123;</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">var</span> previews: <span class="keyword">some</span> <span class="type">View</span> &#123;</span><br><span class="line">        <span class="type">SecondView</span>(pushActive: .constant(false))</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>创建SwiftUI的文件后默认会带有一个遵守了<code>PreviewProvider</code>协议并且以<em>_Previews</em>结尾的结构体，有了它就有了对界面的实时预览能力。</p><p>要想预览导航栏的push和pop效果需要在这个结构体中进行修改。</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">SecondView_Previews</span>: <span class="title">PreviewProvider</span> </span>&#123;</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">var</span> previews: <span class="keyword">some</span> <span class="type">View</span> &#123;</span><br><span class="line">        <span class="type">NavigationView</span> &#123;</span><br><span class="line">            <span class="type">SecondView</span>(pushActive: .constant(false))</span><br><span class="line">                .navigationTitle(<span class="string">&quot;公众号：iOS开发栈&quot;</span>)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>通过在预览结构体中增加一个NavigationView就可以在导航栈的次级页面实时预览带有导航条的效果。</p><div class="note info"><p>到公众号【iOS开发栈】学习更多SwiftUI、iOS开发相关内容。</p></div><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>这篇文章涵盖了NavigationView和NavigationLink的基础用法和常用API的讲解，又提到了在实战应用中会遇到了一些进阶需求以及提升开发效率的预览功能用法。</p><p>🎉 你已经掌握了SwiftUI框架中关于导航栏的知识，现在可以动手试试做一个带有导航控制的应用了。</p>]]></content>
    
    
    <summary type="html">&lt;p&gt;得益于SwiftUI的声明式编程方式进行页面切换是非常方便的，这篇文章将对SwiftUI中的导航功能进行一个全面的了解，主要会涉及到这几个方面：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;NavigatinView的使用方法以及对应API的讲解&lt;/li&gt;
&lt;li&gt;NavigationLink的使用方法&lt;/li&gt;
&lt;li&gt;实现POP会上一级页面的效果&lt;/li&gt;
&lt;li&gt;Xcode12的实时预览导航栏&lt;/li&gt;
&lt;/ol&gt;</summary>
    
    
    
    
    <category term="SwiftUI" scheme="http://www.iosprogrammer.tech/tags/SwiftUI/"/>
    
  </entry>
  
  <entry>
    <title>SwiftUI中Image自适应大小AspectFill、AspectFit</title>
    <link href="http://www.iosprogrammer.tech/swiftui/swiftui-image-fill-fit-mode/"/>
    <id>http://www.iosprogrammer.tech/swiftui/swiftui-image-fill-fit-mode/</id>
    <published>2021-04-16T01:30:16.000Z</published>
    <updated>2021-04-16T03:40:50.576Z</updated>
    
    <content type="html"><![CDATA[<p>SwiftUI中想要让Image能够实现类似于UIViewContentModeAspectFit或者ApectFill的效果需要把两个<a href="https://www.iosprogrammer.tech/swiftui/swiftui-concept-essential/">修改器(modifier)</a>结合起来使用。</p><a id="more"></a><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">Image</span>(<span class="string">&quot;xxx&quot;</span>)</span><br><span class="line">    .resizable(resizingMode: .stretch)</span><br><span class="line">    .aspectRatio(contentMode: .fit)</span><br></pre></td></tr></table></figure><p><code>func resizable(capInsets:, resizingMode:)</code>对应的是UIImage的<code>resizableImageWithCapInsets:resizingMode:</code>。<code>capInsets</code>确定了不被拉伸影响的上下左右四边距，四边距以外的部分会被<code>resizingMode</code>影响。<code>Image.ResizingMode.stretch</code>铺满整个空间，会发生形变,<code>Image.ResizingMode.stretch</code>平铺，也就是说如果图片的大小不足以占满空间就把图片复制多份，如果图片比空间大只会展示出来和空间一样大的部分并且图片的左上角和容器的左上角对齐，其他部分会被裁掉。</p><p><code>aspectRatio(_ aspectRatio:,contentMode:)</code>修改器设置长宽比和填充方式，<code>aspectRatio</code>参数是视图的<em>长:宽</em>，<code>contentMode</code>是填充方式其中Fill表示填满空间，长边会超出容器，Fit会保证长边填满空间短边会留出空白。</p><p><strong>据我观察，单独对Image使用aspectRatio修改器没有效果，需要结合<code>resizable</code>修改器才行。</strong></p><div class="note info"><p>到公众号【iOS开发栈】学习更多SwiftUI、iOS开发相关内容。</p></div>]]></content>
    
    
    <summary type="html">&lt;p&gt;SwiftUI中想要让Image能够实现类似于UIViewContentModeAspectFit或者ApectFill的效果需要把两个&lt;a href=&quot;https://www.iosprogrammer.tech/swiftui/swiftui-concept-essential/&quot;&gt;修改器(modifier)&lt;/a&gt;结合起来使用。&lt;/p&gt;</summary>
    
    
    
    
    <category term="SwiftUI" scheme="http://www.iosprogrammer.tech/tags/SwiftUI/"/>
    
  </entry>
  
  <entry>
    <title>SwiftUI自定义Modifier</title>
    <link href="http://www.iosprogrammer.tech/swiftui/swiftui-custom-modifier/"/>
    <id>http://www.iosprogrammer.tech/swiftui/swiftui-custom-modifier/</id>
    <published>2021-04-14T00:47:13.000Z</published>
    <updated>2021-04-14T01:16:39.832Z</updated>
    
    <content type="html"><![CDATA[<p>SwiftUI中已经自带了很多<a href="https://www.iosprogrammer.tech/swiftui/swiftui-concept-essential/">Modifier</a>，使用这些自带的modifier可以满足我们的大多数需求。有些情况下为了方便使用或者统一风格，我们还想要给View增加自己的Modifier。</p><a id="more"></a><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">CustomModifier</span>: <span class="title">ViewModifier</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">func</span> <span class="title">body</span><span class="params">(content: Content)</span></span> -&gt; <span class="keyword">some</span> <span class="type">View</span> &#123;</span><br><span class="line">        content</span><br><span class="line">            .background(<span class="type">Color</span>.yellow)</span><br><span class="line">            .cornerRadius(<span class="number">10</span>)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>遵守<code>ViewModifier</code>即可创建自定义的modifier。</p><p>modifier并不是对原来view的修改，而是创建了一个新的view，具体可以参考我之前的<a href="https://www.iosprogrammer.tech/swiftui/swiftui-concept-essential/">这篇文章</a>。</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">Text</span>(<span class="string">&quot;iOS开发栈&quot;</span>)</span><br><span class="line">    .modifier(customModifier())</span><br></pre></td></tr></table></figure><p><code>modier(:)</code>方法是View的一个扩展方法，通过这个方法可以让一个view通过应用modier来返回一个新的view，这也证实了上面提到的。</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">extension</span> <span class="title">View</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">func</span> <span class="title">customModifier</span><span class="params">()</span></span> -&gt; <span class="keyword">some</span> <span class="type">View</span> &#123;</span><br><span class="line">        <span class="keyword">self</span>.modifier(<span class="type">CustomModifier</span>())</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>通过给View添加一个扩展方法就可以像使用系统方法那样调用我们自己添加的modifier了。</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">Text</span>(<span class="string">&quot;iOS开发栈&quot;</span>)</span><br><span class="line">    .customModifier()</span><br></pre></td></tr></table></figure><p>当然，我们也可以给自定义的Modifier添加参数，来实现更为复杂的效果。</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">CustomModifier</span>: <span class="title">ViewModifier</span> </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> cornerRadius: <span class="type">CGFloat</span></span><br><span class="line">    <span class="function"><span class="keyword">func</span> <span class="title">body</span><span class="params">(content: Content)</span></span> -&gt; <span class="keyword">some</span> <span class="type">View</span> &#123;</span><br><span class="line">        content</span><br><span class="line">            .background(<span class="type">Color</span>.yellow)</span><br><span class="line">            .cornerRadius(cornerRadius)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">extension</span> <span class="title">View</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">func</span> <span class="title">customModifier</span><span class="params">(cornerRadius: CGFloat)</span></span> -&gt; <span class="keyword">some</span> <span class="type">View</span> &#123;</span><br><span class="line">        <span class="keyword">self</span>.modifier(<span class="type">CustomModifier</span>(cornerRadius: cornerRadius))</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">ContentView</span>: <span class="title">View</span> </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> body: <span class="keyword">some</span> <span class="type">View</span> &#123;</span><br><span class="line">        <span class="type">VStack</span> &#123;</span><br><span class="line">            <span class="type">Text</span>(<span class="string">&quot;iOS开发栈&quot;</span>)</span><br><span class="line">                .customModifier(cornerRadius: <span class="number">10</span>)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><div class="note info"><p>到公众号【iOS开发栈】学习更多SwiftUI、iOS开发相关内容。</p></div>]]></content>
    
    
    <summary type="html">&lt;p&gt;SwiftUI中已经自带了很多&lt;a href=&quot;https://www.iosprogrammer.tech/swiftui/swiftui-concept-essential/&quot;&gt;Modifier&lt;/a&gt;，使用这些自带的modifier可以满足我们的大多数需求。有些情况下为了方便使用或者统一风格，我们还想要给View增加自己的Modifier。&lt;/p&gt;</summary>
    
    
    
    
    <category term="SwiftUI" scheme="http://www.iosprogrammer.tech/tags/SwiftUI/"/>
    
  </entry>
  
  <entry>
    <title>iOS本地化日期、时间、货币数字（超全）</title>
    <link href="http://www.iosprogrammer.tech/xcode/international-data-format/"/>
    <id>http://www.iosprogrammer.tech/xcode/international-data-format/</id>
    <published>2021-04-11T02:44:40.000Z</published>
    <updated>2021-05-01T06:46:21.625Z</updated>
    
    <content type="html"><![CDATA[<p>不同的国家、地区对一些诸如日期、时间、数字、货币等方面有不同的表述方式，为了更好的满足当地人的使用习惯和习俗，App必须做好这些方面的国际化工作。这是一项重要且复杂的工作，希望通过这篇可以让你对这些内容有一个全面的了解。</p><a id="more"></a><div class="note info"><p>到公众号【iOS开发栈】学习更多SwiftUI、iOS开发相关内容。</p></div><p><img src="../../images/international-data-format/cover.png" alt="iOS app 日期和数字的本地化"></p><p>之前两篇关于iOS国际化的文章讨论了关于<a href="https://www.iosprogrammer.tech/xcode/language-internalization-ib/">使用IB将固定UI国际化</a>和<a href="https://www.iosprogrammer.tech/xcode/international-user-facing-text/">使用NSLocalizeString宏将可变文本国际化</a>，这篇文章将集中于处理一些日常表述方面的国际化问题，比如日期、时间、数字、货币等。</p><p>首先要明确一点，这里的本地化并不是完全依赖于语言的，也就是说同样的语言在本地化方面也会有不同的表现形式。比如说意大利和美国都是英语国家但是在美国数字使用的“,”分割，而意大利使用的是“.”，又对于货币符号就更多了。</p><p>在iPhone和Mac上都有地区的选择，在对应页面的下方就是一些示例。</p><p><img src="../../images/international-data-format/mac-region-pannel.png" alt="Mac地区选择示例"></p><p>在开发过程中还有一个快速修改所在区域的小技巧，在Edit Scheme -&gt; Options中修改App Region然后重新运行项目就可以修改所在区域了，这样就不需要每次到系统设置中去修改区域。</p><h1 id="获取当前系统的本地化信息"><a href="#获取当前系统的本地化信息" class="headerlink" title="获取当前系统的本地化信息"></a>获取当前系统的本地化信息</h1><ol><li>获取Locale对象</li></ol><p>可以通过两种方法获取到用户的本地化对象<code>Locale.current</code>和<code>Locale.autoupdatingCurrent</code>，官方文档说autoupdatingCurrent会随着系统设置的更改而改变，current是固定的。</p><p>但是我并没有发现这两者的区别，当用户修改系统语言或者所在地区以后所有app都会重启，不管使用那种方式都会重新获取最新的系统设置，而如果只是修改日历的话app不会重启但是<code>autoupdatingCurrent</code>方法获取到的locale也不会改变。</p><p>我不知道这是由于官方文档没有及时更新还是由于我没有找到这两个方法之间的区别，如果你知道他们的区别麻烦告诉我。</p><ol start="2"><li>获取Locale对象包含的本地化信息</li></ol><p>本地化信息会随着语言、地域、文化的不同而不同，总共包含了大概十几个条目，下面列举几个比较常用的条目并且以大陆地区为例来给出结果。</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 以中国大陆地区为例</span></span><br><span class="line"><span class="keyword">let</span> currentLocale <span class="operator">=</span> <span class="type">Locale</span>.autoupdatingCurrent</span><br><span class="line">currentLocale.identifier <span class="comment">// zh_CN</span></span><br><span class="line">currentLocale.languageCode <span class="operator">??</span> <span class="string">&quot;&quot;</span> <span class="comment">// zh</span></span><br><span class="line">currentLocale.regionCode <span class="operator">??</span> <span class="string">&quot;&quot;</span> <span class="comment">// CN</span></span><br><span class="line">currentLocale.scriptCode <span class="operator">??</span> <span class="string">&quot;&quot;</span> <span class="comment">// &quot;&quot;</span></span><br><span class="line">currentLocale.variantCode <span class="operator">??</span> <span class="string">&quot;&quot;</span> <span class="comment">// &quot;&quot;</span></span><br><span class="line">currentLocale.calendar <span class="comment">// gregorian (current)</span></span><br><span class="line">currentLocale.usesMetricSystem <span class="comment">// true</span></span><br><span class="line">currentLocale.currencySymbol <span class="operator">??</span> <span class="string">&quot;&quot;</span> <span class="comment">// ¥</span></span><br><span class="line">currentLocale.currencyCode <span class="operator">??</span> <span class="string">&quot;&quot;</span> <span class="comment">// CNY</span></span><br><span class="line">currentLocale.quotationBeginDelimiter <span class="operator">??</span> <span class="string">&quot;&quot;</span> <span class="comment">// “ 前引号</span></span><br><span class="line">currentLocale.quotationEndDelimiter <span class="operator">??</span> <span class="string">&quot;&quot;</span> <span class="comment">// ” 后引号</span></span><br></pre></td></tr></table></figure><ol start="3"><li>获取当前语言和方言</li></ol><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> languageId <span class="operator">=</span> <span class="type">Bundle</span>.main.preferredLocalizations.first<span class="operator">!</span> <span class="comment">// zh-Hans</span></span><br><span class="line"><span class="keyword">let</span> locale <span class="operator">=</span> <span class="type">Locale</span>.current</span><br><span class="line"><span class="keyword">let</span> languageName <span class="operator">=</span> locale.localizedString(forLanguageCode: languageId)<span class="operator">!</span> <span class="comment">// 中文</span></span><br></pre></td></tr></table></figure><p>这里的languageId是开发者需要的而不应该让用户看到，languageName是展示给用户的。</p><h1 id="格式化日期时间"><a href="#格式化日期时间" class="headerlink" title="格式化日期时间"></a>格式化日期时间</h1><ol><li>使用预设的格式</li></ol><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> date <span class="operator">=</span> <span class="type">DateFormatter</span>.localizedString(from: <span class="type">Date</span>(), dateStyle: .short, timeStyle: .short) <span class="comment">// 2021/4/11 下午9:15:16</span></span><br></pre></td></tr></table></figure><p>根据当前所在的Locale，将当前时间格式化，其中日期使用“短格式”、时间使用“中格式。下面是官方文档上面的一个对不同格式的示例：</p><table><thead><tr><th>Style</th><th>Date</th><th>Time</th><th>Description</th></tr></thead><tbody><tr><td>Short</td><td>6/10/13</td><td>11:03 AM</td><td>只有数字</td></tr><tr><td>Medium</td><td>Jun 10, 2013</td><td>11:03:15 AM</td><td>简短文本</td></tr><tr><td>Long</td><td>June 10, 2013</td><td>11:03:15 AM PDT</td><td>完整文本</td></tr><tr><td>Full</td><td>Friday, June 10, 2013</td><td>11:03:15 AM Pacific Daylight Time</td><td>更多细节</td></tr></tbody></table><p>下面是在不同的语言和地区中中长和短文本的时间格式：</p><table><thead><tr><th>Language (Region)</th><th>Medium style</th><th>Short style</th></tr></thead><tbody><tr><td>English (United States)</td><td>Jun 6, 2013</td><td>10:14 AM</td></tr><tr><td>French (France)</td><td>6 Jun 2013</td><td>10:14</td></tr><tr><td>Chinese (China)</td><td>2013年6月6日</td><td>上午10:14</td></tr></tbody></table><ol start="2"><li>使用自定义的日期和时间格式</li></ol><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> dateFormatter <span class="operator">=</span> <span class="type">DateFormatter</span>()</span><br><span class="line"><span class="keyword">let</span> formatterString <span class="operator">=</span> <span class="type">DateFormatter</span>.dateFormat(fromTemplate: <span class="string">&quot;MMM d&quot;</span>, options: <span class="number">0</span>, locale: dateFormatter.locale)<span class="operator">!</span>  <span class="comment">// 4月11日</span></span><br><span class="line"><span class="comment">//        let formaterString = &quot;MMM d&quot; // 4月 11</span></span><br><span class="line">dateFormatter.dateFormat <span class="operator">=</span> formatterString </span><br><span class="line"><span class="keyword">let</span> date2 <span class="operator">=</span> dateFormatter.string(from: <span class="type">Date</span>()) </span><br></pre></td></tr></table></figure><p>分两种方式创建formatterString，当使用<code>fromTemplate:options:locale</code>时得到的dateString是4月11日；直接使用普通文本时得到的dateString是4月11。</p><p>下面是几个不同语言和地区分别在使用和不使用地区格式化下的日期：</p><table><thead><tr><th>Language (Region)</th><th>Date using format string “MMM d”</th><th>Date using templat “dMMM”</th></tr></thead><tbody><tr><td>English (United States)</td><td>Nov 13</td><td>Nov 13</td></tr><tr><td>French (France)</td><td>nov. 13</td><td>13 nov.</td></tr><tr><td>Chinese (China)</td><td>11月13</td><td>11月13日｜</td></tr></tbody></table><h1 id="数字格式化"><a href="#数字格式化" class="headerlink" title="数字格式化"></a>数字格式化</h1><ol><li>使用预设样式格式化数字</li></ol><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> myNumber: <span class="type">NSNumber</span> <span class="operator">=</span> <span class="number">234231.231</span></span><br><span class="line"><span class="keyword">let</span> numberString <span class="operator">=</span> <span class="type">NumberFormatter</span>.localizedString(from: myNumber, number: .decimal)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;numberString = <span class="subst">\(numberString)</span>&quot;</span>) <span class="comment">// numberString = 234,231.231</span></span><br></pre></td></tr></table></figure><p>使用预设格式进行格式化数字时，在不同的语言和地区下的例子：</p><table><thead><tr><th>Style</th><th>Formatted string, <br> English (United States)</th><th>Formatted string,<br> Language (Region)</th></tr></thead><tbody><tr><td>Decimal（小数）</td><td>1,234.56</td><td>1.234,56 <br>Italian (Italy)</td></tr><tr><td>Currency（货币）</td><td>$1,234.56</td><td>¥1,234.56<br>Chinese (China)</td></tr><tr><td>Percent（百分数）</td><td>123,456%</td><td><img src="../../images/international-data-format/arabic_percent.svg" width="72.548" height="13.019"><br>Arabic (Egypt)</td></tr><tr><td>Scientific（科学计数法）</td><td>1.23456E+03</td><td>1,23456E3<br>Italian (Italy)</td></tr><tr><td>Spell Out（读）</td><td>one thousand two hundred thirty-four point five six</td><td>一千二百三十四点五六<br>Chinese (China)</td></tr></tbody></table><ol start="2"><li>获取用户输入的数字</li></ol><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> formatter <span class="operator">=</span> <span class="type">NumberFormatter</span>()</span><br><span class="line">formatter.numberStyle <span class="operator">=</span> .decimal</span><br><span class="line">formatter.isLenient <span class="operator">=</span> <span class="literal">true</span></span><br><span class="line"><span class="keyword">let</span> number <span class="operator">=</span> formatter.number(from: <span class="string">&quot;1,234,123.23&quot;</span>)<span class="operator">!</span></span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;number = <span class="subst">\(number)</span>&quot;</span>) <span class="comment">// number = 1234123.23</span></span><br></pre></td></tr></table></figure><p>使用系统当前的语言和地区把用户输入的带有当地特色的数字字符串转化成<code>Number</code>格式。其中<code>isLenient</code>表示是否允许格式不完全按照标准格式，例如如果这里使用<code>formatter.isLenient = false</code>，当输入字符串只要不是标准的<em>1,234,123.23</em>而是<em>1,23,4123.23</em>或者1,234123.23就会返回nil。</p><h1 id="关于日历的本地化"><a href="#关于日历的本地化" class="headerlink" title="关于日历的本地化"></a>关于日历的本地化</h1><p>不同地区之间的纪年方法有很大的差别，日本的年代变化很快（他们还在用天皇纪年，就像咱们中国的封建社会）而公历或者农历的年代变化就相对较慢，而有的地区一年有13个月，不同的日历对每周的第一天定义也不同（周六、周日、周一都有）。要处理这么复杂多变的日历相关问题就一定要用到<code>Calender</code>类。</p><p>获取用户当前使用的日历使用<code>Calendar.current</code>。</p><p>获取一个日期的组成部分：</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> calendar <span class="operator">=</span> <span class="type">Calendar</span>.current</span><br><span class="line"><span class="keyword">let</span> components <span class="operator">=</span> calendar.dateComponents([.era, .year, .month, .weekday, .day, .hour, .minute, .second], from: <span class="type">Date</span>())</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;当前时间组件：<span class="subst">\(String(describing: components.era<span class="operator">!</span>))</span>, <span class="subst">\(String(describing: components.year<span class="operator">!</span>))</span>, <span class="subst">\(String(describing: components.month<span class="operator">!</span>))</span>, <span class="subst">\(String(describing: components.weekday<span class="operator">!</span>))</span>, <span class="subst">\(String(describing: components.day<span class="operator">!</span>))</span>, <span class="subst">\(String(describing: components.hour<span class="operator">!</span>))</span>, <span class="subst">\(String(describing: components.minute<span class="operator">!</span>))</span>, <span class="subst">\(String(describing: components.second<span class="operator">!</span>))</span>&quot;</span>) <span class="comment">// 当前时间组件：1, 2021, 4, 1, 11, 22, 32, 4</span></span><br></pre></td></tr></table></figure><blockquote><p>当使用日本历或者佛教日历的时候，每次获取或者设置年份一定要同时获取或者设置年代。</p></blockquote><p>更多关于日历的内容可以参考一下<a href="https://developer.apple.com/library/archive/documentation/Cocoa/Conceptual/DatesAndTimes/DatesAndTimes.html#//apple_ref/doc/uid/10000039i">官方文档</a></p><h1 id="Locale和时区相关的通知"><a href="#Locale和时区相关的通知" class="headerlink" title="Locale和时区相关的通知"></a>Locale和时区相关的通知</h1><p>要及时的获取Locale或者时区变化的通知可以监听<code>NSCurrentLocaleDidChangeNotification</code>和<code>NSSystemTimeZoneDidChangeNotification</code>通知。</p><p>获取通知在用户进行跨国长途旅行的时候非常有用，当用户时区改变后app能够及时变化可以给用户一个非常棒的体验。</p><div class="note info"><p>到公众号【iOS开发栈】学习更多SwiftUI、iOS开发相关内容。</p></div><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>想要很完善的本地化一个App是不容易的，不仅要把文字本地化还要把日期、时间、日历、数字等内容本地化，这些内容在一个app中是无处不在的，这就要求我们要随时记着自己是在做一个国际化的App。为了能给全世界各地的用户一个更好的使用体验，尽力做好这项工作吧。</p>]]></content>
    
    
    <summary type="html">&lt;p&gt;不同的国家、地区对一些诸如日期、时间、数字、货币等方面有不同的表述方式，为了更好的满足当地人的使用习惯和习俗，App必须做好这些方面的国际化工作。这是一项重要且复杂的工作，希望通过这篇可以让你对这些内容有一个全面的了解。&lt;/p&gt;</summary>
    
    
    
    
    <category term="Xcode" scheme="http://www.iosprogrammer.tech/tags/Xcode/"/>
    
    <category term="国际化" scheme="http://www.iosprogrammer.tech/tags/%E5%9B%BD%E9%99%85%E5%8C%96/"/>
    
  </entry>
  
  <entry>
    <title>苹果官方的iOS App国际化工作流</title>
    <link href="http://www.iosprogrammer.tech/xcode/international-user-facing-text/"/>
    <id>http://www.iosprogrammer.tech/xcode/international-user-facing-text/</id>
    <published>2021-04-05T09:08:21.000Z</published>
    <updated>2021-05-01T06:46:28.083Z</updated>
    
    <content type="html"><![CDATA[<p>国际化是出海应用非常重要的一个基础步骤，其中多语言的适配是重中之重。Xcode自带了帮助开发者进行App本地化的功能，其中包括多语言文件的导入和导出，使用这些功能可以很丝滑的完成多语言的工作。</p><a id="more"></a><p><img src="../../images/first/international-user-facing-text.png" alt="iOS国际化"></p><div class="note info"><p>到公众号【iOS开发栈】学习更多SwiftUI、iOS开发相关内容。</p></div><p>App中有一些固定内容的控件是可以直接利用IB文件来做多语言的，具体方法可以查看一下之前的<a href="https://www.iosprogrammer.tech/xcode/language-internalization-ib/">这篇文章</a>，文章中也讲了怎么添加多语言的操作。</p><p>除了一些固定内容的控件之外还会有一些其他内容需要开发者通过代码的形式来本地化，比如可变内容的控件、错误提示信息、富文本、App名称等。通过下面几个步骤可以给这些内容添加多语言。</p><h1 id="标记需要本地化的文本"><a href="#标记需要本地化的文本" class="headerlink" title="标记需要本地化的文本"></a>标记需要本地化的文本</h1><p>Foundation框架中使用<code>NSLocalizedString(_:tableName:bundle:value:comment:)</code>来标记需要本地化的文本，通常tableName/bundle和value直接使用默认值就可以了。</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">NSLocalizedString</span>(<span class="string">&quot;Label1&quot;</span>, comment: <span class="string">&quot;This is the first label&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 上面的代码最终的样子</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* This is the first label */</span></span><br><span class="line"><span class="string">&quot;Label1&quot;</span> <span class="operator">=</span> <span class="string">&quot;First Label 111&quot;</span>;</span><br></pre></td></tr></table></figure><p>翻译文件是key-value的格式，其中key是<code>NSLocalizedString</code>函数中的第一个参数，在这里就是<em>Label1</em>。默认的value也是<em>Label1</em>。</p><p><code>comment</code>参数是这对key-value的注释，主要是在进行人工翻译的时候提供一个说明作用，尤其是当有多个相似的文本时这个注释就有作用了。</p><h1 id="使用Xcode导出本地化多语言文件"><a href="#使用Xcode导出本地化多语言文件" class="headerlink" title="使用Xcode导出本地化多语言文件"></a>使用Xcode导出本地化多语言文件</h1><p>当还没有进行翻译的时候，使用<code>NSLocalizedString</code>的地方就会显示<em>key</em>文本，Xcode会在导出多语言文件的时候在项目中搜寻这个函数。</p><p>导出多语言文件的步骤如下：</p><ol><li>使用Xcode打开项目</li><li>在左侧的目录导航栏中点击项目名打开.xcodeproj</li><li>在PROJECT中选择项目名，并在Info选项卡的Locations中添加上其他语言</li><li>点击Xcode菜单栏中Editor选项的Export for Localization</li><li>选择导出的文件夹并命名后点击导出</li></ol><h1 id="修改本地化多语言文件"><a href="#修改本地化多语言文件" class="headerlink" title="修改本地化多语言文件"></a>修改本地化多语言文件</h1><p>导出的文件中包含多个.xcloc子文件夹，每一个xloc文件夹中的Localized Contents下的.xliff文件就是要填写翻译内容的文件。</p><p>打开xliff文件并在其中搜索“<source>”，搜索到的文本就是需要翻译的内容。每个<source>对应一个<target>，把译文放到<target>和</target>中间。就像这样：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&lt;source&gt;First Label 111&lt;&#x2F;source&gt;</span><br><span class="line">&lt;target&gt;第一个文本&lt;&#x2F;target&gt;</span><br></pre></td></tr></table></figure><p>source是Development Language的语言文本，target是译文。上面这个例子的Development Language是英文，target是中文。</p><p>source不是<code>NSLocalizedString</code>第一个参数指定的key，而是Development Language下key对应的value，所以如果开发语言的译文变了，这里的source也会变。</p><h1 id="使用Xcode导入本地化多语言文件"><a href="#使用Xcode导入本地化多语言文件" class="headerlink" title="使用Xcode导入本地化多语言文件"></a>使用Xcode导入本地化多语言文件</h1><p>把所有需要翻译的内容翻译完成后，使用Xcode打开项目，并打开.xcodeproj后选择Editor-&gt;Import Localizations，打开翻译文件所在的目录把.xcloc挨个导入就可以了。</p><p>这里建议先翻译并导入Development Language的.xcloc文件夹，再执行一次导出操作后再翻译其他语言并导入。因为第一次导出时source是NSLocalizedString的第一个参数，而这个参数可能并不是主语言的最终翻译，如果其他语言都把第一个参数作为source来翻译就会造成找不到对应翻译的问题。</p><div class="note info"><p>到公众号【iOS开发栈】学习更多SwiftUI、iOS开发相关内容。</p></div><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>iOS和MacOS系统以及它们自带的App在本地化方面做的非常出色，所以我们在没有特殊要求的情况下尽量依赖Xcode提供的功能来实现本地化的需求。</p>]]></content>
    
    
    <summary type="html">&lt;p&gt;国际化是出海应用非常重要的一个基础步骤，其中多语言的适配是重中之重。Xcode自带了帮助开发者进行App本地化的功能，其中包括多语言文件的导入和导出，使用这些功能可以很丝滑的完成多语言的工作。&lt;/p&gt;</summary>
    
    
    
    
    <category term="Xcode" scheme="http://www.iosprogrammer.tech/tags/Xcode/"/>
    
    <category term="国际化" scheme="http://www.iosprogrammer.tech/tags/%E5%9B%BD%E9%99%85%E5%8C%96/"/>
    
  </entry>
  
  <entry>
    <title>必看！2个关于iOS开发多语言的知识点</title>
    <link href="http://www.iosprogrammer.tech/xcode/iphone-selected-language/"/>
    <id>http://www.iosprogrammer.tech/xcode/iphone-selected-language/</id>
    <published>2021-04-05T03:18:11.000Z</published>
    <updated>2021-05-01T06:46:23.768Z</updated>
    
    <content type="html"><![CDATA[<p>在把App进行国际化的过程中会遇到很多问题，这篇文章来看一下Development Language是什么以及怎么修改它，并且看一下系统是怎么来选择使用哪个语言的。</p><a id="more"></a><div class="note info"><p>到公众号【iOS开发栈】学习更多SwiftUI、iOS开发相关内容。</p></div><h1 id="什么是Development-Language和怎么修改它"><a href="#什么是Development-Language和怎么修改它" class="headerlink" title="什么是Development Language和怎么修改它"></a>什么是Development Language和怎么修改它</h1><p>在进行国际化的过程中需要把App中的文字翻译成多个语言，其中有一种语言是Development Language，当没有任何一种语言满足当前设备的时候系统会使用Development Language。</p><p>可以通过修改<em>project.pbxproj</em>文件来修改Development Language。</p><ol><li>打开项目所在文件夹</li><li>右击.xcodeproj文件并选择*Show package Content(显示包内容)*（应该是第三个选项）</li><li>双击<em>project.phxproj</em>打开文件</li><li>搜索<em>developmentRegion</em>，并将内容修改为想要的语言。这个地方的语言是在我们添加多语言时的缩写，比如English=en、Chinese, Simpilied=zh-Hans等等。</li></ol><h1 id="iPhone是怎么选择当前使用的语言的"><a href="#iPhone是怎么选择当前使用的语言的" class="headerlink" title="iPhone是怎么选择当前使用的语言的"></a>iPhone是怎么选择当前使用的语言的</h1><ol><li>在iPhone手机的设置中“语言与地区”选择的“iPhone语言”是最高优先级，如果App的多语言包含这里设置的语言会直接使用。</li><li>如果App的多语言不包含“iPhone语言”，那么会查找“首选语言顺序”中是否有包含在多语言中的语言，按照从上到下的顺序找到一个语言后会直接使用这个语言。</li><li>如果“首选语言顺序”中也没有符合要求的，那么会使用Development Language作为App的语言。</li></ol><div class="note info"><p>到公众号【iOS开发栈】学习更多SwiftUI、iOS开发相关内容。</p></div>]]></content>
    
    
    <summary type="html">&lt;p&gt;在把App进行国际化的过程中会遇到很多问题，这篇文章来看一下Development Language是什么以及怎么修改它，并且看一下系统是怎么来选择使用哪个语言的。&lt;/p&gt;</summary>
    
    
    
    
    <category term="Xcode" scheme="http://www.iosprogrammer.tech/tags/Xcode/"/>
    
    <category term="国际化" scheme="http://www.iosprogrammer.tech/tags/%E5%9B%BD%E9%99%85%E5%8C%96/"/>
    
  </entry>
  
  <entry>
    <title>iOS App国际化必看！使用Xib使App完成国际化功能</title>
    <link href="http://www.iosprogrammer.tech/xcode/language-internalization-ib/"/>
    <id>http://www.iosprogrammer.tech/xcode/language-internalization-ib/</id>
    <published>2021-03-28T13:50:56.000Z</published>
    <updated>2021-05-01T06:46:24.985Z</updated>
    
    <content type="html"><![CDATA[<p>利用Xib或者Storyboard来做iOS的国际化是一种特别方便且高效的方式。通过简单的设置后就可以在不同的文件中把内容翻译为不同的语种，这篇文章我们来了解一下利用IB来做国际化要注意的一些问题，希望能够对你有所帮助。</p><a id="more"></a><div class="note info"><p>到公众号【iOS开发栈】学习更多SwiftUI、iOS开发相关内容。</p></div><p><img src="../../images/xcode-internaiton-ib/cover.png"></p><h1 id="完整了解国际化步骤"><a href="#完整了解国际化步骤" class="headerlink" title="完整了解国际化步骤"></a>完整了解国际化步骤</h1><p><img src="../../images/xcode-internaiton-ib/overview.png"></p><ol><li>增加国际化语言。在xcode左侧的项目目录树中点击<strong>项目名称-&gt;点击“PROJECT”中的项目名称-&gt;Info-&gt;Locatlizations</strong>，之后点击+号就可以增加自己需要的语言了。</li><li>在选择要增加的语言之后会弹出设置弹窗，把需要国际化的IB（Xib、Storyboard）文件勾选上，并且在File Types选项中选择<em>Localizable Strings</em>。</li><li>项目目录树中对应的IB文件就会成为文件夹的形式，可以看到刚刚添加的语言文件（*.strings(xxx)）。</li></ol><h1 id="添加过语言后又要增加UILabel等控件国际化"><a href="#添加过语言后又要增加UILabel等控件国际化" class="headerlink" title="添加过语言后又要增加UILabel等控件国际化"></a>添加过语言后又要增加UILabel等控件国际化</h1><p>随着版本的升级或者需求的改变，我们的IB文件很可能会发生变化，由于我们使用了IB文件进行国际化，又不能每次改版重新做一遍国际化的工作，这就要求我们可以定位到新增的控件并设置语言。</p><p>在xxx.storyboad(Base)文件中选中增加的控件，打开右侧帮助栏，找到第四个选项卡(Show the Identity Inspector)，其中有一个<strong>Object ID</strong>。</p><p>把这个ID复制到其他语言的.strings文件中，就可以设置对应的语言翻译了。其中UILabel、UIButton和UITextFiled的placehoder的设置方法如下:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;* Class &#x3D; &quot;UITextField&quot;; placeholder &#x3D; &quot;ios&quot;; ObjectID &#x3D; &quot;RCg-HC-Mcn&quot;; *&#x2F;</span><br><span class="line">&quot;RCg-HC-Mcn.placeholder&quot; &#x3D; &quot;ios&quot;;</span><br><span class="line"></span><br><span class="line">&#x2F;* Class &#x3D; &quot;UIButton&quot;; normalTitle &#x3D; &quot;Button&quot;; ObjectID &#x3D; &quot;isH-qk-FQm&quot;; *&#x2F;</span><br><span class="line">&quot;isH-qk-FQm.normalTitle&quot; &#x3D; &quot;Button&quot;;</span><br><span class="line"></span><br><span class="line">&#x2F;* Class &#x3D; &quot;UILabel&quot;; text &#x3D; &quot;iosprogrammer.tech&quot;; ObjectID &#x3D; &quot;pLC-qp-tdZ&quot;; *&#x2F;</span><br><span class="line">&quot;pLC-qp-tdZ.text&quot; &#x3D; &quot;iosprogrammer.tech&quot;;</span><br></pre></td></tr></table></figure><h1 id="一些总结"><a href="#一些总结" class="headerlink" title="一些总结"></a>一些总结</h1><ol><li>如果一个用户的设备系统语言是没有进行适配的，他下载了应用后，将会使用Base语言。比如一个葡萄言语的用户下载了一个适配了日文和韩文的app，并且这个app的Base语言是日文，那么这个用户将会看到日文。</li><li>从一个已经适配的语言切换到一个没有适配的语言，仍然会使用切换前的语言。比如从适配了的中文简体切换到了没有适配的日文，那用户看到的仍然会是中文简体。</li></ol><div class="note info"><p>到公众号【iOS开发栈】学习更多SwiftUI、iOS开发相关内容。</p></div><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>通过这篇文章我们学习了几个在使用IB来做iOS国际化的过程中需要注意的地方，如果想要充分了解到这方面的知识建议通篇阅读一下<a href="https://developer.apple.com/library/archive/documentation/MacOSX/Conceptual/BPInternational/Introduction/Introduction.html#//apple_ref/doc/uid/10000171i-CH1-SW1">官方文档</a>。</p>]]></content>
    
    
    <summary type="html">&lt;p&gt;利用Xib或者Storyboard来做iOS的国际化是一种特别方便且高效的方式。通过简单的设置后就可以在不同的文件中把内容翻译为不同的语种，这篇文章我们来了解一下利用IB来做国际化要注意的一些问题，希望能够对你有所帮助。&lt;/p&gt;</summary>
    
    
    
    
    <category term="Xcode" scheme="http://www.iosprogrammer.tech/tags/Xcode/"/>
    
    <category term="国际化" scheme="http://www.iosprogrammer.tech/tags/%E5%9B%BD%E9%99%85%E5%8C%96/"/>
    
  </entry>
  
  <entry>
    <title>告诉你3个容易被忽略的可能造成循环引用的情况和2种不会造成循环引用的情况</title>
    <link href="http://www.iosprogrammer.tech/ios/retain-cycle-problems/"/>
    <id>http://www.iosprogrammer.tech/ios/retain-cycle-problems/</id>
    <published>2021-03-19T05:16:18.000Z</published>
    <updated>2021-04-14T00:57:35.196Z</updated>
    
    <content type="html"><![CDATA[<p>循环引用是iOS开发种十分常见的一个问题，也是面试中出现频率很高的一类问题，有些经验的开发者对循环引用都有所了解，也能在开发过程中尽量避免此类问题，但是随着项目的扩大和开发时间有限有时会不经意见给引用循环引用的问题。</p><p>这类问题虽然很多时候不会出现严重的影响，但是在其他一些条件下可能会带来很蹊跷的现象，本人就深受其害。所以在这里记录一下关于循环引用的一些常用知识，也希望对你有所帮助。</p><a id="more"></a><div class="note info"><p>到公众号【iOS开发栈】学习更多SwiftUI、iOS开发相关内容。</p></div><h1 id="什么是循环引用"><a href="#什么是循环引用" class="headerlink" title="什么是循环引用"></a>什么是循环引用</h1><p>造成循环引用问题的根本原因是iOS的引用计数机制，而在引用计数机制下如果有引用不能得到即时的释放就会造成了内存泄漏，这就是循环引用。</p><p>并且为了维持App的高性能，苹果并不没有也不打算引入类似Android中的垃圾回收机制。这就造成了如果我们导致了循环引用，那么这块内存就无法得到回收。</p><p>泄漏的内存多了会造成系统强制kill掉我们的应用程序，虽然这种现象我还没有见到过不过原理上来说会出现这种情况的。</p><p>一旦有没有得到即时回收的对象内存，还可能造成一些无可预期的问题。比方说我遇到的一个问题：由于一个VC没有得到即时释放，导致里面的一个定时任务不停执行，最终导致了营收不及预期。</p><p>所以循环引用的问题，我们在开发的过程中一定要重视起来。</p><h1 id="下面3种情况会造成循环引用"><a href="#下面3种情况会造成循环引用" class="headerlink" title="下面3种情况会造成循环引用"></a>下面3种情况会造成循环引用</h1><p>会造成循环引用问题的情形很多，下面我列举了3种情况，其中有一些是老生长谈，有些是需要特别注意的，有些真的是手滑造成的。</p><p>在编码过程中时刻谨记这些情况真的可以避免很多错误发生。</p><h3 id="block"><a href="#block" class="headerlink" title="block"></a>block</h3><p>这里的block指的是view对vc的回调、model对vc的回调或者子view对父view的回调。</p><p>不论是子view还是vc中的model，我们都习惯于用strong来修饰它们，这时候在它们的block回调里面用到<code>self</code>的时候一定要用<code>weak self</code>。</p><p>并且，切记成员变量<code>_xxx</code>如果在这种block中使用也会造成循环引用。使用弱指针来指向成员变量是一种解决方案，就像这样<code>self-&gt;_redView.backgroundColor = [UIColor greenColor];</code></p><h3 id="strong修饰的delegate"><a href="#strong修饰的delegate" class="headerlink" title="strong修饰的delegate"></a>strong修饰的delegate</h3><p>我们都知道delegate要使用weak来修饰，不过在编码过程中由于疏忽可能会误用strong来修饰delegate，所以如果当你遇到循环引用可是怎么也找不到原因时，不妨从这个思路找找。我就遇到过这种情况😭 。</p><h3 id="一些异步回调"><a href="#一些异步回调" class="headerlink" title="一些异步回调"></a>一些异步回调</h3><p>有一些异步回调是使用block的形式来处理的，这就可能引起循环引用。</p><p>有一些系统的功能比方说NSTimer的定时任务就会对self造成强引用。</p><p>还有一些是我们自己的功能比方说网络请求.</p><h1 id="下面2种情况不会造成循环引用"><a href="#下面2种情况不会造成循环引用" class="headerlink" title="下面2种情况不会造成循环引用"></a>下面2种情况不会造成循环引用</h1><h3 id="用Masonry给view添加约束"><a href="#用Masonry给view添加约束" class="headerlink" title="用Masonry给view添加约束"></a>用Masonry给view添加约束</h3><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">[<span class="keyword">self</span>.redView mas_makeConstraints:^(MASConstraintMaker *make) &#123;</span><br><span class="line">    make.top.equalTo(@<span class="number">130</span>);</span><br><span class="line">    make.left.equalTo(<span class="keyword">self</span>.view.mas_left).offset(<span class="number">10</span>);</span><br><span class="line">    make.width.equalTo(@<span class="number">60</span>);</span><br><span class="line">    make.height.equalTo(@<span class="number">40</span>);</span><br><span class="line">&#125;];</span><br></pre></td></tr></table></figure><p>这种用法是不会造成循环引用的，可以放心使用。</p><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">- (<span class="built_in">NSArray</span> *)mas_makeConstraints:(<span class="keyword">void</span>(^)(MASConstraintMaker *))block &#123;</span><br><span class="line">    <span class="keyword">self</span>.translatesAutoresizingMaskIntoConstraints = <span class="literal">NO</span>;</span><br><span class="line">    MASConstraintMaker *constraintMaker = [[MASConstraintMaker alloc] initWithView:<span class="keyword">self</span>];</span><br><span class="line">    block(constraintMaker);</span><br><span class="line">    <span class="keyword">return</span> [constraintMaker install];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>从源码来看，这里的block其实是一个同步的方法，所以这里是不会造成循环引用的。</p><h3 id="使用UIView静态方法实现动画"><a href="#使用UIView静态方法实现动画" class="headerlink" title="使用UIView静态方法实现动画"></a>使用UIView静态方法实现动画</h3><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">[<span class="built_in">UIView</span> animateWithDuration:<span class="number">3</span> animations:^&#123;</span><br><span class="line">    <span class="keyword">self</span>.redView.backgroundColor = [<span class="built_in">UIColor</span> greenColor];</span><br><span class="line">&#125;];</span><br></pre></td></tr></table></figure><p>这种情况虽然在block里面引用到了self，但是不会造成循环引用。因为<code>animateWithDuration:</code>是一个类方法。</p><h1 id="开发中怎么解决循环引用问题"><a href="#开发中怎么解决循环引用问题" class="headerlink" title="开发中怎么解决循环引用问题"></a>开发中怎么解决循环引用问题</h1><p>首先这里的方法并不是什么工程级别的高深方法，只是我在开发过程中总结到的一些实用、便捷的小技巧。</p><p>当怀疑某个控制器没有得到即时的释放时，可以在这个控制器里面重写<code>dealloc</code>函数然后打印一行文字，再在这行文字上加一个断点。这样我们就可以通过进出这个控制器来看到它的<code>dealloc</code>方法是不是即时被调用了。如果没有即时调用那就是有循环引用产生，相反则没有。</p><p>确定了某个控制器内确实出现了循环引用之后，就需要定位是哪里导致的循环引用了。</p><p>我个人习惯先看是不是block导致的，要想快速的搜索到一个文件里面所有的block可以通过搜索<code>^&#123;</code>来定位，之后就是检查每个block里面是不是按规范使用了<code>self</code>。检查过程一定要仔细，不然你很可能还得重来一遍😭 。</p><p>检查完所有的block后有99%的可能已经解决了循环引用的问题，不然的话就再去检查一下delegate和是不是使用了<code>NSTimer</code>。</p><p>这个过程下来100%可以解决掉循环引用的问题，否则你来公众号找我。</p><div class="note info"><p>到公众号【iOS开发栈】学习更多SwiftUI、iOS开发相关内容。</p></div>]]></content>
    
    
    <summary type="html">&lt;p&gt;循环引用是iOS开发种十分常见的一个问题，也是面试中出现频率很高的一类问题，有些经验的开发者对循环引用都有所了解，也能在开发过程中尽量避免此类问题，但是随着项目的扩大和开发时间有限有时会不经意见给引用循环引用的问题。&lt;/p&gt;
&lt;p&gt;这类问题虽然很多时候不会出现严重的影响，但是在其他一些条件下可能会带来很蹊跷的现象，本人就深受其害。所以在这里记录一下关于循环引用的一些常用知识，也希望对你有所帮助。&lt;/p&gt;</summary>
    
    
    
    
    <category term="iOS" scheme="http://www.iosprogrammer.tech/tags/iOS/"/>
    
  </entry>
  
  <entry>
    <title>SwiftUI怎么实现UISearchBar</title>
    <link href="http://www.iosprogrammer.tech/swiftui/swiftui-searchbar/"/>
    <id>http://www.iosprogrammer.tech/swiftui/swiftui-searchbar/</id>
    <published>2021-03-13T13:33:16.000Z</published>
    <updated>2021-03-13T14:08:04.238Z</updated>
    
    <content type="html"><![CDATA[<p>SwiftUI没有提供UISearchBar，虽然我们可以通过使用TextField来自己实现SeachBar的效果，不过要想实现一个和UISearchBar同样的控件并不容易，尤其是清除按钮和搜索图标。</p><p>这里推荐直接使用UISearchBar和UIViewRepresentable协议来一个SearchBar。</p><a id="more"></a><div class="note info"><p>到公众号【iOS开发栈】学习更多SwiftUI、iOS开发相关内容。</p></div><p><img src="../../images/first/swiftui-uisearchbar.png"></p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">SearchBar</span>: <span class="title">UIViewRepresentable</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Binding</span> <span class="keyword">var</span> text: <span class="type">String</span></span><br><span class="line">    <span class="keyword">var</span> placeholder: <span class="type">String</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">var</span> onCommit: ((<span class="keyword">_</span> text: <span class="type">String</span>) -&gt; <span class="type">Void</span>)<span class="operator">?</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">func</span> <span class="title">makeUIView</span><span class="params">(context: UIViewRepresentableContext&lt;SearchBar&gt;)</span></span> -&gt; <span class="type">UISearchBar</span> &#123;</span><br><span class="line">        <span class="keyword">let</span> searchBar <span class="operator">=</span> <span class="type">UISearchBar</span>(frame: .zero)</span><br><span class="line">        searchBar.delegate <span class="operator">=</span> context.coordinator</span><br><span class="line"></span><br><span class="line">        searchBar.placeholder <span class="operator">=</span> placeholder</span><br><span class="line">        searchBar.autocapitalizationType <span class="operator">=</span> .none</span><br><span class="line">        searchBar.searchBarStyle <span class="operator">=</span> .minimal</span><br><span class="line">        <span class="keyword">return</span> searchBar</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">func</span> <span class="title">updateUIView</span><span class="params">(<span class="keyword">_</span> uiView: UISearchBar, context: UIViewRepresentableContext&lt;SearchBar&gt;)</span></span> &#123;</span><br><span class="line">        uiView.text <span class="operator">=</span> text</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">func</span> <span class="title">makeCoordinator</span><span class="params">()</span></span> -&gt; <span class="type">SearchBar</span>.<span class="type">Coordinator</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="type">Coordinator</span>(text: <span class="variable">$text</span>, onCommit: <span class="keyword">self</span>.onCommit)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="class"><span class="keyword">class</span> <span class="title">Coordinator</span>: <span class="title">NSObject</span>, <span class="title">UISearchBarDelegate</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="meta">@Binding</span> <span class="keyword">var</span> text: <span class="type">String</span></span><br><span class="line">        <span class="keyword">var</span> onCommit: ((<span class="keyword">_</span> text: <span class="type">String</span>) -&gt; <span class="type">Void</span>)<span class="operator">?</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">init</span>(text: <span class="type">Binding</span>&lt;<span class="type">String</span>&gt;, onCommit: ((<span class="keyword">_</span> text: <span class="type">String</span>) -&gt; <span class="type">Void</span>)<span class="operator">?</span>) &#123;</span><br><span class="line">            _text <span class="operator">=</span> text</span><br><span class="line">            <span class="keyword">self</span>.onCommit <span class="operator">=</span> onCommit</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">func</span> <span class="title">searchBar</span><span class="params">(<span class="keyword">_</span> searchBar: UISearchBar, textDidChange searchText: String)</span></span> &#123;</span><br><span class="line">            text <span class="operator">=</span> searchText</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="function"><span class="keyword">func</span> <span class="title">searchBarSearchButtonClicked</span><span class="params">(<span class="keyword">_</span> searchBar: UISearchBar)</span></span> &#123;</span><br><span class="line">            <span class="keyword">if</span> <span class="keyword">let</span> onCommit <span class="operator">=</span> <span class="keyword">self</span>.onCommit &#123;</span><br><span class="line">                onCommit(searchBar.text <span class="operator">??</span> <span class="string">&quot;&quot;</span>)</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>UIViewRepresentable</code>是SwiftUI框架中提供的用于将UIView转换成SwiftUI中View的协议。</p><p><code>func makeUIView(context: Self.Context) -&gt; Self.UIViewType</code>用来创建View的方法，遵守UIViewRepresentable协议的类必须要实现这个方法。它的返回值是一个UIView类的实例。这个方法只会在创建View时调用一次，当View需要更新时会调用下面的这个方法。</p><p><code>func updateUIView(_ uiView: Self.UIViewType, context: Self.Context)</code>当UIView发生任何需要更新状态的事件时，这个方法就会被调用来更新View的状态。</p><p><code>func makeCoordinator() -&gt; Self.Coordinator</code>需要一个<code>Coordinator</code>的实例作为返回值。它通常用来处理一些事件（点击、时间、delegate、通知）引起了UIView的状态变化后，能够将新的状态反映到View上。</p><div class="note info"><p>到公众号【iOS开发栈】学习更多SwiftUI、iOS开发相关内容。</p></div>]]></content>
    
    
    <summary type="html">&lt;p&gt;SwiftUI没有提供UISearchBar，虽然我们可以通过使用TextField来自己实现SeachBar的效果，不过要想实现一个和UISearchBar同样的控件并不容易，尤其是清除按钮和搜索图标。&lt;/p&gt;
&lt;p&gt;这里推荐直接使用UISearchBar和UIViewRepresentable协议来一个SearchBar。&lt;/p&gt;</summary>
    
    
    
    
    <category term="SwiftUI" scheme="http://www.iosprogrammer.tech/tags/SwiftUI/"/>
    
  </entry>
  
  <entry>
    <title>iOS设置渐变色，给border设置渐变色</title>
    <link href="http://www.iosprogrammer.tech/ios/ios-gradient-color/"/>
    <id>http://www.iosprogrammer.tech/ios/ios-gradient-color/</id>
    <published>2021-03-07T12:50:56.000Z</published>
    <updated>2021-03-08T01:50:12.123Z</updated>
    
    <content type="html"><![CDATA[<p>本文将从4行代码出发给一个view设置渐变色，分别会谈到几个重要的渐变色相关属性，在使用过程中有几个需要特别关注的点。</p><p>给一个view的border设置渐变色是比较高阶的用法，希望本文可以在这个方面帮助到你。</p><a id="more"></a><p><img src="../../images/first/ios-gradient-color-border.png" alt="ios渐变色"></p><div class="note info"><p>到公众号【iOS开发栈】学习更多SwiftUI、iOS开发相关内容。</p></div><h1 id="给view设置渐变色"><a href="#给view设置渐变色" class="headerlink" title="给view设置渐变色"></a>给view设置渐变色</h1><p>通过4行代码就可以给一个view设置渐变色：</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> view <span class="operator">=</span> <span class="type">UIView</span>(frame: <span class="type">CGRect</span>(x: <span class="number">100</span>, y: <span class="number">100</span>, width: <span class="number">100</span>, height: <span class="number">100</span>))</span><br><span class="line"><span class="keyword">let</span> gradientLayer <span class="operator">=</span> <span class="type">CAGradientLayer</span>()</span><br><span class="line">gradientLayer.frame <span class="operator">=</span> view.bounds</span><br><span class="line"><span class="comment">// @[(__bridge id)[UIColor redColor].CGColor, (__bridge id)[UIColor yellowColor].CGColor]</span></span><br><span class="line">gradientLayer.colors <span class="operator">=</span> [<span class="type">UIColor</span>.red.cgColor, <span class="type">UIColor</span>.yellow.cgColor]</span><br><span class="line">view.layer.addSublayer(gradientLayer)</span><br></pre></td></tr></table></figure><p>在创建<code>CAGradientLayer</code>以后需要设置<code>frame</code>才能展示出来，否则它的大小会使用默认的0。</p><p>渐变色会根据<code>colors</code>数组来展示，这个数组的类型是<code>CGColorRef</code>，所以需要用<code>.cgColor</code>强制转换；如果使用的OC语法，必须加上<code>(__bridge id)</code>，否则渐变色会显示不出来。</p><p>默认情况下渐变会从上至下，可是通过设置<code>startPoint</code>和<code>endPoint</code>来改变这个顺序：</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">gradientLayer.startPoint <span class="operator">=</span> <span class="type">CGPoint</span>(x: <span class="number">0</span>, y: <span class="number">0</span>)</span><br><span class="line">gradientLayer.endPoint <span class="operator">=</span> <span class="type">CGPoint</span>(x: <span class="number">1</span>, y: <span class="number">1</span>)</span><br></pre></td></tr></table></figure><p>这两个点的范围是从0到1，也就是说最左边和最上边是0，最下和最右是1。这个例子中渐变会变成从左上角到右下角。</p><p>渐变色还有一个重要的属性是<code>locations</code>，这个属性是用来指定<code>colors</code>中设置的每个颜色的终点的。</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">gradientLayer.locations <span class="operator">=</span> [<span class="number">0.2</span>, <span class="number">0.8</span>]</span><br></pre></td></tr></table></figure><p>locations中元素的范围是从0到1。在这里，数组中的第一个元素<em>0.2</em>指定了colors数组中第一个元素<em>红色</em>的终点是0.2，也就是说把整个渐变色范围分成10份，从开始到<em>2/10</em>处都是纯红色，从<em>2/10</em>到<em>8/10</em>处是纯红色到纯黄色的渐变，而从<em>8/10</em>到<em>10/10</em>是纯黄色。</p><h1 id="给view的border设置渐变色"><a href="#给view的border设置渐变色" class="headerlink" title="给view的border设置渐变色"></a>给view的border设置渐变色</h1><p>使用<code>UIBezierPath</code>来创建一个带圆角的<code>CAShapeLayer</code>，并且把它的圆角设置成view的圆角，就可以把一个view的border设置为渐变色。</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="operator">...</span> <span class="comment">// 同上给view设置gradientLayer</span></span><br><span class="line">        </span><br><span class="line"><span class="keyword">let</span> shapeLayer <span class="operator">=</span> <span class="type">CAShapeLayer</span>()</span><br><span class="line">shapeLayer.borderWidth <span class="operator">=</span> <span class="number">1</span></span><br><span class="line">shapeLayer.path <span class="operator">=</span> <span class="type">UIBezierPath</span>(roundedRect: gradientLayer.bounds, cornerRadius: <span class="number">10</span>).cgPath</span><br><span class="line">shapeLayer.fillColor <span class="operator">=</span> <span class="type">UIColor</span>.clear.cgColor <span class="comment">// 必须要设置成clearColor或者nil，默认是黑色</span></span><br><span class="line">shapeLayer.strokeColor <span class="operator">=</span> <span class="type">UIColor</span>.white.cgColor <span class="comment">// 随便设置一个非clearColor的颜色</span></span><br><span class="line">        </span><br><span class="line">gradientLayer.mask <span class="operator">=</span> shapeLayer</span><br><span class="line"></span><br><span class="line">view.layer.addSublayer(gradientLayer)</span><br></pre></td></tr></table></figure><ol><li><em>borderWidth</em> shapeLayer的border宽度和view的相同，可以根据设计图来设置。</li><li><em>cornerRadius</em> UIBezierPath的圆角和view的圆角相同；<em>roundedRect</em>和<em>CAGradientLayer</em>的大小相同。</li><li><em>fillColor</em> 是shapeLayer的填充色，默认是黑色，建议设置成nil或者是透明色<code>clearColor</code></li><li><em>strokeColor</em> 是border的描边色，如果设置成clearColor的话就不会绘制出来border了，这里随便一个颜色就是让其能够绘制出来，实际使用的是渐变色</li><li><em>mask</em> 用shapeLayer作为gradientLayer的mask，可以让gradientLayer内部挖空，只保留边缘border的渐变颜色</li><li>最终把渐变色layer添加到view.layer上，shapeLayer只是用来修饰gradientlayer的，目的是把gradientlayer的内部挖空，并且把border和圆角做出来。</li></ol><div class="note info"><p>到公众号【iOS开发栈】学习更多SwiftUI、iOS开发相关内容。</p></div><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>通过这篇文章我们了解了怎么给一个view设置渐变色，并详细阐述了渐变色的几个重要属性。关于给border设置渐变色是一个进阶的知识点。</p><p>希望本篇文章能够帮助到你，也欢迎你把文章分享到朋友圈或微博。</p><p>有任何问题都可以到公众号给我发信息。</p>]]></content>
    
    
    <summary type="html">&lt;p&gt;本文将从4行代码出发给一个view设置渐变色，分别会谈到几个重要的渐变色相关属性，在使用过程中有几个需要特别关注的点。&lt;/p&gt;
&lt;p&gt;给一个view的border设置渐变色是比较高阶的用法，希望本文可以在这个方面帮助到你。&lt;/p&gt;</summary>
    
    
    
    
    <category term="iOS" scheme="http://www.iosprogrammer.tech/tags/iOS/"/>
    
  </entry>
  
  <entry>
    <title>environment和environmentObject的区别及适用场景</title>
    <link href="http://www.iosprogrammer.tech/swiftui/environment-vs-environmentObject/"/>
    <id>http://www.iosprogrammer.tech/swiftui/environment-vs-environmentObject/</id>
    <published>2021-03-05T03:25:18.000Z</published>
    <updated>2021-03-05T07:01:31.618Z</updated>
    
    <content type="html"><![CDATA[<p>SwiftUI中传递环境变量时会发现两个相似的方法：<code>environment&lt;V&gt;(_ keyPath:, _ value:)</code>和<code>environmentObject&lt;T&gt;(_ object:)</code>，这篇文章我们来看一下这两个方法的不同之处和分别的适用场景。</p><a id="more"></a><p><img src="../../images/first/swiftui-environmentobject-environment.png" alt="Swift环境变量对比"></p><div class="note info"><p>到公众号【iOS开发栈】学习更多SwiftUI、iOS开发相关内容。回复“博客”免费获取各大互联网公司面试题。</p></div><p>首先要明确的一点是，这两个方法都是用来设置环境变量的，而环境变量会影响到被设置变量的视图以及它的所有子视图，并且这个传递过程不需要明确指出。</p><p>也就是说，假设有三个视图，view1、view2、view3，其中view2和view3是view1的子视图，要想在view2和view3中使用view1设置的环境变量的话，只需要直接在view中使用<code>@EnvironmentObject</code>或者<code>@Environment</code>而不需要在创建view2和view3的时候显式传参。</p><h1 id="EnvironmentObject"><a href="#EnvironmentObject" class="headerlink" title="@EnvironmentObject"></a>@EnvironmentObject</h1><p>下面以<code>@EnvironmentObject</code>举例说明上面的这段话：</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 公众号——iOS开发栈</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">OfficalAccount</span>: <span class="title">ObservableObject</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Published</span> <span class="keyword">var</span> amount <span class="operator">=</span> <span class="number">3000</span> <span class="comment">// 订阅人数</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">DetailView</span>: <span class="title">View</span> </span>&#123;</span><br><span class="line">    <span class="meta">@EnvironmentObject</span> <span class="keyword">var</span> account: <span class="type">OfficalAccount</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">var</span> body: <span class="keyword">some</span> <span class="type">View</span> &#123;</span><br><span class="line">        <span class="type">VStack</span> &#123;</span><br><span class="line">            <span class="type">Button</span>(<span class="string">&quot;Increase Score in detailView&quot;</span>) &#123;</span><br><span class="line">                account.amount <span class="operator">+=</span> <span class="number">1</span></span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="type">Text</span>(<span class="string">&quot;account: <span class="subst">\(account.amount)</span>&quot;</span>)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">DetailView2</span>: <span class="title">View</span> </span>&#123;</span><br><span class="line">    <span class="meta">@EnvironmentObject</span> <span class="keyword">var</span> account: <span class="type">OfficalAccount</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">var</span> body: <span class="keyword">some</span> <span class="type">View</span> &#123;</span><br><span class="line">        <span class="type">Text</span>(<span class="string">&quot;Score: <span class="subst">\(account.amount)</span>&quot;</span>)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">ContentView</span>: <span class="title">View</span> </span>&#123;</span><br><span class="line">    <span class="meta">@StateObject</span> <span class="keyword">var</span> account <span class="operator">=</span> <span class="type">OfficalAccount</span>()</span><br><span class="line"></span><br><span class="line">    <span class="keyword">var</span> body: <span class="keyword">some</span> <span class="type">View</span> &#123;</span><br><span class="line">        <span class="type">VStack</span> &#123;</span><br><span class="line">            <span class="type">Button</span>(<span class="string">&quot;Increase Score&quot;</span>) &#123;</span><br><span class="line">                account.amount <span class="operator">+=</span> <span class="number">1</span></span><br><span class="line">            &#125;</span><br><span class="line">            </span><br><span class="line">            <span class="type">DetailView</span>()</span><br><span class="line">            <span class="type">DetailView2</span>()</span><br><span class="line">        &#125;</span><br><span class="line">        .environmentObject(account)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上面的例子是以我的公众号（”iOS开发栈“）的订阅人数做说明，可以看出<em>ContentView</em>创建<em>DetailView</em>和<em>DetailView2</em>时并没有直接传递变量<em>accout</em>，但是结果是这两个子视图中的数量显示会随着点击按钮而增加。</p><p>对上面使用<code>environmentObject</code>进行环境变量传递有几点需要注意：</p><ul><li>使用<code>@Environment</code>、<code>@StateObject</code>、<code>@ObservedObject</code>包装的类必须遵守<code>ObservableObject</code>协议，并且只能是类不能是结构体，否则会报错 <mark class="label danger">Non-class type OfficalAccount cannot conform to class protocol ObservableObject</mark></li><li><code>@Published</code>也只能在<em>class</em>中使用，如果放在了struct中，会报错<mark class="label danger">'wrappedValue' is unavailable: </mark></li><li>使用<code>@EnvironmentObject</code>包装的变量是不需要初始化的，编译器会从环境变量中获取这个对象的值</li><li>在子视图中可以修改了环境变量的值，并且这个改变会在当前的视图层级中传递</li></ul><h1 id="Environment"><a href="#Environment" class="headerlink" title="@Environment"></a>@Environment</h1><p>而对于<code>@Environment</code>来说，它主要是用来处理一些当前的系统设置的，比如说语言、时区、黑暗模式、CoreData的Context等。</p><p>在使用过程中一个很大的不同是，<code>@Environment(_ keyPath:)</code>需要指定一个类型为<code>KeyPath</code>的参数，而这个参数大多数情况下我们都是使用的<code>EnvironmentValues</code>中已经定义好的，比如<code>managedObjectContext</code>/<code>locale</code>等。</p><p>下面以使用<em>CoreData</em>为例说明使用方法：</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// App.swift</span></span><br><span class="line"><span class="operator">...</span></span><br><span class="line"><span class="keyword">let</span> persistenceController <span class="operator">=</span> <span class="type">PersistenceController</span>.shared</span><br><span class="line"><span class="operator">...</span></span><br><span class="line"><span class="keyword">var</span> body: <span class="keyword">some</span> <span class="type">Scene</span> &#123;</span><br><span class="line">    <span class="type">WindowGroup</span> &#123;</span><br><span class="line">        <span class="type">ContentView</span>()</span><br><span class="line">            .environment(\.managedObjectContext, persistenceController.container.viewContext)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="operator">...</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// ContentView.swift</span></span><br><span class="line"><span class="operator">...</span></span><br><span class="line"><span class="meta">@Environment</span>(\.managedObjectContext) <span class="keyword">private</span> <span class="keyword">var</span> viewContext</span><br><span class="line"><span class="operator">...</span></span><br><span class="line"><span class="keyword">let</span> newItem <span class="operator">=</span> <span class="type">Item</span>(context: viewContext)</span><br><span class="line">newItem.platform <span class="operator">=</span> <span class="number">1</span></span><br><span class="line"><span class="operator">...</span></span><br></pre></td></tr></table></figure><p>在这个例子中，我们在<em>App.swift</em>中创建了<code>persistenceController</code>并通过调用<code>.environment</code>把值传递给了<em>ContentView</em>。<em>ContentView</em>中使用<code>@Environment(\.managedObjectContext) private var viewContext</code>获取到了这个环境变量。</p><p>除了需要一个KeyPath和上面提到的主要用来处理系统自带的环境变量外，<code>@Environment</code>和<code>@EnvironmentObject</code>在用法上相差不大。</p><div class="note info"><p>到公众号【iOS开发栈】学习更多SwiftUI、iOS开发相关内容。回复“博客”免费获取各大互联网公司面试题。</p></div><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>通过灵活使用环境变量，可以让开发过程更加简单，页面之间可以写更少的值传递（正向、反相）相关代码。通过本文对<code>Environment</code>和<code>EnvironmentObject</code>的对比，我们更深入的了解了SwiftUI中环境变量的一些使用细节。</p><p>如果本文对你有帮助请帮忙分享到朋友圈或者微博。</p><p>如果有任何问题也可以到公众号联系我。</p>]]></content>
    
    
    <summary type="html">&lt;p&gt;SwiftUI中传递环境变量时会发现两个相似的方法：&lt;code&gt;environment&amp;lt;V&amp;gt;(_ keyPath:, _ value:)&lt;/code&gt;和&lt;code&gt;environmentObject&amp;lt;T&amp;gt;(_ object:)&lt;/code&gt;，这篇文章我们来看一下这两个方法的不同之处和分别的适用场景。&lt;/p&gt;</summary>
    
    
    
    
    <category term="SwiftUI" scheme="http://www.iosprogrammer.tech/tags/SwiftUI/"/>
    
  </entry>
  
  <entry>
    <title>在SwiftUI中实现UISegmentControl</title>
    <link href="http://www.iosprogrammer.tech/swiftui/swiftui-uisegmentcontrol/"/>
    <id>http://www.iosprogrammer.tech/swiftui/swiftui-uisegmentcontrol/</id>
    <published>2021-03-04T03:09:44.000Z</published>
    <updated>2021-03-04T10:24:09.339Z</updated>
    
    <content type="html"><![CDATA[<p>在SwiftUI中官方把控件做了精简，造成有些在UIKit中使用的控件找不到了。这篇文章来看一下UIPickerView在SwiftUI中是怎么表示的。</p><a id="more"></a><p>了解了一些SwiftUI的基础知识以后，应该就知道有一个<code>Picker</code>控件，想要实现UISegmentControl的效果就要用到这个控件。</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@State</span> <span class="keyword">var</span> platform <span class="operator">=</span> <span class="number">1</span></span><br><span class="line">    </span><br><span class="line"><span class="keyword">var</span> body: <span class="keyword">some</span> <span class="type">View</span> &#123;</span><br><span class="line">    <span class="type">VStack</span> &#123;</span><br><span class="line">        <span class="type">Picker</span>(<span class="string">&quot;平台名称&quot;</span>, selection: <span class="variable">$platform</span>) &#123;</span><br><span class="line">            <span class="type">Text</span>(<span class="string">&quot;支付宝&quot;</span>).tag(<span class="number">1</span>).navigationTitle(<span class="string">&quot;选择平台&quot;</span>)</span><br><span class="line">            <span class="type">Text</span>(<span class="string">&quot;京东金融&quot;</span>).tag(<span class="number">2</span>)</span><br><span class="line">        &#125;</span><br><span class="line">        .pickerStyle(<span class="type">SegmentedPickerStyle</span>())</span><br><span class="line">        </span><br><span class="line">        <span class="type">Text</span>(<span class="string">&quot;<span class="subst">\(platform)</span>&quot;</span>)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>使用这段代码就可以得到一个UISegmentControl效果的Picker了。</p><p>其中关键部分是<code>.pickerStyle(SegmentedPickerStyle())</code>，pickerStyle是一个设置Picker样式的Modifier，<code>SegmentedPickerStyle</code>就是外型和UISegmentControl一摸一样的效果。</p><p>除了SegmentedPickerStyle以外，pickerStyle还有下面几种类型：</p><ul><li><code>DefaultPickerStyle</code> 在不同平台有不同的展现形式。iOS平台上和<em>InlinePickerStyle</em>相同都是滚轮样式；MacOS平台和<em>MenuPickerStyle</em>相同；tvOS平台上和<em>SegmentedPickerStyle</em>相同</li><li><code>InlinePickerStyle</code>/<code>WheelPickerStyle</code> 滚轮样式</li><li><code>MenuPickerStyle</code> 点击后Picker的text后弹出选项，有点类似于<code>MenuController</code></li><li><code>RadioGroupPickerStyle</code> MacOS上使用的，所有选项一字排开，每个前面都有一个复选框☑️</li><li><code>SegmentedPickerStyle</code> 上面说的模仿UISegmentControl的外形，使用这种style的时候，Picker的content只能是Text或者Image</li></ul><div class="note info"><p>到公众号【iOS开发栈】学习更多SwiftUI、iOS开发相关内容。</p></div>]]></content>
    
    
    <summary type="html">&lt;p&gt;在SwiftUI中官方把控件做了精简，造成有些在UIKit中使用的控件找不到了。这篇文章来看一下UIPickerView在SwiftUI中是怎么表示的。&lt;/p&gt;</summary>
    
    
    
    
    <category term="SwiftUI" scheme="http://www.iosprogrammer.tech/tags/SwiftUI/"/>
    
  </entry>
  
  <entry>
    <title>3个关于SwiftUI中TextField不得不看的知识点</title>
    <link href="http://www.iosprogrammer.tech/swiftui/swiftui-textfield/"/>
    <id>http://www.iosprogrammer.tech/swiftui/swiftui-textfield/</id>
    <published>2021-02-27T12:21:57.000Z</published>
    <updated>2021-02-27T13:12:43.176Z</updated>
    
    <content type="html"><![CDATA[<p>几乎每一个iOS App都需要处理用户交互，输入框作为获取用户输入内容的最常用控件之一是开发者经常用到的一个控件。这篇文章我们来看一下在iOS14中怎么使用全新的SwiftUI框架来处理TextField。</p><a id="more"></a><div class="note info"><p>到公众号【iOS开发栈】学习更多SwiftUI、iOS开发相关内容。</p></div><p><img src="../../images/first/swiftui-textfiled.png" alt="SwiftUI TextField知识点"></p><h1 id="SwiftUI创建一个基础的TextField"><a href="#SwiftUI创建一个基础的TextField" class="headerlink" title="SwiftUI创建一个基础的TextField"></a>SwiftUI创建一个基础的TextField</h1><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">ContentView</span>: <span class="title">View</span> </span>&#123;</span><br><span class="line">    <span class="meta">@State</span> <span class="keyword">private</span> <span class="keyword">var</span> aStr <span class="operator">=</span> <span class="string">&quot;&quot;</span></span><br><span class="line">    <span class="keyword">var</span> body: <span class="keyword">some</span> <span class="type">View</span> &#123;</span><br><span class="line">        <span class="type">VStack</span> &#123;</span><br><span class="line">            <span class="type">TextField</span>(<span class="string">&quot;公众号&lt;iOS开发栈&gt;&quot;</span>, text: <span class="variable">$aStr</span>)</span><br><span class="line">            </span><br><span class="line">            <span class="type">Text</span>(aStr)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>创建一个<code>TextField</code>需要两个参数，一个占位符和一个<a href="https://www.iosprogrammer.tech/swiftui/swiftui-data-flow.html"><code>Bind&lt;Binding&lt;String</code></a>。</p><h1 id="TextFieldStyle"><a href="#TextFieldStyle" class="headerlink" title="TextFieldStyle"></a>TextFieldStyle</h1><p>通过设置<code>textFieldStyle</code>可以修改<code>TextField</code>的展现样式，在SwiftUI中系统自带了UIKit框架中的几个样式：<code>DefaultTextFieldStyle</code>/<code>PlainTextFieldStyle</code>/<code>RoundedBorderTextFieldStyle</code>。</p><p>设置的方法是：</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">TextField</span>(<span class="string">&quot;公众号&lt;iOS开发栈&gt;&quot;</span>, text: <span class="variable">$aStr</span>)</span><br><span class="line">    .textFieldStyle(<span class="type">DefaultTextFieldStyle</span>())</span><br></pre></td></tr></table></figure><blockquote><p>如果系统自带的这三种样式都不能满足需求，也可以自定义TextField的样式</p></blockquote><h1 id="TextField文本对齐方式"><a href="#TextField文本对齐方式" class="headerlink" title="TextField文本对齐方式"></a>TextField文本对齐方式</h1><p>在SwiftUI中设置TextField的文本对齐方式使用的modifier是<code>multilineTextAlignment</code>，其中包含<code>leading</code>/<code>center</code>/<code>trailing</code>三种对齐方式。</p><p>使用这个modifier的方法如下：</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">TextField</span>(<span class="string">&quot;公众号&lt;iOS开发栈&gt;&quot;</span>, text: <span class="variable">$aStr</span>)</span><br><span class="line">    .multilineTextAlignment(.trailing)</span><br></pre></td></tr></table></figure><div class="note info"><p>到公众号【iOS开发栈】学习更多SwiftUI、iOS开发相关内容。</p></div><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>这篇文章对SwiftUI框架中的<code>TextFiled</code>控件进行了讲解，主要涉及了创建方法、修改展示样式和设置文本对齐方法三个方面，希望对你有所帮助。</p>]]></content>
    
    
    <summary type="html">&lt;p&gt;几乎每一个iOS App都需要处理用户交互，输入框作为获取用户输入内容的最常用控件之一是开发者经常用到的一个控件。这篇文章我们来看一下在iOS14中怎么使用全新的SwiftUI框架来处理TextField。&lt;/p&gt;</summary>
    
    
    
    
    <category term="SwiftUI" scheme="http://www.iosprogrammer.tech/tags/SwiftUI/"/>
    
  </entry>
  
  <entry>
    <title>SwiftUI给Color添加扩展支持十六进制字符串</title>
    <link href="http://www.iosprogrammer.tech/swiftui/SwiftUI-Color-Hex/"/>
    <id>http://www.iosprogrammer.tech/swiftui/SwiftUI-Color-Hex/</id>
    <published>2021-02-26T03:06:25.000Z</published>
    <updated>2021-02-26T03:21:50.689Z</updated>
    
    <content type="html"><![CDATA[<p>SwiftUI中使用<code>Color</code>表示颜色，为了能够尽量独立的使用SwiftUI特性，我们通过给Color添加一个简单的扩展来满足对十六进制颜色的使用。</p><a id="more"></a><p>下面是这个扩展的所有代码：</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">extension</span> <span class="title">Color</span> </span>&#123;</span><br><span class="line">    <span class="keyword">init</span>(hex: <span class="type">String</span>) &#123;</span><br><span class="line">        <span class="keyword">let</span> hex <span class="operator">=</span> hex.trimmingCharacters(<span class="keyword">in</span>: <span class="type">CharacterSet</span>.alphanumerics.inverted)</span><br><span class="line">        <span class="keyword">var</span> int: <span class="type">UInt64</span> <span class="operator">=</span> <span class="number">0</span></span><br><span class="line">        <span class="type">Scanner</span>(string: hex).scanHexInt64(<span class="operator">&amp;</span>int)</span><br><span class="line">        <span class="keyword">let</span> a, r, g, b: <span class="type">UInt64</span></span><br><span class="line">        <span class="keyword">switch</span> hex.count &#123;</span><br><span class="line">        <span class="keyword">case</span> <span class="number">3</span>: <span class="comment">// RGB (12-bit)</span></span><br><span class="line">            (a, r, g, b) <span class="operator">=</span> (<span class="number">255</span>, (int <span class="operator">&gt;&gt;</span> <span class="number">8</span>) <span class="operator">*</span> <span class="number">17</span>, (int <span class="operator">&gt;&gt;</span> <span class="number">4</span> <span class="operator">&amp;</span> <span class="number">0xF</span>) <span class="operator">*</span> <span class="number">17</span>, (int <span class="operator">&amp;</span> <span class="number">0xF</span>) <span class="operator">*</span> <span class="number">17</span>)</span><br><span class="line">        <span class="keyword">case</span> <span class="number">6</span>: <span class="comment">// RGB (24-bit)</span></span><br><span class="line">            (a, r, g, b) <span class="operator">=</span> (<span class="number">255</span>, int <span class="operator">&gt;&gt;</span> <span class="number">16</span>, int <span class="operator">&gt;&gt;</span> <span class="number">8</span> <span class="operator">&amp;</span> <span class="number">0xFF</span>, int <span class="operator">&amp;</span> <span class="number">0xFF</span>)</span><br><span class="line">        <span class="keyword">case</span> <span class="number">8</span>: <span class="comment">// ARGB (32-bit)</span></span><br><span class="line">            (a, r, g, b) <span class="operator">=</span> (int <span class="operator">&gt;&gt;</span> <span class="number">24</span>, int <span class="operator">&gt;&gt;</span> <span class="number">16</span> <span class="operator">&amp;</span> <span class="number">0xFF</span>, int <span class="operator">&gt;&gt;</span> <span class="number">8</span> <span class="operator">&amp;</span> <span class="number">0xFF</span>, int <span class="operator">&amp;</span> <span class="number">0xFF</span>)</span><br><span class="line">        <span class="keyword">default</span>:</span><br><span class="line">            (a, r, g, b) <span class="operator">=</span> (<span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">0</span>)</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">self</span>.<span class="keyword">init</span>(</span><br><span class="line">            .sRGB,</span><br><span class="line">            red: <span class="type">Double</span>(r) <span class="operator">/</span> <span class="number">255</span>,</span><br><span class="line">            green: <span class="type">Double</span>(g) <span class="operator">/</span> <span class="number">255</span>,</span><br><span class="line">            blue:  <span class="type">Double</span>(b) <span class="operator">/</span> <span class="number">255</span>,</span><br><span class="line">            opacity: <span class="type">Double</span>(a) <span class="operator">/</span> <span class="number">255</span></span><br><span class="line">        )</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>使用方法如下：</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">Color</span>(hex: <span class="string">&quot;#FF6D5D&quot;</span>)</span><br></pre></td></tr></table></figure><div class="note info"><p>到公众号【iOS开发栈】学习更多SwiftUI、iOS开发相关内容。</p></div>]]></content>
    
    
    <summary type="html">&lt;p&gt;SwiftUI中使用&lt;code&gt;Color&lt;/code&gt;表示颜色，为了能够尽量独立的使用SwiftUI特性，我们通过给Color添加一个简单的扩展来满足对十六进制颜色的使用。&lt;/p&gt;</summary>
    
    
    
    
    <category term="SwiftUI" scheme="http://www.iosprogrammer.tech/tags/SwiftUI/"/>
    
  </entry>
  
  <entry>
    <title>详解SwiftUI中Divider和Spacer的用法和区别（最新）</title>
    <link href="http://www.iosprogrammer.tech/swiftui/swiftui-divide-spacer/"/>
    <id>http://www.iosprogrammer.tech/swiftui/swiftui-divide-spacer/</id>
    <published>2021-02-17T11:43:10.000Z</published>
    <updated>2021-02-25T06:53:41.437Z</updated>
    
    <content type="html"><![CDATA[<p>Divider和Spacer都可以用到分割两个视图，但是它们也有一些区别。通过这篇文章我们将学到这两个控件的使用方式和它们之间的区别。</p><a id="more"></a><div class="note info"><p>到公众号【iOS开发栈】学习更多SwiftUI、iOS开发相关内容。</p></div><p><img src="../../images/first/SwiftUI-Divider-Spacer.jpg" alt="SwiftUI-Divider-vs-Spacer"></p><h1 id="Spacer"><a href="#Spacer" class="headerlink" title="Spacer"></a>Spacer</h1><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">ContentView</span>: <span class="title">View</span> </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> body: <span class="keyword">some</span> <span class="type">View</span> &#123;</span><br><span class="line">        <span class="type">VStack</span> &#123;</span><br><span class="line">            <span class="type">Text</span>(<span class="string">&quot;Top&quot;</span>).background(<span class="type">Color</span>.red)</span><br><span class="line">            <span class="type">Spacer</span>()</span><br><span class="line">            <span class="type">Text</span>(<span class="string">&quot;Bottom&quot;</span>).background(<span class="type">Color</span>.red)</span><br><span class="line">        &#125;</span><br><span class="line">        .frame(width: <span class="number">100</span>, height: <span class="number">400</span>, alignment: .center)</span><br><span class="line">        .background(<span class="type">Color</span>.yellow)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在“Top”和“Bottom”之间添加一个<code>Spacer</code>控件，会把这两个文字隔开，使这两个文字分别位于最上和最下面。</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">Spacer</span>(minLength: <span class="number">30</span>)</span><br></pre></td></tr></table></figure><p>通过设置<code>minLength</code>可以指定被分开的两个视图的最小距离，如果不指定的话，会有一个默认的距离。</p><h1 id="Divider"><a href="#Divider" class="headerlink" title="Divider"></a>Divider</h1><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">VStack</span> &#123;</span><br><span class="line">    <span class="type">Text</span>(<span class="string">&quot;Top&quot;</span>).background(<span class="type">Color</span>.red)</span><br><span class="line">    <span class="type">Divider</span>().background(<span class="type">Color</span>.red)</span><br><span class="line">    <span class="type">Text</span>(<span class="string">&quot;Bottom&quot;</span>).background(<span class="type">Color</span>.red)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Top和Bottom之间添加一个Divider控件可以在两个视图之间添加一个间隔，和上面的<code>Spacer</code>不同的是中间会出现一根线，<code>background</code>设置的颜色会影响到这根线的颜色。</p><p>并且，被Divider分割的两个视图中间的距离是固定的，它们不会移动到父视图的两端。</p><p>另外，把<code>Divider</code>的高度分别设置为0之后，被它分割的两个视图不会靠在一起。但是把<code>Spacer</code>的高度设置为0，被它分割的两个视图会靠在一起，就和没有被分割一样。</p><div class="note info"><p>到公众号【iOS开发栈】学习更多SwiftUI、iOS开发相关内容。回复“博客”免费获取各大互联网公司面试题。</p></div><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>这篇文章学习了SwiftUI中<code>Spacer</code>和<code>Divider</code>的用法以及它们之间的区别，这两个控件在SwiftUI中虽然简单但是非常的常用，我们一定要熟悉。如果你有任何的问题、建议都可以通过<a href="https://weibo.com/7414691003/profile">微博</a>或<a href="mailto:shizhiang@126.com">邮件</a>联系到我本人。</p>]]></content>
    
    
    <summary type="html">&lt;p&gt;Divider和Spacer都可以用到分割两个视图，但是它们也有一些区别。通过这篇文章我们将学到这两个控件的使用方式和它们之间的区别。&lt;/p&gt;</summary>
    
    
    
    
    <category term="SwiftUI" scheme="http://www.iosprogrammer.tech/tags/SwiftUI/"/>
    
  </entry>
  
  <entry>
    <title>iOS完整集成admob教程（2021）</title>
    <link href="http://www.iosprogrammer.tech/ios/ios-integrate-admob/"/>
    <id>http://www.iosprogrammer.tech/ios/ios-integrate-admob/</id>
    <published>2021-02-06T11:57:33.000Z</published>
    <updated>2021-02-25T06:53:41.437Z</updated>
    
    <content type="html"><![CDATA[<p>Admob是谷歌推出的广告服务，其中包含的广告类型有：banner、插屏、激励、开屏（最近添加的）。利用Admob的中介组可以引入其他广告商的广告，比如FaceBook、unity等10多家平台。对于出海的App集成Admob是非常必要的变现手段。</p><a id="more"></a><div class="note info"><p>到公众号【iOS开发栈】学习更多SwiftUI、iOS开发相关内容。</p></div><p><img src="../../images/admob/admob.png" alt="Admob 集成"></p><h1 id="通过Cocoapods导入Admob-SDK"><a href="#通过Cocoapods导入Admob-SDK" class="headerlink" title="通过Cocoapods导入Admob SDK"></a>通过Cocoapods导入Admob SDK</h1><p>通过Cocoapods导入SDK是最简单的方法，如果不知道Cocoapods的使用方法可以看一下<a href="https://cocoapods.org/">官方文档</a>。在Podfile中添加一行代码：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">pod &#39;Google-Mobile-Ads-SDK&#39;</span><br></pre></td></tr></table></figure><p>之后在终端执行命令行：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">pod install --repo-update</span><br></pre></td></tr></table></figure><h1 id="修改主工程的info-plist文件"><a href="#修改主工程的info-plist文件" class="headerlink" title="修改主工程的info.plist文件"></a>修改主工程的info.plist文件</h1><p>在主工程的info.plist文件中添加两个键值对：</p><ol><li><code>GADApplicationIdentifier</code>对应的是你的app在Admob申请到的App ID。</li><li><code>SKAdNetworkItems</code>对应的是一个固定的<code>cstr6suwn9.skadnetwork</code>。</li></ol><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">&lt;key&gt;GADApplicationIdentifier&lt;&#x2F;key&gt;</span><br><span class="line">&lt;string&gt;ca-app-pub-3940256099942544~1458002511&lt;&#x2F;string&gt;</span><br><span class="line">&lt;key&gt;SKAdNetworkItems&lt;&#x2F;key&gt;</span><br><span class="line">  &lt;array&gt;</span><br><span class="line">    &lt;dict&gt;</span><br><span class="line">      &lt;key&gt;SKAdNetworkIdentifier&lt;&#x2F;key&gt;</span><br><span class="line">      &lt;string&gt;cstr6suwn9.skadnetwork&lt;&#x2F;string&gt;</span><br><span class="line">    &lt;&#x2F;dict&gt;</span><br><span class="line">  &lt;&#x2F;array&gt;</span><br></pre></td></tr></table></figure><p>添加之后的info.plist效果：<br><img src="../../images/admob/quick_start_skadnetwork.png" alt="info.plist添加Admob"></p><p>关于注册Admob账号和获取App ID的内容可以到<a href="https://apps.admob.com/v2/home">Admob的官方网站</a>查看。</p><h1 id="初始化Admob-SDK"><a href="#初始化Admob-SDK" class="headerlink" title="初始化Admob SDK"></a>初始化Admob SDK</h1><p>在<code>AppDelegate</code>中添加初始化Admob SDK的代码</p><div class="tabs" id="initialize-admob-sdk"><ul class="nav-tabs"><li class="tab active"><a href="#initialize-admob-sdk-1">Objective-C</a></li><li class="tab"><a href="#initialize-admob-sdk-2">Swift</a></li></ul><div class="tab-content"><div class="tab-pane active" id="initialize-admob-sdk-1"><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">@import</span> GoogleMobileAds;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">@implementation</span> <span class="title">AppDelegate</span></span></span><br><span class="line"></span><br><span class="line">- (<span class="built_in">BOOL</span>)application:(<span class="built_in">UIApplication</span> *)application</span><br><span class="line">    didFinishLaunchingWithOptions:(<span class="built_in">NSDictionary</span> *)launchOptions &#123;</span><br><span class="line"></span><br><span class="line">  [[GADMobileAds sharedInstance] startWithCompletionHandler:<span class="literal">nil</span>];</span><br><span class="line">  <span class="keyword">return</span> <span class="literal">YES</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">@end</span></span><br></pre></td></tr></table></figure></div><div class="tab-pane" id="initialize-admob-sdk-2"><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> GoogleMobileAds</span><br><span class="line"></span><br><span class="line"><span class="keyword">@UIApplicationMain</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">AppDelegate</span>: <span class="title">UIResponde</span>, <span class="title">UIApplicationDelegate</span> </span>&#123;</span><br><span class="line">  <span class="function"><span class="keyword">func</span> <span class="title">application</span><span class="params">(<span class="keyword">_</span> application: UIApplication,</span></span></span><br><span class="line"><span class="function"><span class="params">      didFinishLaunchingWithOptions launchOptions: [UIApplicationLaunchOptionsKey: <span class="keyword">Any</span>]?)</span></span> -&gt; <span class="type">Bool</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="type">GADMobileAds</span>.sharedInstance().start(completionHandler: <span class="literal">nil</span>)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div></div></div><p>到这里，我们就可以根据需要来在App的不同位置添加需要的广告类型了。</p><p>因为类型比较多，这里如果分别介绍的话篇幅就太长了。所以在这篇文章只说一下需要注意的地方，详细的集成方法可以到<a href="https://developers.google.com/admob/ios/quick-start">Admob开发官网</a>查看。</p><h1 id="各种Admob广告类型的最佳实践方案"><a href="#各种Admob广告类型的最佳实践方案" class="headerlink" title="各种Admob广告类型的最佳实践方案"></a>各种Admob广告类型的最佳实践方案</h1><p>不同类型的Admob广告适用于不同的场景，按照场景放广告不仅更能被用户接受，而且对广告营收有一定的益处。相反，如果不按照推荐方法来展示广告有可能会被广告商警告，严重的话可能会被禁止投放（我们就被Facebook警告了）。</p><ol><li>Banner广告是那种长条状的横幅形式，建议放在屏幕的边缘处，对于手机屏幕建议放在屏幕的最上面或者最下面。</li><li>插屏广告是一种全屏展示的广告，可能是一张图片或者一个视频，只有用户点击关闭按钮是才会关闭。这种广告对用户打扰非常大，建议放在界面切换的时候才展示这种广告，<strong>并且不能在push到一个新页面以后再展示</strong>，比如说不能在到一个新页面后网络请求服务端的过程中展示这个广告。</li><li>Native广告（原生广告）是一种比较特殊的广告形式，它通过SDK来实现广告加载，加载到的是广告的一些组件（文字、图片、视频），我们可以自定义组件的展示位置和大小。<strong>这种广告适合用在启动图或者列表（UITableView/UICollectionView）中。</strong></li><li>激励视频广告是一种可以让用户通过观看广告获取App内奖励的广告形式，在游戏类App中十分常见。在弹出这种广告前一定要让用户选择是否要通过看广告获取“更多奖励”。</li></ol><h1 id="使用Admob中介组聚合多个平台广告"><a href="#使用Admob中介组聚合多个平台广告" class="headerlink" title="使用Admob中介组聚合多个平台广告"></a>使用Admob中介组聚合多个平台广告</h1><p>谷歌广告平台不仅有自家的Admob广告还有很多其他广告平台的资源，我们在集成了<code>Google-Mobile-Ads-SDK</code>的基础上通过添加不同平台的中介组（Mediation）来快速获取不同平台的广告。</p><p>在这里我们仅以集成Facebook的广告为例做一下说明，其他平台的广告也都大同小异。如果在集成过程中有什么问题也可以到公众号“iOS开发栈”问我。</p><p>在<code>Podfile</code>文件中添加Admob SDK和Facebook的中介组：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">pod &#39;Google-Mobile-Ads-SDK&#39;,</span><br><span class="line">pod &#39;GoogleMobileAdsMediationFacebook&#39;</span><br></pre></td></tr></table></figure><p>之后在终端切换到项目所在目录，并执行</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">cd &lt;当前项目目录&gt;</span><br><span class="line">pod install --repo-update</span><br></pre></td></tr></table></figure><p>安装完Admob SDk和FB的广告中介组以后，就可以直接使用对应的广告形式了。对应广告形式的使用方式可以到上一节查看，这里不再赘述。</p><p>这里有一点需要强调的是在初始化不同的广告形式需要调用<code>initWithAdUnitID:</code>方法，这里的<em>UnitID</em>是广告但愿ID，可以在Admob的管理后台-&gt;广告单元页面查看。</p><p><img src="../../images/admob/UnitId.png" alt="Admob UnitID"></p><div class="note info"><p>到公众号【iOS开发栈】学习更多SwiftUI、iOS开发相关内容。回复“博客”免费获取各大互联网公司面试题。</p></div><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>谷歌的Admob服务和其他广告商相比文档更加全面（不过文档中也可能有错误），社区也非常活跃（我曾经提过一个问题，很快可以得到回复）。这篇文章是我在使用过程中的一些总结，里面除了基础的集成方法外，大都是使用过程中的注意事项，至于详细的集成过程推荐到<a href="https://developers.google.com/admob/ios/quick-start">官方文档</a>中查看。如果你有任何的问题、建议都可以通过<a href="https://weibo.com/7414691003/profile">微博</a>或<a href="mailto:shizhiang@126.com">邮件</a>联系到我本人。</p>]]></content>
    
    
    <summary type="html">&lt;p&gt;Admob是谷歌推出的广告服务，其中包含的广告类型有：banner、插屏、激励、开屏（最近添加的）。利用Admob的中介组可以引入其他广告商的广告，比如FaceBook、unity等10多家平台。对于出海的App集成Admob是非常必要的变现手段。&lt;/p&gt;</summary>
    
    
    
    
    <category term="iOS" scheme="http://www.iosprogrammer.tech/tags/iOS/"/>
    
  </entry>
  
  <entry>
    <title>详解SwiftUI数据流是怎么在View间传递的</title>
    <link href="http://www.iosprogrammer.tech/swiftui/swiftui-data-flow/"/>
    <id>http://www.iosprogrammer.tech/swiftui/swiftui-data-flow/</id>
    <published>2021-02-02T06:35:42.234Z</published>
    <updated>2021-02-25T06:53:41.437Z</updated>
    
    <content type="html"><![CDATA[<p>作为一个声明式的UI框架，SwiftUI帮我们处理了几乎所有关于UI和数据之间的交互，这使我们不再需要关注数据变化时刷新UI和用户交互以后更新数据的逻辑。</p><p>为了实现数据和UI的绑定，我们需要利用Swift的一些关属性包装器来向SwiftUI描述它们之间的关系，那么让我们开始吧。</p><a id="more"></a><div class="note info"><p>到公众号【iOS开发栈】学习更多SwiftUI、iOS开发相关内容。</p></div><p><img src="../../image/../images/first/SwiftUI-Data-Flow.jpg"></p><h1 id="State-Properties-State"><a href="#State-Properties-State" class="headerlink" title="State Properties @State"></a>State Properties @State</h1><p>在<a href="https://www.iosprogrammer.tech/swiftui/what-is-the-different-between-foreach-and-list">前面的一篇文章</a>中当我们给数组添加或者删除元素时，<a href="https://www.iosprogrammer.tech/swiftui/swiftui-concept-essential.md">列表</a>会自动响应变化，正是因为使用了<code>@State</code>来标记View中的model。</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">ContentView</span>: <span class="title">View</span> </span>&#123;</span><br><span class="line">    <span class="meta">@State</span> <span class="keyword">private</span> <span class="keyword">var</span> title: <span class="type">String</span> <span class="operator">=</span> <span class="string">&quot;&quot;</span></span><br><span class="line">    <span class="keyword">var</span> body: <span class="keyword">some</span> <span class="type">View</span> &#123;</span><br><span class="line">        <span class="type">VStack</span> &#123;</span><br><span class="line">            <span class="type">Text</span>(<span class="string">&quot;<span class="subst">\(title)</span>&quot;</span>)</span><br><span class="line">            <span class="type">TextField</span>(<span class="string">&quot;Please Enter Title&quot;</span>, text: <span class="variable">$title</span>)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>使用<code>@State</code>包装的变量是可以被SwiftUI读取的值，这些值通常是一些字符串或数字等常量值。</p><p>当被State包装的属性改变时，SwiftUI会重新计算和绘制使用到该属性的视图所在的整个视图层级，通常是说变量所在View的Body会被重新绘制，在本例子中就是指<code>ContentView</code>的body。</p><blockquote><p>被<code>@State</code>包装的变量一定要用<code>private</code>修饰，并且这个变量只能在当前view以及其子View的body中使用。</p></blockquote><p>正如TextField中的<code>$title</code>一样，我们可以通过*$*前缀把变量和另一个view绑定起来，这样就可以在另一个view中对这个变量进行修改了。下面的代码使用一个Toggle来控制Wi-Fi的开关：</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">ContentView</span>: <span class="title">View</span> </span>&#123;</span><br><span class="line">    <span class="meta">@State</span> <span class="keyword">private</span> <span class="keyword">var</span> isOn <span class="operator">=</span> <span class="literal">false</span></span><br><span class="line">    <span class="keyword">var</span> body: <span class="keyword">some</span> <span class="type">View</span> &#123;</span><br><span class="line">        <span class="type">VStack</span> &#123;</span><br><span class="line">            <span class="type">Text</span>(<span class="string">&quot;Wi-Fi State: <span class="subst">\(isOn <span class="operator">?</span> <span class="string">&quot;On&quot;</span> : <span class="string">&quot;Off&quot;</span>)</span>&quot;</span>)</span><br><span class="line">            <span class="type">Image</span>(systemName: <span class="string">&quot;<span class="subst">\(isOn <span class="operator">?</span> <span class="string">&quot;wifi&quot;</span> : <span class="string">&quot;wifi.slash&quot;</span>)</span>&quot;</span>)</span><br><span class="line">            <span class="type">Toggle</span>(<span class="string">&quot;Wi-Fi State&quot;</span>, isOn: <span class="variable">$isOn</span>)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>正如上面的代码所示，我们在<code>isOn</code>属性和Toggle控件之间建立了一个绑定。Toggle可以修改isOn的值，另外当isOn改变的时候，Text和Image的内容都会发生变化。</p><h1 id="State-Binding-状态绑定"><a href="#State-Binding-状态绑定" class="headerlink" title="State Binding 状态绑定"></a>State Binding 状态绑定</h1><p>使用@state包装的属性只在它所属view的内部使用，那么当它的子视图要访问这个属性的时候就要用到<code>@binding</code>了。就像上面例子用到的<code>Toggle</code>，我们把Text和Image放到一个自定义的View中。</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">WiFiView</span>: <span class="title">View</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Binding</span> <span class="keyword">var</span> isOn: <span class="type">Bool</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">var</span> body: <span class="keyword">some</span> <span class="type">View</span> &#123;</span><br><span class="line">        <span class="type">Text</span>(<span class="string">&quot;Wi-Fi State: <span class="subst">\(isOn <span class="operator">?</span> <span class="string">&quot;On&quot;</span> : <span class="string">&quot;Off&quot;</span>)</span>&quot;</span>)</span><br><span class="line">        <span class="type">Image</span>(systemName: <span class="string">&quot;<span class="subst">\(isOn <span class="operator">?</span> <span class="string">&quot;wifi&quot;</span> : <span class="string">&quot;wifi.slash&quot;</span>)</span>&quot;</span>)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在这里我们使用了<code>@Binding</code>来创建数据和界面之间的依赖，它和<code>@State</code>不同的地方在于，binding的属性并不被当前的视图所持有，并且binding的值是可以被state的属性值导出的。</p><p>在这里如果把@Binding换成@State就会使WiFiView和它的父视图分别拥有各自的isOn属性，其中一个修改不会影响到另一个，而这显然不是我们想要的结果。</p><h1 id="使用Combine框架的Publisher"><a href="#使用Combine框架的Publisher" class="headerlink" title="使用Combine框架的Publisher"></a>使用<em>Combine</em>框架的<em>Publisher</em></h1><p>使用@State包装的属性只能在当前View内部或者它的子视图中使用，并且state属性时临时的——由于state包装的属性是隶属于它所在view的，当view被销毁时对应的state属性也会消失，这明显是不够的，另外我们在开发过程中还要处理一些非界面的信息，比如说<em>Timer</em>、<em>Notification</em>等，它们携带的信息通常也会有更新界面的需求。这种情况就要用到Combine中的Publisher了。</p><p><em>Combine</em>是在iOS13中被引入的，主要目的是为了处理App中的各种事件消息。如果你之前接触过<em>RxSwift</em>或者<em>ReactiveCocoa</em>那你对这个概念应该很容易理解，它的原理就是发布者和订阅者的模式。</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Contact</span>: <span class="title">ObservableObject</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Published</span> <span class="keyword">var</span> name: <span class="type">String</span></span><br><span class="line">    <span class="meta">@Published</span> <span class="keyword">var</span> age: <span class="type">Int</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">init</span>(name: <span class="type">String</span>, age: <span class="type">Int</span>) &#123;</span><br><span class="line">        <span class="keyword">self</span>.name <span class="operator">=</span> name</span><br><span class="line">        <span class="keyword">self</span>.age <span class="operator">=</span> age</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">ContentView</span>: <span class="title">View</span> </span>&#123;</span><br><span class="line">    <span class="meta">@ObservedObject</span> <span class="keyword">var</span> xiaowang <span class="operator">=</span> <span class="type">Contact</span>(name: <span class="string">&quot;xiaowang&quot;</span>, age: <span class="number">21</span>)</span><br><span class="line">    <span class="keyword">var</span> body: <span class="keyword">some</span> <span class="type">View</span> &#123;</span><br><span class="line">        <span class="type">VStack</span> &#123;</span><br><span class="line">            <span class="type">Text</span>(<span class="string">&quot;小王：<span class="subst">\(xiaowang.name)</span>&quot;</span>)</span><br><span class="line">            </span><br><span class="line">            <span class="comment">// 这里只是一个例子，通常不会在这里对Publisher进行修改</span></span><br><span class="line">            <span class="type">Button</span>(<span class="string">&quot;修改联系人&quot;</span>) &#123;</span><br><span class="line">                xiaowang.name <span class="operator">=</span> <span class="string">&quot;小王&quot;</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>我们先创建一个遵守<em>ObservableObject</em>协议的联系人类，然后在SwiftUI视图中添加一个被<em>ObservedObject</em>包装的变量，在body中使用这个变量，当被<em><em>@Published</em></em>包装的变量改变时，body会使用新值重新加载。</p><blockquote><p>如果你在看WWDC2019的<a href="https://developer.apple.com/wwdc19/226">Introducing Combile</a>视频的时候发现<em>BindableObject</em>/<em>didChange.send()</em>/<em>onReceive</em>，这些内容现在已经被<a href="https://developer.apple.com/forums/thread/127243">移除了</a>。</p></blockquote><blockquote><p>只有class可以遵守ObservableObject协议，否则会报错 <mark class="label danger">Non-class type Contact cannot conform to class protocol ObservableObject</mark></p></blockquote><p>在iOS14中，引入了一个新的<em><em>@StateObject</em></em>来丰富这种使用场景。它和ObservedObject的区别在于当view刷新时被ObservedObject包装的属性会重置到初始值，而被StateObject使用的不会。</p><blockquote><p>除非在某些必要的情况下需要使用ObservedObject之外，大多数情况都适用于StateObject。</p></blockquote><h1 id="环境变量-Evironment-Objects"><a href="#环境变量-Evironment-Objects" class="headerlink" title="环境变量 Evironment Objects"></a>环境变量 Evironment Objects</h1><p>除了以上列出的几个场景之外，假设我们的app需要从一个页面跳转到另一个页面，这是一个很常见的场景，并且在后一个页面要用到前面页面的一些属性。通常可以这样做：</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">NavigationLink</span>(destination: nextView(aModel: aModel)) &#123;</span><br><span class="line">    <span class="type">Text</span>(<span class="string">&quot;Detail&quot;</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上面用到了<strong><em>NavigationLink</em></strong>来做导航，destination是要弹出的页面，初始化时带着当前页面的一个属性。</p><p>这样处理没有什么大的问题，不过如果层级变多，后面层级又出现很多新层级，再有反向传值的话就会很复杂容易出错——就像使用UIKit的时候。而为了解决这个问题，SwiftUI引入了<strong><em>Evironment Objects</em></strong>。</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// DataSource.swift</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">DataSource</span>: <span class="title">ObservableObject</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Published</span> <span class="keyword">var</span> counter <span class="operator">=</span> <span class="number">0</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// ContentView.swift</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">ContentView</span>: <span class="title">View</span> </span>&#123;</span><br><span class="line">    <span class="keyword">let</span> dataSource <span class="operator">=</span> <span class="type">DataSource</span>()</span><br><span class="line">    <span class="keyword">var</span> body: <span class="keyword">some</span> <span class="type">View</span> &#123;</span><br><span class="line">        <span class="type">NavigationView</span> &#123;</span><br><span class="line">            <span class="type">VStack</span> &#123;</span><br><span class="line">                <span class="type">Button</span>(<span class="string">&quot;Click&quot;</span>) &#123;</span><br><span class="line">                    dataSource.counter <span class="operator">+=</span> <span class="number">1</span></span><br><span class="line">                &#125;</span><br><span class="line">                <span class="type">NavigationLink</span>(</span><br><span class="line">                    destination: <span class="type">ContactView</span>()) &#123;</span><br><span class="line">                    <span class="type">Text</span>(<span class="string">&quot;Enter Next Page&quot;</span>)</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        .environmentObject(dataSource)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// ContactView.swift</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">ContactView</span>: <span class="title">View</span> </span>&#123;</span><br><span class="line">    <span class="meta">@EnvironmentObject</span> <span class="keyword">var</span> dataSource: <span class="type">DataSource</span></span><br><span class="line">    <span class="keyword">var</span> body: <span class="keyword">some</span> <span class="type">View</span> &#123;</span><br><span class="line">        <span class="type">Text</span>(<span class="string">&quot;<span class="subst">\(dataSource.counter)</span>&quot;</span>)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Environment Object和ObservedObject/StateObject用法非常相似，首先DataSource遵守ObservableObject协议，要观察的属性counter使用Publisher包装。</p><p>被<em><em>@EnvironmentObject</em></em>包装的属性会随着Publised属性的改变而变化，所在的view也会重新加载。</p><p><em>.environmentObject</em>是一个<a href="https://www.iosprogrammer.tech/swiftui-concept-essential">Modifier</a>，它向环境变量中注入一个属性，如果不在使用@EnvironmentObject之前使用把属性注入到环境变量中，就会包错 <mark class="label danger">MissingEnvironmentObjectError: Missing EnvironmentObject</mark></p><div class="note info"><p>到公众号【iOS开发栈】回复“博客”免费获取各大互联网公司面试题。</p></div><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>在这篇文章中我们学习了SwiftUI框架中数据的流动相关知识，其中主要涉及了几个常用的属性包装器（property wrapper）：@State @Binding @ObservedObject @StateObject @EnvironmentObject用法和适用场景，希望对你所有帮助。如果你有任何的问题、建议都可以通过<a href="https://weibo.com/7414691003/profile">微博</a>或<a href="mailto:shizhiang@126.com">邮件</a>联系到我本人。</p>]]></content>
    
    
    <summary type="html">&lt;p&gt;作为一个声明式的UI框架，SwiftUI帮我们处理了几乎所有关于UI和数据之间的交互，这使我们不再需要关注数据变化时刷新UI和用户交互以后更新数据的逻辑。&lt;/p&gt;
&lt;p&gt;为了实现数据和UI的绑定，我们需要利用Swift的一些关属性包装器来向SwiftUI描述它们之间的关系，那么让我们开始吧。&lt;/p&gt;</summary>
    
    
    
    
    <category term="SwiftUI" scheme="http://www.iosprogrammer.tech/tags/SwiftUI/"/>
    
  </entry>
  
  <entry>
    <title>一文解决UIKeyboard的疑难杂症</title>
    <link href="http://www.iosprogrammer.tech/UIScrollView-Keyboard/"/>
    <id>http://www.iosprogrammer.tech/UIScrollView-Keyboard/</id>
    <published>2021-01-30T02:58:39.000Z</published>
    <updated>2021-02-25T06:53:41.437Z</updated>
    
    <content type="html"><![CDATA[<p>我们在iOS的开发过程中，经常要在包含UIScrollView的view中监听键盘的通知，有时候会出现一些bug，比方说<code>UIKeyboardWillShowNotification</code>可能会调用多次。</p><p>通过这篇文章我们来讨论几个经常出现的问题，并且了解一下对应的解决方案。</p><a id="more"></a><div class="note info"><p>到公众号【iOS开发栈】学习更多SwiftUI、iOS开发相关内容。回复“博客”免费获取各大互联网公司面试题。</p></div><p><img src="../../images/first/UIkeyBoard.jpg" alt="UIkeyboard的bugs"></p><h1 id="UIScrollView退出键盘"><a href="#UIScrollView退出键盘" class="headerlink" title="UIScrollView退出键盘"></a>UIScrollView退出键盘</h1><p>拖动UIScrollView退出键盘的方法：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">typedef NS_ENUM(NSInteger, UIScrollViewKeyboardDismissMode) &#123;</span><br><span class="line">    UIScrollViewKeyboardDismissModeNone,</span><br><span class="line">    UIScrollViewKeyboardDismissModeOnDrag,      &#x2F;&#x2F; dismisses the keyboard when a drag begins</span><br><span class="line">    UIScrollViewKeyboardDismissModeInteractive, &#x2F;&#x2F; the keyboard follows the dragging touch off screen, and may be pulled upward again to cancel the dismiss</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">@property(nonatomic) UIScrollViewKeyboardDismissMode keyboardDismissMode &#x2F;&#x2F; 默认是None，UIScrollView和Keyboar不会有任何交互效果</span><br></pre></td></tr></table></figure><ul><li><code>UIScrollViewKeyboardDismissModeOnDrag</code> 当开始拖动时，keyboard会退出屏幕。在iOS14的模拟器上动画有点不流畅。</li><li><code>UIScrollViewKeyboardDismissModeInteractive</code> <strong>当拖动手势进入键盘区域时</strong>，键盘会跟随拖动上升或者下降。</li></ul><h1 id="UIKeyboardWillShowNotification多次重复通知"><a href="#UIKeyboardWillShowNotification多次重复通知" class="headerlink" title="UIKeyboardWillShowNotification多次重复通知"></a><code>UIKeyboardWillShowNotification</code>多次重复通知</h1><p>多个TextField或者TextView之间切换时，<code>UIKeyboardWillShowNotification</code>、<code>UIKeyboardWillChangeFrameNotification</code>每次都会调用（但是<code>UIKeyboardWillHideNotification</code>却不会调用），当你使用上面提到的<code>UIScrollViewKeyboardDismissModeInteractive</code>时，通知甚至会在一个动画过程中频繁调用。</p><p>我们在处理一些业务逻辑的时候需要谨记这个特点，不要寄希望于只会调用一次。比方说要在<code>UIKeyboardWillShowNotification</code>的回调中把某个视图上移。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line">[[NSNotificationCenter defaultCenter] addObserver:self selector:@selector(willShow:) name:UIKeyboardWillShowNotification object:nil]; &#x2F;&#x2F; 订阅通知</span><br><span class="line"></span><br><span class="line">❌</span><br><span class="line">- (void)willShow:(NSNotification *)noti &#123;</span><br><span class="line">    NSLog(@&quot;willShow&quot;);</span><br><span class="line">    CGRect keyboarFrame &#x3D; [noti.userInfo[UIKeyboardFrameBeginUserInfoKey] CGRectValue];</span><br><span class="line">    CGRect bottomViewFrame &#x3D; _bottomView.frame;</span><br><span class="line">    bottomViewFrame.origin.y -&#x3D; keyboarFrame.size.height;</span><br><span class="line">    _bottomView.frame &#x3D; bottomViewFrame;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">✅</span><br><span class="line">&#x2F;&#x2F; 使用固定高度的方法</span><br><span class="line">- (void)willShow:(NSNotification *)noti &#123;</span><br><span class="line">    NSLog(@&quot;willShow&quot;);</span><br><span class="line">    CGRect keyboarFrame &#x3D; [noti.userInfo[UIKeyboardFrameEndUserInfoKey] CGRectValue];</span><br><span class="line">    CGRect bottomViewFrame &#x3D; _bottomView.frame;</span><br><span class="line">    bottomViewFrame.origin.y &#x3D; self.view.bounds.size.height - keyboarFrame.size.height - _bottomView.bounds.size.height;</span><br><span class="line">    _bottomView.frame &#x3D; bottomViewFrame;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">✅</span><br><span class="line">&#x2F;&#x2F; 使用全局变量的方法</span><br><span class="line">[[NSNotificationCenter defaultCenter] addObserver:self selector:@selector(didHide:) name:UIKeyboardDidHideNotification object:nil]; &#x2F;&#x2F; 订阅键盘消失的通知</span><br><span class="line"></span><br><span class="line">static BOOL keyboarShow &#x3D; NO;</span><br><span class="line"></span><br><span class="line">- (void)willShow:(NSNotification *)noti &#123;</span><br><span class="line">    NSLog(@&quot;willShow&quot;);</span><br><span class="line">    if (keyboarShow &#x3D;&#x3D; YES) &#123;</span><br><span class="line">        return;</span><br><span class="line">    &#125;</span><br><span class="line">    keyboarShow &#x3D; YES;</span><br><span class="line">    CGRect keyboarFrame &#x3D; [noti.userInfo[UIKeyboardFrameEndUserInfoKey] CGRectValue];</span><br><span class="line">    CGRect bottomViewFrame &#x3D; _bottomView.frame;</span><br><span class="line">    bottomViewFrame.origin.y &#x3D; self.view.bounds.size.height - keyboarFrame.size.height - _bottomView.bounds.size.height;</span><br><span class="line">    _bottomView.frame &#x3D; bottomViewFrame;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (void)didHide:(NSNotification *)noti &#123;</span><br><span class="line">    NSLog(@&quot;didHide&quot;);</span><br><span class="line">    keyboarShow &#x3D; NO;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h1 id="点击UIScrollView触发UIKeyboardWillShowNotification通知"><a href="#点击UIScrollView触发UIKeyboardWillShowNotification通知" class="headerlink" title="点击UIScrollView触发UIKeyboardWillShowNotification通知"></a>点击UIScrollView触发<code>UIKeyboardWillShowNotification</code>通知</h1><p>点击TextFiled或者TextView后，再点击UIScrollView，<code>UIKeyboardWillShowNotification</code>的回调会被触发，我不能确定造成这个现象的原因是什么，不过猜测是因为iOS的事件管理系统的内部bug导致的。解决这个问题的终极方法和我们上面⬆️用的方法是一样的。</p><div class="note info"><p>到公众号【iOS开发栈】学习更多SwiftUI、iOS开发相关内容。回复“博客”免费获取各大互联网公司面试题。</p></div><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>通过这篇文章我们讨论了在使用<code>UIScrollView</code>的时候会出现的一些关于键盘的问题，并且给出了具体的解决方案，以及用到了UIKeybaord的一些通知，希望对你有所帮助。</p><p>如果你有任何的问题、建议都可以通过<a href="https://weibo.com/7414691003/profile">微博</a>或<a href="mailto:shizhiang@126.com">邮件</a>联系到我本人。</p>]]></content>
    
    
    <summary type="html">&lt;p&gt;我们在iOS的开发过程中，经常要在包含UIScrollView的view中监听键盘的通知，有时候会出现一些bug，比方说&lt;code&gt;UIKeyboardWillShowNotification&lt;/code&gt;可能会调用多次。&lt;/p&gt;
&lt;p&gt;通过这篇文章我们来讨论几个经常出现的问题，并且了解一下对应的解决方案。&lt;/p&gt;</summary>
    
    
    
    
    <category term="iOS" scheme="http://www.iosprogrammer.tech/tags/iOS/"/>
    
  </entry>
  
</feed>

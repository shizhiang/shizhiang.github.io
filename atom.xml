<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>iOS开发栈 - 专注于分享iOS开发相关知识</title>
  
  <subtitle>关注公众号【iOS开发栈】及时免费获取更多iOS开发知识</subtitle>
  <link href="http://www.iosprogrammer.tech/atom.xml" rel="self"/>
  
  <link href="http://www.iosprogrammer.tech/"/>
  <updated>2021-07-11T08:57:40.103Z</updated>
  <id>http://www.iosprogrammer.tech/</id>
  
  <author>
    <name>施治昂</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>掌握KeyPaths的用法（从理论到实践），极大提高Swift开发效率</title>
    <link href="http://www.iosprogrammer.tech/swift/swift-keypaths/"/>
    <id>http://www.iosprogrammer.tech/swift/swift-keypaths/</id>
    <published>2021-07-05T11:30:17.000Z</published>
    <updated>2021-07-11T08:57:40.103Z</updated>
    
    <content type="html"><![CDATA[<p>作为一门非常强调类型安全的语言，为了让程序员尽量少犯错误，Swift在编译时会进行尽量多的类型检查，因此在设计之初就决定了Swift不能像其他某些语言（比如Objective-C）一样具有很强的动态特性。这篇文章要说的<code>KeyPath</code>就是为了类型安全而生的特性之一。</p><p>下面主要包括这几个方面的内容：</p><ol><li>Keypath是什么</li><li>KeyPath的作用，也就是为什么要使用Keypath</li><li>KeyPath的使用示例</li></ol><a id="more"></a><p><img src="../images/first/swift-keypath.png"></p><div class="note info"><p>到公众号【iOS开发栈】学习更多Swift、SwiftUI、iOS开发相关内容。</p></div><h1 id="KeyPath是什么"><a href="#KeyPath是什么" class="headerlink" title="KeyPath是什么"></a>KeyPath是什么</h1><p>首先来看<code>KeyPath</code>的定义：</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">KeyPath</span>&lt;<span class="title">Root</span>, <span class="title">Value</span>&gt;</span></span><br></pre></td></tr></table></figure><p>根据这个定义可以得知<code>KeyPath</code>实际是一个类，也就是说当我们看到某个函数参数声明类似<code>func test(param: KeyPath&lt;Any, Any&gt;)</code>时，其实只是说<code>param</code>参数是<code>KeyPath</code>类型的。</p><p>具体来说，<code>KeyPath</code>类型是一个包含两个范型的类型，这两个范型可能用在类的变量里，也可能用在方法的参数里，至于这两个范型具体是怎么使用的我们由于看不到源码就不得而知了。</p><blockquote><p>A key path from a specific root type to a specific resulting value type.</p></blockquote><p>这是Apple官方文档给的定义，key path从根类型到结果值类型。</p><p>单从这个定义理解是挺晦涩的，下面让我们理解一下它的意思。</p><h1 id="KeyPath的作用"><a href="#KeyPath的作用" class="headerlink" title="KeyPath的作用"></a>KeyPath的作用</h1><p>让我们写一个公众号的类并且创建iOS开发栈的实例：</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">OfficialAccount</span> </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> name: <span class="type">String</span></span><br><span class="line">    <span class="keyword">var</span> fans: <span class="type">Int</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> iosDev <span class="operator">=</span> <span class="type">OfficialAccount</span>(name: <span class="string">&quot;ios开发栈&quot;</span>, fans: <span class="number">500</span>)</span><br></pre></td></tr></table></figure><p>上面新建了一个名为<code>OfficialAccount</code>的公众号类，并创建了一个<code>iosDev</code>的实例。</p><p>如果我要获取iosDev有多少个粉丝，第一种方法是通过<code>iosDev.fans</code>，除此之外还可以用KeyPath来获取属性值：</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">iosDev[keyPath: \<span class="type">OfficialAccount</span>.fans]</span><br></pre></td></tr></table></figure><p>熟悉OC的同学应该对这个用法很熟悉，在OC中是这样使用的：<code>[iosDev valueForKey:@&quot;fans&quot;]</code>，如果经常这样用肯定也遇到过这个用法导致的程序崩溃<mark class="label danger">[<OfficialAccount 0x6000014d0260> valueForUndefinedKey:]: this class is not key value coding-compliant for the key fans1</mark>。</p><p>没错Swift中的KeyPath正是为了解决OC这个问题的，正因为有了KeyPath，在Swift中就不需要使用一个字符串来直接访问一个对象，也就避免了UndefinedKey问题。</p><p>另外，<code>KeyPath</code>也支持链式调用：</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Person</span> </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> nickName: <span class="type">String</span></span><br><span class="line">    <span class="keyword">var</span> age: <span class="type">Int</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">OfficialAccount</span> </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> name: <span class="type">String</span></span><br><span class="line">    <span class="keyword">var</span> fans: <span class="type">Int</span></span><br><span class="line">    <span class="keyword">var</span> owner: <span class="type">Person</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> sza <span class="operator">=</span> <span class="type">Person</span>(nickName: <span class="string">&quot;施治昂&quot;</span>, age: <span class="number">30</span>)</span><br><span class="line"><span class="keyword">var</span> iosDev <span class="operator">=</span> <span class="type">OfficialAccount</span>(name: <span class="string">&quot;ios开发栈&quot;</span>, fans: <span class="number">500</span>, owner: sza)</span><br><span class="line">iosDev[keyPath: \.owner.nickName]</span><br></pre></td></tr></table></figure><p>新建一个<code>Person</code>类，它拥有姓名、年龄两个属性，公众号类增加<code>owner</code>拥有者属性。新建<code>Person</code>类示例sza作为iosDev公众号的拥有者。</p><p>之后就可以通过<code>iosDev[keyPath: \.owner.nickName]</code>来获取公众号拥有者的名字了，结果是施治昂。</p><h1 id="KeyPath实践"><a href="#KeyPath实践" class="headerlink" title="KeyPath实践"></a>KeyPath实践</h1><p>Swift库提供了数组的排序方法<code>sorted</code>，比如:</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> arr <span class="operator">=</span> [<span class="number">3</span>, <span class="number">6</span>, <span class="number">5</span>, <span class="number">1</span>]</span><br><span class="line"><span class="keyword">let</span> sortedArr <span class="operator">=</span> arr.sorted(by: <span class="operator">&gt;</span>)</span><br><span class="line"><span class="built_in">print</span>(sortedArr) <span class="comment">// [6, 5, 3, 1]</span></span><br></pre></td></tr></table></figure><p>有了这个方法确实给开发者提供了很大的便利，但是如果要对<code>OfficialAccount</code>的数组排序这个方法就无能为力了。</p><p>下面我们利用<code>KeyPath</code>给数组<code>Array</code>增加一个方法，来给<code>OfficialAccount</code>类型的数组排序：</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">extension</span> <span class="title">Array</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">func</span> <span class="title">sorted</span>&lt;Value&gt;<span class="params">(keyPath: KeyPath&lt;Element, Value&gt;, by areInIncreasingOrder: <span class="params">(Value, Value)</span></span></span> <span class="keyword">throws</span> -&gt; <span class="type">Bool</span>) <span class="keyword">rethrows</span> -&gt; [<span class="type">Element</span>] &#123;</span><br><span class="line">        <span class="keyword">try</span> sorted &#123;</span><br><span class="line">            <span class="keyword">try</span> areInIncreasingOrder(<span class="variable">$0</span>[keyPath: keyPath] , <span class="variable">$1</span>[keyPath: keyPath])</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> sza <span class="operator">=</span> <span class="type">Person</span>(nickName: <span class="string">&quot;施治昂&quot;</span>, age: <span class="number">30</span>)</span><br><span class="line"><span class="keyword">var</span> iosDev <span class="operator">=</span> <span class="type">OfficialAccount</span>(name: <span class="string">&quot;ios开发栈&quot;</span>, fans: <span class="number">500</span>, owner: sza)</span><br><span class="line"><span class="keyword">var</span> iosDev2 <span class="operator">=</span> <span class="type">OfficialAccount</span>(name: <span class="string">&quot;ios开发栈2&quot;</span>, fans: <span class="number">30</span>, owner: sza)</span><br><span class="line"><span class="keyword">let</span> sorted <span class="operator">=</span> [iosDev, iosDev2].sorted(keyPath: \.fans, by: <span class="operator">&gt;</span>)</span><br><span class="line"><span class="built_in">print</span>(sorted) <span class="comment">// [__lldb_expr_32.OfficialAccount(name: &quot;ios开发栈&quot;, fans: 500, owner: __lldb_expr_32.Person(nickName: &quot;施治昂&quot;, age: 30)), __lldb_expr_32.OfficialAccount(name: &quot;ios开发栈2&quot;, fans: 30, owner: __lldb_expr_32.Person(nickName: &quot;施治昂&quot;, age: 30))]</span></span><br></pre></td></tr></table></figure><p>利用扩展给<code>Array</code>增加一个<code>sorted(keyPath:by areInIncreasingOrder:)</code>方法，这个方法中用到了两个范型类型，其中<code>Element</code>是标准库<code>Array</code>定义的表示数组中的元素类型（在Swift中数组元素类型相同）；另外新定义了一个范型<code>Value</code>用在<code>KeyPath</code>中。</p><p>新增方法的实现完全是利用Swift标准库中的<code>sorted(by areInIncreasingOrder:)</code>方法，与上面对整数排序不同的是这里的两个元素用的是<code>$0[keyPath: keyPath]</code>和<code>$1[keyPath: keyPath]</code>。</p><p>$0和$1表示的是用来比较的两个元素，这两个元素都是实例对象，通过<code>keyPath</code>把对象中的属性值取出来之后就满足了标准库中<code>sorted</code>函数定义。</p><p>同理，我们也可以利用这个方法来进行嵌套类型的排序，比如按照公众号拥有着的年龄对多个公众号排序。</p><div class="note info"><p>到公众号【iOS开发栈】学习更多Swift、SwiftUI、iOS开发相关内容。</p></div><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>这篇文章从概念到实战对<code>KeyPath</code>做了一个全面的讲解，相信你已经对这个概念有了一定的认识，其实这是Swift中一个非常强大功能，以后遇到了合适的场景就用起来吧。👍</p>]]></content>
    
    
    <summary type="html">&lt;p&gt;作为一门非常强调类型安全的语言，为了让程序员尽量少犯错误，Swift在编译时会进行尽量多的类型检查，因此在设计之初就决定了Swift不能像其他某些语言（比如Objective-C）一样具有很强的动态特性。这篇文章要说的&lt;code&gt;KeyPath&lt;/code&gt;就是为了类型安全而生的特性之一。&lt;/p&gt;
&lt;p&gt;下面主要包括这几个方面的内容：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;Keypath是什么&lt;/li&gt;
&lt;li&gt;KeyPath的作用，也就是为什么要使用Keypath&lt;/li&gt;
&lt;li&gt;KeyPath的使用示例&lt;/li&gt;
&lt;/ol&gt;</summary>
    
    
    
    
    <category term="Swift" scheme="http://www.iosprogrammer.tech/tags/Swift/"/>
    
  </entry>
  
  <entry>
    <title>解密SwiftUI中@ViewBuilder的黑暗魔法</title>
    <link href="http://www.iosprogrammer.tech/swiftui/swiftui-viewbuilder/"/>
    <id>http://www.iosprogrammer.tech/swiftui/swiftui-viewbuilder/</id>
    <published>2021-07-03T09:02:04.000Z</published>
    <updated>2021-07-04T02:52:57.679Z</updated>
    
    <content type="html"><![CDATA[<p>在SwiftUI框架中使用很多的注解，虽然使语法看上去非常简洁，但是增加了初学者的理解难度，这篇文章我们来看一下<code>@ViewBuilder</code>的相关知识。主要包括以下内容：</p><ol><li><code>resultBuilder</code>/<code>functionBuilder</code>是什么以及用法</li><li><code>ViewBuilder</code>结构体</li><li><code>@ViewBuilder</code>修饰符的用法</li><li>使用<code>@ViewBuilder</code>完成一个自定义视图</li></ol><a id="more"></a><div class="note info"><p>到公众号【iOS开发栈】学习更多SwiftUI、iOS开发相关内容。</p></div><h1 id="resultBuilder注解"><a href="#resultBuilder注解" class="headerlink" title="@resultBuilder注解"></a><code>@resultBuilder</code>注解</h1><p><code>@resultBuilder</code>是在Swift5.4添加的，之前是叫<code>@_functionBuilder</code>，在这里我们可以简单了解一下它的作用。</p><p>一个类、结构体添加<code>@resultBuilder</code>注解时必须包含至少一个<code>buildBlock</code>方法，并且这个方法是<code>static</code>静态的。这个方法可以接收0个或多个参数，在函数内部确定了参数的组成形式。</p><p>比如下面这个例子：</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@resultBuilder</span> <span class="class"><span class="keyword">struct</span> <span class="title">StringBuilder</span> </span>&#123;</span><br><span class="line">    <span class="keyword">static</span> <span class="function"><span class="keyword">func</span> <span class="title">buildBlock</span><span class="params">(<span class="keyword">_</span> string1: String, <span class="keyword">_</span> string2: String, <span class="keyword">_</span> string3: String)</span></span> -&gt; <span class="type">String</span> &#123;</span><br><span class="line">        string1 <span class="operator">+</span> <span class="string">&quot; - &quot;</span> <span class="operator">+</span> string2 <span class="operator">+</span> <span class="string">&quot; - &quot;</span> <span class="operator">+</span> string3</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">test</span><span class="params">(@StringBuilder strings: <span class="params">()</span></span></span> -&gt; <span class="type">String</span>) &#123;</span><br><span class="line">    <span class="built_in">print</span>(strings())</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">test &#123;</span><br><span class="line">    <span class="string">&quot;1&quot;</span></span><br><span class="line">    <span class="string">&quot;2&quot;</span></span><br><span class="line">    <span class="string">&quot;3&quot;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>StringBuilder</code>是一个字符串构建者结构体，里面的<code>buildBlock</code>方法接收3个参数，并且在3个参数中间插入” - “作为函数的返回值。</p><p><code>test</code>函数接收一个使用<code>@StringBuilder</code>修饰的名为<code>strings</code>的闭包作为参数，函数体是调用这个闭包并打印到控制台。</p><p>最后使用3个字符串作为参数调用<code>test</code>函数，执行这段代码后会得到”1 - 2 - 3”的输出结果</p><h1 id="ViewBuilder定义"><a href="#ViewBuilder定义" class="headerlink" title="@ViewBuilder定义"></a><code>@ViewBuilder</code>定义</h1><p>先来看<code>ViewBuilder</code>的定义：</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@resultBuilder</span> <span class="class"><span class="keyword">struct</span> <span class="title">ViewBuilder</span></span></span><br></pre></td></tr></table></figure><p><code>ViewBuilder</code>本质上是一个结构体，并且被<code>@resultBuilder</code>注解，也就是说<code>ViewBuilder</code>是一个reult builder（结果建造者）类型了。</p><p><code>ViewBuilder</code>结构体有11个名为<code>buildBlock</code>的函数，分别接收从0到10个<code>View</code>类型的参数，因此在SwiftUI中一个接收<code>@ViewBuilder</code>类型参数的视图容器最多能接收10个子视图，如果不能满足需求可以通过拆分来增加子视图的个数。</p><h1 id="ViewBuilder的用法"><a href="#ViewBuilder的用法" class="headerlink" title="@ViewBuilder的用法"></a><code>@ViewBuilder</code>的用法</h1><p>使用<code>@resultBuilder</code>注解<code>ViewBuilder</code>结构体后，就可以用<code>@ViewBuilder</code>修饰闭包，这个闭包可以接收多个指定类型的对象，而这些对象会按照<code>buildBlock</code>函数的实现进行组织。</p><blockquote><p>A custom parameter attribute that constructs views from closures.</p></blockquote><p>这是Apple的官方文档对ViewBuilder的定义，简单来说ViewBuilder就是一个包含多个视图的闭包。</p><p>在SwiftUI框架中，所有的容器视图都是使用<code>@ViewBuilder</code>来修饰最后一个参数，因此这些容器视图可以接受多个子视图作为参数。比如<code>HStack</code>/<code>VStack</code>/<code>ScrollView</code>等。</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// HStack</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">struct</span> <span class="title">HStack</span>&lt;<span class="title">Content</span>&gt; : <span class="title">View</span> <span class="title">where</span> <span class="title">Content</span> : <span class="title">View</span> </span>&#123;</span><br><span class="line">    <span class="operator">...</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">@inlinable</span> <span class="keyword">public</span> <span class="keyword">init</span>(alignment: <span class="type">VerticalAlignment</span> <span class="operator">=</span> .center, spacing: <span class="type">CGFloat</span>? <span class="operator">=</span> <span class="literal">nil</span>, <span class="meta">@ViewBuilder</span> content: () -&gt; <span class="type">Content</span>)</span><br><span class="line"></span><br><span class="line">    <span class="operator">...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这是<code>HStack</code>的初始化方法，其中前面的几个参数都是可选项，它们不在本篇文章的讨论范围内。</p><p>它的最后一个参数<code>content</code>的类型是一个返回值为Content的闭包，单看<code>()-&gt;Content</code>是一个没有参数的闭包，但是前面使用了<code>@ViewBuilder</code>修饰，这就是一个可以接收多个视图的闭包了，最终看起来像是这样的：<code>(view1: Content, view2: Content....) -&gt; Content</code>。</p><p>下面我们通过自定义一个视图来看<code>@ViewBuilder</code>的用法。</p><h1 id="实践"><a href="#实践" class="headerlink" title="实践"></a>实践</h1><p>下面通过实现一个自定义的容器视图来展示<code>@ViewBuilder</code>的用法：</p><p><img src="../../images/viewbuilder/containerview.png" alt="@ViewBuilder示例"></p><p>自定义一个继承自<code>View</code>名为<code>CustomContainerView</code>的视图，它仅有一个接收<code>@ViewBuilder</code>类型参数的初始化方法，并使用常量<code>content</code>接收这个参数。</p><p>在<code>body</code>中构建当前视图：<code>@ViewBuilder</code>中可能包含多个子视图，因此使用<code>VStack</code>把这些子视图纵向排列，之后使用多个<a href="https://www.iosprogrammer.tech/swiftui/swiftui-concept-essential/#Modifer">视图修改器</a>自定义子视图的外观。</p><p>在源文件的第29行，<code>ContentView</code>中创建了<code>CustomContainerView</code>并给它传递了3个<code>Text</code>子视图。通过Xcode右侧的即时预览可以看到这三个子视图正是以我们在<code>CustomContainerView</code>中要求的方式展现出来——纵向排列、绿色的背景色、红色的文字颜色等。</p><div class="note info"><p>到公众号【iOS开发栈】学习更多SwiftUI、iOS开发相关内容。</p></div><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>至此，关于<code>@ViewBuilder</code>的相关知识基本都涉及到了，相信通过本篇文章的学习你一定也对它有了一个非常全面的掌握，那么赶快到实战项目中用起来吧👍。</p>]]></content>
    
    
    <summary type="html">&lt;p&gt;在SwiftUI框架中使用很多的注解，虽然使语法看上去非常简洁，但是增加了初学者的理解难度，这篇文章我们来看一下&lt;code&gt;@ViewBuilder&lt;/code&gt;的相关知识。主要包括以下内容：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;&lt;code&gt;resultBuilder&lt;/code&gt;/&lt;code&gt;functionBuilder&lt;/code&gt;是什么以及用法&lt;/li&gt;
&lt;li&gt;&lt;code&gt;ViewBuilder&lt;/code&gt;结构体&lt;/li&gt;
&lt;li&gt;&lt;code&gt;@ViewBuilder&lt;/code&gt;修饰符的用法&lt;/li&gt;
&lt;li&gt;使用&lt;code&gt;@ViewBuilder&lt;/code&gt;完成一个自定义视图&lt;/li&gt;
&lt;/ol&gt;</summary>
    
    
    
    
    <category term="SwiftUI" scheme="http://www.iosprogrammer.tech/tags/SwiftUI/"/>
    
  </entry>
  
  <entry>
    <title>程序员读《成为乔布斯》</title>
    <link href="http://www.iosprogrammer.tech/notes/read-becoming-steve-jobs/"/>
    <id>http://www.iosprogrammer.tech/notes/read-becoming-steve-jobs/</id>
    <published>2021-06-26T09:14:26.000Z</published>
    <updated>2021-06-27T02:38:01.397Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>他的故事不是成功的故事，而是成长的故事。他从一位杰出的艺术家成长为杰出的企业管理者。</p></blockquote><p>这也许是对乔布斯的一生最为贴切的概括。</p><a id="more"></a><p><img src="../../images/becoming-jobs/s28948876.jpg"></p><p>乔布斯是Apple辉煌的缔造者，Apple是乔布斯能够发挥光辉的舞台，两者之间是互相成就。</p><p>乔布斯的生涯大概可以分为三个阶段，这篇读后感就从这三个方面讲起吧，我们作为一个程序员从这三个方面可以学到很多不同的东西。</p><h1 id="乔布斯1-0"><a href="#乔布斯1-0" class="headerlink" title="乔布斯1.0"></a>乔布斯1.0</h1><p>这个时期是乔布斯人生中最为理想主义、浪漫主义的时期，也是最荒诞不经、饱受诟病的时期，虽然这个时期的乔布斯完全称不上是一位成功的企业家，但确实一位实实在在的创造者。</p><h2 id="乔布斯的家庭"><a href="#乔布斯的家庭" class="headerlink" title="乔布斯的家庭"></a>乔布斯的家庭</h2><p>乔布斯出生于1955年的旧金山，出生没多久他的父母就把他给了一对中产阶级的夫妇收养，虽然他的养父母拼尽全力让他进入了大学读书，但是就像其他名人的传奇一样 —— 中途辍学了。</p><p>乔布斯正因为成长在这样一个家庭中才能有了后面诸多的成就。</p><p>养父母给予他足够的关怀与赞赏，使他长大后依然对自己拥有绝对的自信（甚至是超过常人的自负），<strong>从这里我们可以学到一点，就是为人父母以后一定要给予孩子足够的爱，并且要进行赞扬式教育</strong>。</p><p>另外一点非常重要的是，他的养父从事木匠工作 —— 这是一门手艺活，做的工作和程序员本质上很相似。他从小就教育乔布斯要工作认真并追求完美，哪怕是那些外人所看不到的地方也尽量要做到完美。</p><blockquote><p>对于一个橱柜来说，别人看不到的底面与表面的抛光一样重要;对于一辆雪佛兰汽⻋来说，别人看不到的刹⻋片和汽⻋的油漆一样重要。</p></blockquote><p>总结一句话就是 —— 关注细节。写代码也同样的道理， 对于用户看不到的地方——比如代 码规范、执行效率一定也要严格要求，并尽量做到最好。</p><h2 id="青年乔布斯"><a href="#青年乔布斯" class="headerlink" title="青年乔布斯"></a>青年乔布斯</h2><p>乔布斯从原生家庭学到的自信和认真的品质贯穿了他的整个职业生涯，不可否认，正是这两个品质促使他达到了那样的人生高度。</p><p>乔布斯的青年时期恰逢美国的计算机蓬勃发展的阶段，作为一个拥有及其敏感商业嗅觉的年轻人，他当然不会错过这个机会。</p><p>在那个时期他结识了另一位技术天才 —— 沃兹尼亚克。</p><p>两位天才在凭借自己的绝对天分在<strong>1976年开发出了 AppleI 电脑，并成立了“苹果合伙公司”</strong>。</p><p>当时与他们同样对微机相关技术感兴趣的年轻人非常多，但是最终以此为本成立公司的却屈指可数，正如本书中所说。</p><blockquote><p>成员中只有少数几位拥有宏大的商业理想，成立了自己的微机公司，其他大部分人只是埋头钻研电子技术难点。</p></blockquote><p><strong>作为一名程序员，我们特别容易陷入对技术的痴迷和自娱自乐中，却忽视了把技术商业化才是对自己所掌握技术的最好证明和回报。</strong></p><h2 id="初创苹果的乔布斯"><a href="#初创苹果的乔布斯" class="headerlink" title="初创苹果的乔布斯"></a>初创苹果的乔布斯</h2><p>这是恶魔与天使共存的乔布斯。</p><p>Apple一代和二代获得了极好的市场反馈，苹果公司也因此赚的盆满钵满，并于1980年上市。</p><p>但是在二代电脑推出以后苹果公司却黔驴技穷了，先后尝试多款产品却都没有收获好的效果。</p><p>在这个时期乔布斯一直是作为某个产品线的负责人在施展自己的才华和野蛮。</p><p>他看到自己感兴趣的项目以后无所不用其极的排挤掉原来的负责人，进而把那个项目占为己有。</p><p>并且对自己手下的工程师也是无所不用其极。他一边逼迫工程师为了能够如期完成项目进度而不停加班，一边又极力维护这些工程师，容不得别人说一句坏话，并且对这些工程师极尽赞美。</p><blockquote><p>无论他的说辞怎么变，都能给团队成员一种感觉，仿佛在史蒂夫眼里，他们真的是艺术家，是创新者。</p></blockquote><blockquote><p> 为史蒂夫工作的这些年是他们生命中工作业绩最为突出的几年。</p></blockquote><p>这些受尽虐待的工程师在史蒂夫要离开苹果时竟然会选择继续跟随。读到这里，我对史蒂夫的魅力佩服的无以言表。</p><p>最终苹果董事会无法面对业绩不断下滑的局面，选择了孤立这个“天才与混蛋的结合体”。最终乔布斯选择离开苹果。</p><h1 id="乔布斯2-0"><a href="#乔布斯2-0" class="headerlink" title="乔布斯2.0"></a>乔布斯2.0</h1><p>这个时期的乔布斯是职业生涯中学习管理经验最多的一个时期，也是他性格成熟最快的一个时期。</p><h2 id="Next"><a href="#Next" class="headerlink" title="Next"></a>Next</h2><p>在离开苹果后，乔布斯创立了Next，其中的员工基本都是苹果公司的前员工。不过在经营Next的几年中乔布斯并没有多少可圈可点的成就。</p><p>不过对于我们iOS开发来说，正是因为这个时期的Next完成了Objective-C语言的基础工作，才让我等有口饭吃。</p><p>在这段时间，乔布斯尝试了新的个人电脑和多种不同的销售方式，却最终都没有扭转Next巨亏的局面。</p><p>导致失败的原因大多是由于乔布斯凡事都要和苹果较量一番，尤其是在极尽奢华的办公楼和电脑的生产线方面真的是不惜重金。结果就是应了那句：没有苹果的命，却得了苹果的病。</p><p>在Next的11年是乔布斯人生中的至暗时刻，但是上帝在给他关闭一扇门的同时却打开了另一扇窗。</p><h2 id="皮克斯"><a href="#皮克斯" class="headerlink" title="皮克斯"></a>皮克斯</h2><p>如果说Next是乔布斯对苹果情怀的一种延续，那么皮克斯就完全是另一项事业，而且他从这项事业中学习到了之前从未学到的管理企业和管理情绪的技能。</p><p>皮克斯的前身一个制图小组，并且在乔布斯成为它的老板之前，这就是一个建制非常稳定的公司了。尤其是它的两个管理者是及其擅长管理皮克斯这种充满创造力的企业的。</p><p>乔布斯对皮克斯的管理从来没有像在苹果或者Next一样事无巨细的插手，而是始终处于一个有些距离的地方远观，也正是因为这样皮克斯才始终能够保持最初的创造力和团队和谐，以至于最终能够连续制作出很多举世闻名的影片。</p><p>乔布斯对于这家公司来说更像是一个可以源源不断产奶的奶牛，在公司前期经济困难的时期乔布斯凭借在苹果时期积攒的资金不停给它输血。</p><blockquote><p>最好的管理技能就是放手，给予手下的优秀人才足够的空间</p></blockquote><p>而皮克斯就像是乔布斯的一个老师一样，教导着乔布斯要怎么管理企业以及怎么和企业内的高管合作。</p><p>在被苹果放逐的11年里，乔布斯经历了人生的大起大落，性格变得更加沉稳，管理技能也更加丰富成熟。</p><h1 id="乔布斯3-0"><a href="#乔布斯3-0" class="headerlink" title="乔布斯3.0"></a>乔布斯3.0</h1><p>重新回到苹果的乔布斯在成功把苹果拯救回来以后，不断推出风靡世界的产品，最终把自己也把苹果推向了一座至今无人企及的高峰。</p><blockquote><p>苹果就是我所擅⻓的领域。我当然不想失败，再次踏进苹果时，尽管并不知道情况到底有多糟糕，但我仍然有很多顾虑。我必须要考虑如果失败了，对皮克斯有什么影响，对我的家庭有什么影响，对我的名誉有什么影响。但我最终决定放手一搏。如果我竭尽所能依然失败了，至少我已经尽力了。</p></blockquote><p>这是乔布斯在决定担任苹果CEO之前的一些想法，可以明显看出他再也不是那个20多岁的毛头小伙，在做事情以前开始能够全面考虑事情的影响。</p><p>但是他依然是那个对事业充满激情的人，在知道可能失败并且失败后会对自己的家庭、声誉、已有事业造成重大影响的情况下，依然选择从事自己热爱的工作。</p><blockquote><p>推出前沿产品，服务高端个人和专业市场。</p></blockquote><p>乔布斯再次给苹果这样的定位，之后对苹果的拯救行动也都是建立在这样的思想之上。最终苹果进行了大量裁员和产品线的裁撤，保留了4条符合这个定位的产品线，集中精力打造公司独有的产品特色和定位。</p><p>随着2001年iPod的推出和2003年iTunes音乐商店的推出苹果从悬崖边上被拉了回来，重新站在了消费电子产品的第一梯队。</p><p>而接着在2007年推出的iPhone和2010年推出的iPad则完全把苹果推到了时代的风头浪尖，彻底的和其他公司拉开了巨大差距。</p><p>正如书中所说，我们大多数人对苹果的认识只是建立在那简单大气的外观设计和流畅的操作体验上，而苹果真正对世界的贡献却是：</p><blockquote><p>⻨金塔、iPhone和iPad其实是把 Unix超级计算机装进了一个适合消费者使用的外壳里，这才是苹果的成就，却没有人讨论，因为大家都把目光放在了设计上。”他身体前倾，继续说道，“你口袋里的 iPhone事实上就是20年前售价高达1000万美元的克雷XMP超级计算机，iPhone的操作系统、运算处理速度、数据存储容量都与XMP不相上下，但售价却只要600美元。这是史蒂夫的突破，这才是iPhone的本质。</p></blockquote><p>毫无疑问苹果是能够让每个人用上电子产品的伟大推手，而苹果在这些产品技术中的实际发明创造并不多，但是却是最成功把各种技术商业化的公司。</p><p>而能够将那些高高在上的产品和技术让普通大众用上何尝不是一项非常伟大的能力。在一定程度上来说，埃隆马斯克是一个和乔布斯同样伟大的企业家。</p><p>2011年10月5日是一个周二，全世界在这一天失去了伟大的乔布斯。</p><blockquote><p>他的故事不是成功的故事，而是成长的故事。他从一位杰出的艺术家成长为杰出的企业管理者。</p></blockquote><p>乔布斯的一生是精彩而充满了跌宕起伏的，在那样一个时代他引领了世界的消费电子产业发展，并且创建了至今仍是市值第一的苹果公司。</p><p>后乔布斯时代的苹果在库克的带领下仍然高歌猛进，只是让我们这些果粉总是觉着缺少了一丝让人眼前一亮的感觉，也许只是因为没有了传奇的乔布斯使苹果失去了往日的传奇色彩。</p>]]></content>
    
    
    <summary type="html">&lt;blockquote&gt;
&lt;p&gt;他的故事不是成功的故事，而是成长的故事。他从一位杰出的艺术家成长为杰出的企业管理者。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;这也许是对乔布斯的一生最为贴切的概括。&lt;/p&gt;</summary>
    
    
    
    
    <category term="读书笔记" scheme="http://www.iosprogrammer.tech/tags/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/"/>
    
  </entry>
  
  <entry>
    <title>SwiftUI弹窗大全：Menu/Alert/ActionSheet</title>
    <link href="http://www.iosprogrammer.tech/swiftui/swiftui-alertview/"/>
    <id>http://www.iosprogrammer.tech/swiftui/swiftui-alertview/</id>
    <published>2021-06-12T10:31:50.000Z</published>
    <updated>2021-06-12T13:08:46.358Z</updated>
    
    <content type="html"><![CDATA[<p>一个iOS应用中必然会有很多的弹窗，UIKit中的弹窗主要是<code>UIMenuController</code>、<code>UIAlertView</code>和<code>UIActionController</code>，到了SwiftUI框架中也有对应的弹窗，它们分别是<code>contextMenu</code>、<code>alert</code>和<code>actionSheet</code>三个<a href="https://www.iosprogrammer.tech/swiftui/swiftui-concept-essential/#Modifer">ViewModifier(视图修改器)</a>。</p><a id="more"></a><p><img src="../../images/swiftui-popupview/first.png"></p><div class="note info"><p>到公众号【iOS开发栈】学习更多SwiftUI、iOS开发相关内容。</p></div><h1 id="contextMenu"><a href="#contextMenu" class="headerlink" title="contextMenu"></a>contextMenu</h1><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* 下面两种方式是等价的 */</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 第一种方式</span></span><br><span class="line"><span class="keyword">let</span> menu <span class="operator">=</span> <span class="type">ContextMenu</span> &#123; </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">Button</span>(<span class="string">&quot;1&quot;</span>, action: &#123;&#125;)</span><br><span class="line">    .contextMenu(menu)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 第二种方式</span></span><br><span class="line"><span class="type">Image</span>(systemName: <span class="string">&quot;square.and.arrow.up&quot;</span>)</span><br><span class="line">    .contextMenu &#123;</span><br><span class="line">        <span class="type">Button</span>(<span class="string">&quot;1&quot;</span>, action: &#123;&#125;)</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p><code>contextMenu</code>两种初始化方式对应上面例子中的两种方式，第一种<code>public func contextMenu&lt;MenuItems&gt;(_ contextMenu: ContextMenu&lt;MenuItems&gt;?) -&gt; some View where MenuItems : View</code>是用一个<code>ContextMenu</code>实例作为参数；第二种<code>public func contextMenu&lt;MenuItems&gt;(@ViewBuilder menuItems: () -&gt; MenuItems) -&gt; some View where MenuItems : View</code>的参数是一个使用<code>@ViewBuilder</code>修饰的闭包。</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">struct</span> <span class="title">ContextMenu</span>&lt;<span class="title">MenuItems</span>&gt; <span class="title">where</span> <span class="title">MenuItems</span> : <span class="title">View</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">init</span>(<span class="meta">@ViewBuilder</span> menuItems: () -&gt; <span class="type">MenuItems</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>由<code>ContextMenu</code>的初始化方法可以看出，要初始化这个类也是需要一个用<code>@ViewBuilder</code>修饰的闭包，所以上面的两种<code>menuContext</code>使用方式并没有本质区别。或者说第二种是第一种的简便方法，类似于这样的用法在SwiftUI中有很多。</p><p>下面是一个完整的例子：</p><p><img src="../../images/swiftui-popupview/menuview.png"></p><p>长按”Context Menu”文本后会弹出一个Menu菜单，其中每个选项都是一个按钮，因为这是一个示例程序所以按钮的事件没有写，在你的项目中可以加上对应的事件。</p><h1 id="alert"><a href="#alert" class="headerlink" title="alert"></a>alert</h1><p><img src="../../images/swiftui-popupview/alert.png"></p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@State</span> <span class="keyword">var</span> presentAlert: <span class="type">Bool</span> <span class="operator">=</span> <span class="literal">false</span></span><br><span class="line"></span><br><span class="line"><span class="type">Button</span> &#123;</span><br><span class="line">    presentAlert <span class="operator">=</span> <span class="literal">true</span></span><br><span class="line">&#125; label: &#123;</span><br><span class="line">    <span class="type">Text</span>(<span class="string">&quot;Show Alert&quot;</span>)</span><br><span class="line">&#125;</span><br><span class="line">        </span><br><span class="line">.alert(isPresented: <span class="variable">$presentAlert</span>) &#123;</span><br><span class="line">    <span class="keyword">let</span> alert <span class="operator">=</span> <span class="type">Alert</span>(title: <span class="type">Text</span>(<span class="string">&quot;Alert Test&quot;</span>), message: <span class="type">Text</span>(<span class="string">&quot;This is a test case&quot;</span>), primaryButton: .default(<span class="type">Text</span>(<span class="string">&quot;Sure&quot;</span>)), secondaryButton: .destructive(<span class="type">Text</span>(<span class="string">&quot;Cancel&quot;</span>)))</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> alert</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>alert</code>这个视图修改器接受两个参数，第一个是<code>Binding&lt;Bool&gt;</code>类型，我们可以通过在一个被<code>@State</code>属性包装器包装的属性前加<code>$</code>来作为这个参数，详情可以参考<a href="https://www.iosprogrammer.tech/swiftui/swiftui-concept-essential/#State%E5%92%8C-%E2%80%94%E2%80%94-Binding-Value">属性包装器和@State</a></p><p>第二个参数是一个返回值是<code>Alert</code>类型的闭包，因此我们这里需要创建一个Alert的示例作为返回值。</p><h1 id="actionSheet"><a href="#actionSheet" class="headerlink" title="actionSheet"></a>actionSheet</h1><p><img src="../../images/swiftui-popupview/actionSheet.png"></p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@State</span> <span class="keyword">var</span> presentAlert: <span class="type">Bool</span> <span class="operator">=</span> <span class="literal">false</span></span><br><span class="line"></span><br><span class="line"><span class="type">Button</span> &#123;</span><br><span class="line">    presentAlert <span class="operator">=</span> <span class="literal">true</span></span><br><span class="line">&#125; label: &#123;</span><br><span class="line">    <span class="type">Text</span>(<span class="string">&quot;Show Alert&quot;</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">.actionSheet(isPresented: <span class="variable">$presentAlert</span>) &#123;</span><br><span class="line">    <span class="keyword">let</span> actionSheet <span class="operator">=</span> <span class="type">ActionSheet</span>(title: <span class="type">Text</span>(<span class="string">&quot;Test ActionSheet&quot;</span>), message: <span class="type">Text</span>(<span class="string">&quot;This is a test&quot;</span>), buttons: [.default(<span class="type">Text</span>(<span class="string">&quot;Sure Item&quot;</span>)), .default(<span class="type">Text</span>(<span class="string">&quot;Sure Item2&quot;</span>)), .destructive(<span class="type">Text</span>(<span class="string">&quot;Cancel&quot;</span>))])</span><br><span class="line">    <span class="keyword">return</span> actionSheet</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>actionSheet</code>和上面的<code>alert</code>用法非常相似，第一个参数是一个<code>Binding&lt;Bool&gt;</code>类型的变量，<code>presentAlert</code>是一个被<code>@State</code>属性包装器包装的Bool类型变量，在这个变量前面加<code>$</code>可以生成一个Binding类型的变量。</p><p>第一个参数是一个返回值是<code>ActionSheet</code>类型的闭包，因此需要创建这个类型的实例并将它作为返回值。<code>buttons</code>参数是一个<code>ActionSheet.Button</code>类型的数组，因为这是一个实例程序，Button并没有添加任何的事件，如果需要可以自行添加。</p><div class="note info"><p>到公众号【iOS开发栈】学习更多SwiftUI、iOS开发相关内容。</p></div><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>这篇文章对SwiftUI框架中的<code>contextMenu</code>、<code>alert</code>和<code>actionSheet</code>做了全面的说明，你现在对这3种弹窗肯定有了全面的认识，那就在项目中用起来吧。👍</p>]]></content>
    
    
    <summary type="html">&lt;p&gt;一个iOS应用中必然会有很多的弹窗，UIKit中的弹窗主要是&lt;code&gt;UIMenuController&lt;/code&gt;、&lt;code&gt;UIAlertView&lt;/code&gt;和&lt;code&gt;UIActionController&lt;/code&gt;，到了SwiftUI框架中也有对应的弹窗，它们分别是&lt;code&gt;contextMenu&lt;/code&gt;、&lt;code&gt;alert&lt;/code&gt;和&lt;code&gt;actionSheet&lt;/code&gt;三个&lt;a href=&quot;https://www.iosprogrammer.tech/swiftui/swiftui-concept-essential/#Modifer&quot;&gt;ViewModifier(视图修改器)&lt;/a&gt;。&lt;/p&gt;</summary>
    
    
    
    
    <category term="SwiftUI" scheme="http://www.iosprogrammer.tech/tags/SwiftUI/"/>
    
  </entry>
  
  <entry>
    <title>全面掌握！SwiftUI2.0中TabView的知识和用法</title>
    <link href="http://www.iosprogrammer.tech/swiftui/swiftui-tabview/"/>
    <id>http://www.iosprogrammer.tech/swiftui/swiftui-tabview/</id>
    <published>2021-05-20T00:35:28.000Z</published>
    <updated>2021-05-21T10:24:57.866Z</updated>
    
    <content type="html"><![CDATA[<p>绝大多数App的底部都有Tabbar来切换不同的功能，在UIKit框架中使用<code>UITabbarController</code>来实现这样的操作，到了SwiftUI中被<code>TabView</code>取代了。</p><p>这篇文章我们将学习关于<code>TabView</code>的一些基础知识和高阶用法，其中包括这几个主要方面：</p><ol><li>怎么创建<code>TabView</code></li><li><code>TabView</code>比<code>UITabbarController</code>的优势</li><li>自定义TabView的外观</li></ol><a id="more"></a><div class="note info"><p>到公众号【iOS开发栈】学习更多SwiftUI、iOS开发相关内容。</p></div><p><img src="../../images/swiftui-tabview/first.png"></p><h1 id="开始使用TabView"><a href="#开始使用TabView" class="headerlink" title="开始使用TabView"></a>开始使用<code>TabView</code></h1><h2 id="最基础的TabView"><a href="#最基础的TabView" class="headerlink" title="最基础的TabView"></a>最基础的TabView</h2><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">TabView</span> &#123;</span><br><span class="line">    <span class="type">ContentView</span>()</span><br><span class="line">    <span class="type">SecondView</span>()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这样就创建了一个最简单的<code>TabView</code>，和其他很多SwiftUI的控件一样TabView的初始化也是接收一个<code>@ViewBuilder</code>修饰的View<code>public init(@ViewBuilder content: () -&gt; Content)</code>。</p><p>其中的<code>ContentView</code>和<code>SecondView</code>是<code>TabView</code>的两个<code>Tabbar</code>，但是由于我们没有设置<code>Tabbar</code>的图片和文字，此时App最底部的导航栏是空的。</p><h2 id="给Tabbar设置图片和文字"><a href="#给Tabbar设置图片和文字" class="headerlink" title="给Tabbar设置图片和文字"></a>给Tabbar设置图片和文字</h2><p>得益于SwiftUI的声明式语法，我们设置tabbar中文字和图片的效率比UIKit高了10倍。</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">TabView</span> &#123;</span><br><span class="line">    <span class="type">ContentView</span>()</span><br><span class="line">        .tabItem &#123; <span class="type">Label</span>(<span class="string">&quot;Menu&quot;</span>, systemImage: <span class="string">&quot;list.dash&quot;</span>) &#125;</span><br><span class="line">    <span class="type">SecondView</span>()</span><br><span class="line">        .tabItem &#123;</span><br><span class="line">            <span class="type">Image</span>(systemName: <span class="string">&quot;square.and.pencil&quot;</span>)</span><br><span class="line">            <span class="type">Text</span>(<span class="string">&quot;Me&quot;</span>)</span><br><span class="line">        &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="../../images/swiftui-tabview/essential-tabview.png"></p><p>给tabbar设置图片和文字使用的是<code>tabItem</code><a href="https://www.iosprogrammer.tech/swiftui/swiftui-concept-essential#Modifer">视图修改器</a>。</p><p>第一种设置文字和图片的方法是使用<code>Label</code>控件，它通过一个文字和一个图片作为参数来进行初始化，而第二种方式是直接使用了一段文字和一张图片。</p><p>由于tabItem修改器的参数是一组View所以原则上来说可以使用任意View来设置tabbar的样式。</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Tabbar</span>: <span class="title">View</span> </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> body: <span class="keyword">some</span> <span class="type">View</span> &#123;</span><br><span class="line">        <span class="type">VStack</span> &#123;</span><br><span class="line">            <span class="type">Text</span>(<span class="string">&quot;1&quot;</span>)</span><br><span class="line">            <span class="type">Text</span>(<span class="string">&quot;2&quot;</span>)</span><br><span class="line">            <span class="type">Image</span>(systemName: <span class="string">&quot;square.and.pencil&quot;</span>)</span><br><span class="line">            <span class="type">Image</span>(systemName: <span class="string">&quot;list.dash&quot;</span>)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">.tabItem &#123;</span><br><span class="line">    <span class="type">Tabbar</span>()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>使用了一个包含两段文字和两张图片的Tabbar来设置<code>tabItem</code>，最终能够显示出来的是<code>Text(&quot;1&quot;)</code>和<code>Image(systemName: &quot;square.and.pencil&quot;)</code>，所以tabItem在实现的时候应该是使用的子视图中的第一段文字和第一张图片，且不论文字和图片的顺序如何，它们最终展示出来的位置都不会变。</p><h1 id="自定义TabView外观"><a href="#自定义TabView外观" class="headerlink" title="自定义TabView外观"></a>自定义<code>TabView</code>外观</h1><h2 id="修改tabView的样式"><a href="#修改tabView的样式" class="headerlink" title="修改tabView的样式"></a>修改tabView的样式</h2><p>使用<code>tabViewStyle</code>修改器来设置不同的样式可以轻易满足不同的场景需要。</p><table><thead><tr><th>TabViewStyle</th><th>解释</th></tr></thead><tbody><tr><td>DefaultTabViewStyle</td><td>默认样式，效果类似UITabbarController</td></tr><tr><td>PageTabViewStyle</td><td>没有下面的标签，可以左右滚动，常见于新闻App</td></tr></tbody></table><p>使用方式：</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">TabView</span> &#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line">.tabViewStyle(<span class="type">DefaultTabViewStyle</span>())</span><br></pre></td></tr></table></figure><h2 id="设置tabbarItem的选中颜色"><a href="#设置tabbarItem的选中颜色" class="headerlink" title="设置tabbarItem的选中颜色"></a>设置tabbarItem的选中颜色</h2><p>使用<code>accentColor()</code><a href="https://www.iosprogrammer.tech/swiftui/swiftui-concept-essential#Modifer">修改器</a>可以设置tabItem的选中颜色。</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">.tabItem &#123;</span><br><span class="line">    <span class="type">Label</span>(<span class="string">&quot;Menu&quot;</span>, systemImage: <span class="string">&quot;list.dash&quot;</span>)</span><br><span class="line">&#125;</span><br><span class="line">.accentColor(.green)</span><br></pre></td></tr></table></figure><p><code>accentColor</code>是设置View高亮颜色的修改器，设置后tabItem在未选中状态下是灰色，选中后是green绿色。</p><h2 id="导航控制器隐藏TabBar"><a href="#导航控制器隐藏TabBar" class="headerlink" title="导航控制器隐藏TabBar"></a>导航控制器隐藏TabBar</h2><h3 id="自动隐藏底部tabbar"><a href="#自动隐藏底部tabbar" class="headerlink" title="自动隐藏底部tabbar"></a>自动隐藏底部tabbar</h3><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">NavigationView</span> &#123;</span><br><span class="line">    <span class="type">TabView</span>(selection: <span class="variable">$tabViewSelection</span>) &#123;</span><br><span class="line">        <span class="type">List</span>(<span class="number">1</span><span class="operator">...</span><span class="number">10</span>, id: \.<span class="keyword">self</span>) &#123;index <span class="keyword">in</span></span><br><span class="line">            <span class="type">NavigationLink</span>(</span><br><span class="line">                destination: <span class="type">Text</span>(<span class="string">&quot;Item <span class="subst">\(index)</span> Details&quot;</span>),</span><br><span class="line">                label: &#123;</span><br><span class="line">                    <span class="type">Text</span>(<span class="string">&quot;Item <span class="subst">\(index)</span>&quot;</span>)</span><br><span class="line">                &#125;)</span><br><span class="line">        &#125;</span><br><span class="line">        .tabItem &#123;</span><br><span class="line">            <span class="type">Label</span>(<span class="string">&quot;Menu&quot;</span>, systemImage: <span class="string">&quot;list.dash&quot;</span>)</span><br><span class="line">        &#125;</span><br><span class="line">        .accentColor(.blue)</span><br><span class="line">        .navigationTitle(<span class="string">&quot;Menu&quot;</span>)</span><br><span class="line">        .tag(<span class="number">0</span>)</span><br><span class="line">        </span><br><span class="line">        <span class="type">Text</span>(<span class="string">&quot;Second Page&quot;</span>)</span><br><span class="line">            .navigationTitle(<span class="string">&quot;Me&quot;</span>)</span><br><span class="line">            .tabItem &#123;</span><br><span class="line">                <span class="type">Label</span>(<span class="string">&quot;Me&quot;</span>, systemImage: <span class="string">&quot;square.and.pencil&quot;</span>)</span><br><span class="line">            &#125;</span><br><span class="line">            .navigationTitle(<span class="string">&quot;Home&quot;</span>)</span><br><span class="line">            .accentColor(.red)</span><br><span class="line">            .tag(<span class="number">1</span>)</span><br><span class="line">    &#125;</span><br><span class="line">    .navigationTitle(tabViewSelection <span class="operator">==</span> <span class="number">0</span> <span class="operator">?</span> <span class="string">&quot;Home&quot;</span> : <span class="string">&quot;Me&quot;</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>将TabView嵌套在NavigationView里面也就是说TabView整体作为导航栈的首页，通过这种方式可以实现切换到二级页面自动隐藏底部Tabbar的效果。</p><p>不过这样做会带来一个问题：TabView被当作一个页面来看待，那么设置的<code>navigationTitle</code>会对整个TabView生效，也就是说当切换tabItem的时候导航栏标题不会改变。为了解决这个问题，这里根据当前选中的tabItem来切换标题。关于怎么获取选中的tabItem和<code>tag</code>的内容我们下面再说。</p><h3 id="不隐藏底部tabbar"><a href="#不隐藏底部tabbar" class="headerlink" title="不隐藏底部tabbar"></a>不隐藏底部tabbar</h3><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">TabView</span> &#123;</span><br><span class="line">    <span class="type">NavigationView</span> &#123;</span><br><span class="line">        <span class="type">List</span>(<span class="number">1</span><span class="operator">...</span><span class="number">10</span>, id: \.<span class="keyword">self</span>) &#123;index <span class="keyword">in</span></span><br><span class="line">            <span class="type">NavigationLink</span>(</span><br><span class="line">                destination: <span class="type">Text</span>(<span class="string">&quot;Item <span class="subst">\(index)</span> Details&quot;</span>),</span><br><span class="line">                label: &#123;</span><br><span class="line">                    <span class="type">Text</span>(<span class="string">&quot;Item <span class="subst">\(index)</span>&quot;</span>)</span><br><span class="line">                &#125;)</span><br><span class="line">        &#125;</span><br><span class="line">        .navigationTitle(<span class="string">&quot;Home&quot;</span>)</span><br><span class="line">    &#125;</span><br><span class="line">    .tabItem &#123;</span><br><span class="line">        <span class="type">Label</span>(<span class="string">&quot;Menu&quot;</span>, systemImage: <span class="string">&quot;list.dash&quot;</span>)</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="type">NavigationView</span> &#123;</span><br><span class="line">        <span class="type">Text</span>(<span class="string">&quot;Second Page&quot;</span>)</span><br><span class="line">            .navigationTitle(<span class="string">&quot;Me&quot;</span>)</span><br><span class="line">    &#125;</span><br><span class="line">    .tabItem &#123;</span><br><span class="line">        <span class="type">Label</span>(<span class="string">&quot;Me&quot;</span>, systemImage: <span class="string">&quot;square.and.pencil&quot;</span>)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>每一个NavigationView是一个TabItem，当navigationView切换到二级页面时tabBar仍然会显示。</p><p>关于SwiftUI导航栏相关的内容可以查看<a href="https://www.iosprogrammer.tech/swiftui/swiftui-navigate-get-start-tutorial">你应该知道的！关于SwiftUI中导航栏的4点知识</a>。</p><h1 id="TabView选中的tabItem"><a href="#TabView选中的tabItem" class="headerlink" title="TabView选中的tabItem"></a>TabView选中的tabItem</h1><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">init</span>(selection: <span class="type">Binding</span>&lt;<span class="type">SelectionValue</span>&gt;?, <span class="meta">@ViewBuilder</span> content: () -&gt; <span class="type">Content</span>)</span><br></pre></td></tr></table></figure><p>在<code>TabView</code>的初始化方法中除了content之外还有一个<code>selection</code>参数，它的类型是<code>Bind&lt;SelectionValue&gt;</code>，这种类型的参数可以接受一个<code>@State</code>修饰的参数，关于@State和参数绑定相关的内容可以查看<a href="%5Bhttps%5D(https://www.iosprogrammer.tech/swiftui/swiftui-concept-essential">学习SwiftUI，必须掌握的3个知识点</a>。</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@State</span> <span class="keyword">var</span> tabViewSelection <span class="operator">=</span> <span class="number">0</span></span><br><span class="line"><span class="type">TabView</span>(selection: <span class="variable">$tabViewSelection</span>)</span><br></pre></td></tr></table></figure><p><code>tabViewSelection</code>是一个被@State绑定的变量，将它传递给TabView的初始化方法之后，当切换TabItem时该变量会被修改。</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">Button</span>(<span class="string">&quot;Go to Home&quot;</span>) &#123;</span><br><span class="line">    tabViewSelection <span class="operator">=</span> <span class="number">0</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>通过点击一个按钮来修改<code>tabViewSelection</code>变量的值，tabView被选中的tabItem就会成第0个。</p><div class="note info"><p>到公众号【iOS开发栈】学习更多SwiftUI、iOS开发相关内容。</p></div><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>在这篇文章中我们主要了解了tabView的用法和怎么修改tabView以及tabItem的样式，以及关于绑定tabView选中的item的方法，相信现在你已经对SwiftUI框架中的tabView有了一个全面的掌握，赶紧用起来吧😊</p>]]></content>
    
    
    <summary type="html">&lt;p&gt;绝大多数App的底部都有Tabbar来切换不同的功能，在UIKit框架中使用&lt;code&gt;UITabbarController&lt;/code&gt;来实现这样的操作，到了SwiftUI中被&lt;code&gt;TabView&lt;/code&gt;取代了。&lt;/p&gt;
&lt;p&gt;这篇文章我们将学习关于&lt;code&gt;TabView&lt;/code&gt;的一些基础知识和高阶用法，其中包括这几个主要方面：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;怎么创建&lt;code&gt;TabView&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;TabView&lt;/code&gt;比&lt;code&gt;UITabbarController&lt;/code&gt;的优势&lt;/li&gt;
&lt;li&gt;自定义TabView的外观&lt;/li&gt;
&lt;/ol&gt;</summary>
    
    
    
    
    <category term="SwiftUI" scheme="http://www.iosprogrammer.tech/tags/SwiftUI/"/>
    
  </entry>
  
  <entry>
    <title>iOS项目国际化对【名词复数】的处理方法</title>
    <link href="http://www.iosprogrammer.tech/xcode/localized-noun-plural/"/>
    <id>http://www.iosprogrammer.tech/xcode/localized-noun-plural/</id>
    <published>2021-05-15T04:30:51.000Z</published>
    <updated>2021-05-16T12:13:26.927Z</updated>
    
    <content type="html"><![CDATA[<p>iOS项目国际化过程中对【名词复数】的处理方法和对其他文字的处理方法有些不同之处，这篇文章将从下面几个方面讲解一下项目中怎么处理名词复数。</p><ol><li>什么不能像对其他语句一样对名词复数进行处理？</li><li><code>.stringsdict</code>文件的使用方法和说明</li></ol><a id="more"></a><p><img src="../../images/localize-noun-plural/first.png"></p><div class="note info"><p>到公众号【iOS开发栈】学习更多SwiftUI、iOS开发相关内容。</p></div><h1 id="错误的名词复数处理方式"><a href="#错误的名词复数处理方式" class="headerlink" title="错误的名词复数处理方式"></a>错误的名词复数处理方式</h1><p>iOS项目国际化主要是对项目中用到的文字进行本地化语言处理，这个方面的知识在前面几篇文章都有涉及，比如<a href="https://www.iosprogrammer.tech/xcode/international-user-facing-text/">苹果官方的iOS App国际化工作流</a>、<a href="https://www.iosprogrammer.tech/xcode/language-internalization-ib/">使用Xib使App完成国际化功能</a>。</p><p>普通文本可以大致看作1对1的翻译，比如说“iOS开发栈”-&gt;“iOS developers stack”，这种一对一的翻译通过<code>.strings</code>文件可以处理。</p><p>名词复数的多语言处理是更加复杂的翻译，因为不同的语言对不同数量的表达方式都不一样。分别以英文、中文表达【iOS开发栈】公众号有几个粉丝为例：</p><table><thead><tr><th>名词</th><th>数量</th><th>英文</th><th>中文</th></tr></thead><tbody><tr><td>Fan</td><td>0</td><td>There is none fan</td><td>没有粉丝</td></tr><tr><td>Fan</td><td>1</td><td>There is one fan</td><td>有一个粉丝</td></tr><tr><td>Fan</td><td>n(n&gt;1)</td><td>There are n fans</td><td>有n个粉丝</td></tr></tbody></table><blockquote><p>不同语言对不同数量的表达可以参考<a href="https://unicode-org.github.io/cldr-staging/charts/latest/supplemental/language_plural_rules.html">Language Plural Rules</a></p></blockquote><p>如果要用<code>.strings</code>文件来处理名词复数的话，大概会写出这样的代码：</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* 伪代码 */</span></span><br><span class="line"><span class="keyword">let</span> fans <span class="operator">=</span> <span class="operator">...</span></span><br><span class="line"><span class="keyword">if</span> fans <span class="operator">==</span> <span class="number">0</span> &#123;</span><br><span class="line">    <span class="type">NSLocalizedString</span>(<span class="string">&quot;zero fans number of my offical account&quot;</span>, comment: <span class="string">&quot;The Fans Number of 【ios开发栈】is zero&quot;</span>)</span><br><span class="line">&#125; <span class="keyword">else</span> <span class="keyword">if</span> fans <span class="operator">==</span> <span class="number">1</span> &#123;</span><br><span class="line">    <span class="type">NSLocalizedString</span>(<span class="string">&quot;one fans number of my offical account&quot;</span>, comment: <span class="string">&quot;The Fans Number of 【ios开发栈】is one&quot;</span>)</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="type">NSLocalizedString</span>(<span class="string">&quot;other fans number of my offical account&quot;</span>, comment: <span class="string">&quot;The Fans Number of 【ios开发栈】is other&quot;</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如果每个用到名词复数的地方都这样写的话，项目中就会充斥着这种胶水代码，非常不利于维护。为了避免这种做法，我们可以利用Xcode自带的<code>.stringsdict</code>文件。</p><h1 id="stringsdict"><a href="#stringsdict" class="headerlink" title="stringsdict"></a>stringsdict</h1><p><code>.stringsdict</code>文件就是专门用来处理名词复数的plist文件。</p><h2 id="创建-stringsdict文件"><a href="#创建-stringsdict文件" class="headerlink" title="创建.stringsdict文件"></a>创建<code>.stringsdict</code>文件</h2><div style="display:flex;justify-content:space-evenly;">    <img src="../../images/localize-noun-plural/create-stringsdict-1.png">    <img src="../../images/localize-noun-plural/create-stringsdict-2.png">    <img src="../../images/localize-noun-plural/create-stringsdict-3.png"></div><ol><li>在项目目录右击选择New File或者使用快捷键⌘+N</li><li>新建一个Stringsdict File,并命名为<code>Localizable.stringsdict</code></li></ol><h2 id="stringsdict文件解析"><a href="#stringsdict文件解析" class="headerlink" title="stringsdict文件解析"></a><code>stringsdict</code>文件解析</h2><div style="display:flex;justify-content:space-evenly;">    <img src="../../images/localize-noun-plural/empty-stringsdict.png" alt="空的stringsdict">    <img src="../../images/localize-noun-plural/example-stringsdict.png" alt="公众号粉丝数stringdict"></div><p>左边是一个空的stringsdict文件，右边是用公众号粉丝数为例的stringsdict文件。</p><ul><li><code>Localized String Key</code>是一个文字常量,用在<code>NSLocalizedString</code>宏里面用来匹配多语言翻译，如<code>NSLocalizedString(&quot;fans number of my official account&quot;, comment: &quot;The Fans Number of 【ios开发栈】&quot;)</code>。项目中有多少个需要翻译的名词复数就要有多少个Localized String Key。</li><li><code>Localized Format Key</code>对应的是包含名词复数的句子，其中的数字和名词在<code>%#@</code>和<code>@</code>中间。</li><li><code>VARIABLE</code>用<code>%#@</code>和<code>@</code>之间的代替。这是一个键值对，内容就是VARIABLE在不同数量下的表示规则。<ul><li><code>NSStringFormatSpecTypeKey</code> 指定复数规则的类型，固定为<code>NSStringPluralRuleType</code>表示复数规则类型。</li><li><code>NSStringFormatValueTypeKey</code> 用来表示不同的数字类型，比方说整型是%d，无符号整型%u，具体可以查看<a href="https://developer.apple.com/library/archive/documentation/CoreFoundation/Conceptual/CFStrings/formatSpecifiers.html#//apple_ref/doc/uid/TP40004265">String Format Specifiers</a></li><li><code>zero</code>/<code>one</code>/<code>two</code>/<code>few,many</code>/<code>other</code> 不同数量下名词复数的表现方式，有些语言只有其中几个比如汉语基本所有数量都可以用一种方式来表达（1个、2个、100个），英语有两种（one fan/many fans），更多的语言可以查看<a href="https://unicode-org.github.io/cldr-staging/charts/latest/supplemental/language_plural_rules.html">Language Plural Rules</a>。</li></ul></li></ul><h2 id="实战经验"><a href="#实战经验" class="headerlink" title="实战经验"></a>实战经验</h2><ol><li><code>Localized Format Key</code>是一个语句，其中可以包含1个或1个以上的复数，每个都用<code>%#@</code>和<code>@</code>包围。</li><li>每增加一个需要翻译的名词复数就要增加一个<code>Localized String Key</code>。</li><li>设置<code>.stringsdict</code>文件的多语言<ol><li>点击<code>Localizable.stringsdict</code>文件</li><li>点击右上角文件检视器，选中第一个选项<code>the File inspector</code></li><li>在Localization中增加、减少语言。</li></ol></li></ol><div style="display:flex;justify-content:space-evenly;">    <img src="../../images/localize-noun-plural/stringsdict-chinese.png" alt="中文">    <img src="../../images/localize-noun-plural/stringsdict-english.png" alt="英文"></div><p>上面是在中英文下对<em>iOS开发栈有n个粉丝</em>和<em>iOS开发栈有n篇文章和m次分享</em>的翻译。对这两个翻译的使用方法如下：</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> fansNumLocalizableString <span class="operator">=</span> <span class="type">NSLocalizedString</span>(<span class="string">&quot;fans num in my offical account&quot;</span>, comment: <span class="string">&quot;The Fans Number of 【ios开发栈】&quot;</span>)</span><br><span class="line"><span class="keyword">let</span> fanNumStr <span class="operator">=</span> <span class="type">String</span>.localizedStringWithFormat(fansNumLocalizableString, <span class="number">3</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> offcialAccountInfo <span class="operator">=</span> <span class="type">NSLocalizedString</span>(<span class="string">&quot;official account info&quot;</span>, comment: <span class="string">&quot;&quot;</span>)</span><br><span class="line"><span class="keyword">let</span> accountInfoStr <span class="operator">=</span> <span class="type">String</span>.localizedStringWithFormat(offcialAccountInfo, <span class="number">10</span>, <span class="number">5</span>)</span><br></pre></td></tr></table></figure><div class="note info"><p>到公众号【iOS开发栈】学习更多SwiftUI、iOS开发相关内容。</p></div><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>通过这篇文章我们了解了为什么要对名词复数的国际化进行单独处理，和stringsdict文件的用法，相信你已经对名词复数的国际化有所了解，现在就去动手试试吧～</p>]]></content>
    
    
    <summary type="html">&lt;p&gt;iOS项目国际化过程中对【名词复数】的处理方法和对其他文字的处理方法有些不同之处，这篇文章将从下面几个方面讲解一下项目中怎么处理名词复数。&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;什么不能像对其他语句一样对名词复数进行处理？&lt;/li&gt;
&lt;li&gt;&lt;code&gt;.stringsdict&lt;/code&gt;文件的使用方法和说明&lt;/li&gt;
&lt;/ol&gt;</summary>
    
    
    
    
    <category term="Xcode" scheme="http://www.iosprogrammer.tech/tags/Xcode/"/>
    
    <category term="国际化" scheme="http://www.iosprogrammer.tech/tags/%E5%9B%BD%E9%99%85%E5%8C%96/"/>
    
  </entry>
  
  <entry>
    <title>iOS项目入口的演变过程（2021）</title>
    <link href="http://www.iosprogrammer.tech/ios/application-entry-point-changes/"/>
    <id>http://www.iosprogrammer.tech/ios/application-entry-point-changes/</id>
    <published>2021-05-05T13:47:33.000Z</published>
    <updated>2021-05-10T05:42:05.788Z</updated>
    
    <content type="html"><![CDATA[<p><code>UISceneDelegate</code>是什么，它和<code>AppDelegate</code>有什么关系，Swift中的<code>@main</code>又是什么，本文将带你一一了解。</p><p>这篇文章将主要讲解下面几点内容：</p><ol><li>iOS13之前的<code>AppDelegate</code>启动项目的流程</li><li><code>UISceneDelegate</code>的多窗口实现逻辑</li><li><code>UISceneDelegate</code>和<code>AppDelegate</code>的关系</li><li><code>int main()</code>和<code>@main</code></li></ol><a id="more"></a><div class="note info"><p>到公众号【iOS开发栈】学习更多SwiftUI、iOS开发相关内容。</p></div><p><img src="../../images/scene-delegate/first.png"></p><h1 id="单Window的AppDelegate"><a href="#单Window的AppDelegate" class="headerlink" title="单Window的AppDelegate"></a>单Window的AppDelegate</h1><p>在iOS13之前iPhone上的项目都是单windows的，AppDelegate中的<code>- (BOOL)application:(UIApplication *)application didFinishLaunchingWithOptions:(NSDictionary *)launchOptions</code>就是iOS项目启动后第一个会被调用的函数。</p><h2 id="纯代码在AppDelegate中启动App"><a href="#纯代码在AppDelegate中启动App" class="headerlink" title="纯代码在AppDelegate中启动App"></a>纯代码在AppDelegate中启动App</h2><p>AppDelegate中有一个<code>window</code>属性，需要自己来给windows指定一个<code>rootViewController</code>，在不使用storyboard或者xib的情况下，最简单的AppDelegate代码大概是下面这样子：</p><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// AppDelegate.h</span></span><br><span class="line"><span class="class"><span class="keyword">@interface</span> <span class="title">AppDelegate</span> : <span class="title">UIResponder</span> &lt;<span class="title">UIApplicationDelegate</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">@property</span> (<span class="keyword">nonatomic</span>) <span class="built_in">UIWindow</span> *window;</span><br><span class="line"></span><br><span class="line"><span class="keyword">@end</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// AppDelegate.m</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#import <span class="meta-string">&quot;AppDelegate.h&quot;</span></span></span><br><span class="line"><span class="meta">#import <span class="meta-string">&quot;ViewController.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">@interface</span> <span class="title">AppDelegate</span> ()</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">@end</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">@implementation</span> <span class="title">AppDelegate</span></span></span><br><span class="line"></span><br><span class="line">- (<span class="built_in">BOOL</span>)application:(<span class="built_in">UIApplication</span> *)application didFinishLaunchingWithOptions:(<span class="built_in">NSDictionary</span> *)launchOptions &#123;</span><br><span class="line">    <span class="comment">// Override point for customization after application launch.</span></span><br><span class="line">    <span class="keyword">self</span>.window = [[<span class="built_in">UIWindow</span> alloc] initWithFrame:[<span class="built_in">UIScreen</span> mainScreen].bounds];</span><br><span class="line">    <span class="keyword">self</span>.window.rootViewController = [[ViewController alloc] init];</span><br><span class="line">    <span class="keyword">self</span>.window.backgroundColor = [<span class="built_in">UIColor</span> whiteColor];</span><br><span class="line">    [<span class="keyword">self</span>.window makeKeyAndVisible];</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">YES</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">@end</span></span><br></pre></td></tr></table></figure><p><code>AppDelegate</code>遵守了<code>UIApplicationDelegate</code>协议，其中window是协议里规定的一个属性，所以这里必须在.h中声明这个属性，否则会报错<mark class="label danger">-[AppDelegate setWindow:]: unrecognized selector sent to instance</mark>；而如果放在.m中会报重复声明的错误<mark class="label danger">Illegal redeclaration of property in class extension AppDelegate (attribute must be readwrite, while its primary must be readonly)</mark>。</p><p>在<code>didFinishLaunchingWithOptions</code>中初始化window并设置它的<code>rootViewController</code>之后调用<code>makeKeyAndVisible</code>。</p><h2 id="Storyboard在AppDelegate中启动App"><a href="#Storyboard在AppDelegate中启动App" class="headerlink" title="Storyboard在AppDelegate中启动App"></a>Storyboard在AppDelegate中启动App</h2><p>如果是使用storyboard作为项目入口的话，AppDelegate就更简单了：</p><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">- (<span class="built_in">BOOL</span>)application:(<span class="built_in">UIApplication</span> *)application didFinishLaunchingWithOptions:(<span class="built_in">NSDictionary</span> *)launchOptions &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">YES</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>如果项目是使用Xcode11创建的那么要想试验这种方法需要 1. 删除info.plist中的<code>Application Scene Manifest</code> 2. 删除<code>SceneDelegate.h</code>和<code>SceneDelegate.m</code> 3. 删除<code>AppDelegate.m</code>中的两个SceneDelegate相关函数<code>application(_:configurationForConnecting:options:)</code>和<code>application(_:didDiscardSceneSessions:)</code> 4. 此时Xcode不会自动从Main.storyboard加载视图，我们需要通过修改<code>didFinishLaunchingWithOptions</code>来展示界面。</p></blockquote><h1 id="SceneDelegate"><a href="#SceneDelegate" class="headerlink" title="SceneDelegate"></a>SceneDelegate</h1><p>从Xcode11开始，创建新的iOS项目的模版中会带有<code>SceneDelegate</code>类，并且在plist文件中会有一个<code>Application Scene Manifest</code>配置，<code>AppDelegate.m</code>中新增了两个管理SceneDelegate的函数<code>application(_:configurationForConnecting:options:)</code>和<code>application(_:didDiscardSceneSessions:)</code>。</p><h2 id="iOS应用的进程生命周期和UI生命周期"><a href="#iOS应用的进程生命周期和UI生命周期" class="headerlink" title="iOS应用的进程生命周期和UI生命周期"></a>iOS应用的进程生命周期和UI生命周期</h2><p>App的进程生命周期包括App启动、App终止等，主要涉及的协议有：</p><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* UIApplicationDelegate */</span></span><br><span class="line">- (<span class="keyword">void</span>)applicationDidFinishLaunching:(<span class="built_in">UIApplication</span> *)application;</span><br><span class="line">- (<span class="built_in">BOOL</span>)application:(<span class="built_in">UIApplication</span> *)application willFinishLaunchingWithOptions:(<span class="keyword">nullable</span> <span class="built_in">NSDictionary</span>&lt;<span class="built_in">UIApplicationLaunchOptionsKey</span>, <span class="keyword">id</span>&gt; *)launchOptions API_AVAILABLE(ios(<span class="number">6.0</span>));</span><br><span class="line">- (<span class="built_in">BOOL</span>)application:(<span class="built_in">UIApplication</span> *)application didFinishLaunchingWithOptions:(<span class="keyword">nullable</span> <span class="built_in">NSDictionary</span>&lt;<span class="built_in">UIApplicationLaunchOptionsKey</span>, <span class="keyword">id</span>&gt; *)launchOptions API_AVAILABLE(ios(<span class="number">3.0</span>));</span><br><span class="line">- (<span class="keyword">void</span>)applicationWillTerminate:(<span class="built_in">UIApplication</span> *)application;</span><br></pre></td></tr></table></figure><p>App退到后台或者重新进入前台的过程属于UI生命周期，其中主要涉及的协议有：</p><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* UIApplicationDelegate */</span></span><br><span class="line">- (<span class="keyword">void</span>)applicationDidBecomeActive:(<span class="built_in">UIApplication</span> *)application;</span><br><span class="line">- (<span class="keyword">void</span>)applicationWillResignActive:(<span class="built_in">UIApplication</span> *)application;</span><br></pre></td></tr></table></figure><h2 id="SceneDelegate是什么"><a href="#SceneDelegate是什么" class="headerlink" title="SceneDelegate是什么"></a>SceneDelegate是什么</h2><p><img src="../../images/scene-delegate/ios12-appdelegate.png" alt="iOS12之前AppDelegate的作用"></p><p>在iOS13之前，iOS项目只有一个主Window，那时候的进程生命周期和UI生命周期都在<code>APPDelegate</code>中进行管理。</p><p>在iOS13之后，为了增强iOS项目的可用性一个App可以有多个window来显示不同或相同的内容。双击设备的Home键后每一个window会独立展示。</p><p><img src="../../images/scene-delegate/sample-image.png" alt="sceneDelegate示例"></p><p><strong>多窗口特性只有在iPad上才可以用</strong>，iPhone上面是不行的。具体的使用方法和例子可以查看这篇<a href="https://developer.apple.com/documentation/uikit/uiscenedelegate/supporting_multiple_windows_on_ipad">苹果的官方文档</a>。</p><p>为了管理不同窗口的生命周期，苹果添加了<code>UIWindowSceneDelegate</code>协议，而<code>SceneDelegate</code>类实现了这个协议的方法，因此<strong>SceneDelegate类是用来管理iOS应用窗口的生命周期的</strong>，也就是应用界面的生命周期。</p><h2 id="SceneDelegate和AppDelegate的关系"><a href="#SceneDelegate和AppDelegate的关系" class="headerlink" title="SceneDelegate和AppDelegate的关系"></a>SceneDelegate和AppDelegate的关系</h2><p>在推出<code>SceneDelegate</code>之前，整个应用的生命周期和UI生命周期都是依赖AppDelegate进行管理，在这之后，UI生命周期交给了SceneDelegate来管理，而AppDelegate就用来管理应用的生命周期和SceneDelegate的生命周期。</p><p><img src="../../images/scene-delegate/appdelegate-scenedelegate.png" alt="AppDelegate和SceneDelegate的关系"></p><p>App的启动和杀死的回调仍然在AppDelegate中，除此之外在创建iOS项目的模版中，AppDelegate中增加了对SceneDelegate管理的两个方法：</p><ul><li><code>application:configurationForConnectingSceneSession:options:</code> 当窗口建立时会被调用。</li><li><code>application:didDiscardSceneSessions:sceneSessions</code>。 当窗口被永久销毁时被调用</li></ul><p>SceneDelegate中对App的某个窗口的动作进行管理：</p><table><thead><tr><th></th><th></th></tr></thead><tbody><tr><td><code>scene:willConnectToSession:options:connectionOptions</code></td><td><code>sceneDidDisconnect:</code></td></tr><tr><td><code>sceneDidBecomeActive:</code></td><td><code>sceneWillResignActive:</code></td></tr><tr><td><code>sceneWillEnterForeground:</code></td><td><code>sceneDidEnterBackground:</code></td></tr></tbody></table><p>这里的方法都是对称出现的，基本也都是和之前在AppDelegate中的相关功能的方法很类似。</p><p><strong>SceneDelegate承接了部分AppDelegate的功能，而AppDelegate重点用来对应用生命周期就进行管理，SceneDelegate用来管理UI生命周期。</strong></p><h1 id="int-main-和-main"><a href="#int-main-和-main" class="headerlink" title="int main()和@main"></a><code>int main()</code>和<code>@main</code></h1><p>在Objc项目中存在一个<code>main.m</code>文件，里面的main函数是项目的启动函数。</p><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> main(<span class="keyword">int</span> argc, <span class="keyword">char</span> * argv[]) &#123;</span><br><span class="line">    <span class="built_in">NSString</span> * appDelegateClassName;</span><br><span class="line">    <span class="keyword">@autoreleasepool</span> &#123;</span><br><span class="line">        <span class="comment">// Setup code that might create autoreleased objects goos here.</span></span><br><span class="line">        appDelegateClassName = <span class="built_in">NSStringFromClass</span>([AppDelegate <span class="keyword">class</span>]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">UIApplicationMain</span>(argc, argv, <span class="literal">nil</span>, appDelegateClassName);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在Swift中，项目入口使用<code>@main</code>作为标记，作用和上面的C语言函数是一样的。</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* AppDelegate.swift */</span></span><br><span class="line"><span class="keyword">@main</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">AppDelegate</span></span></span><br></pre></td></tr></table></figure><p>通过添加<code>@main</code>标记，编译器会自动生成项目入口相关代码，并把<code>AppDelegate</code>的类名传递进去。</p><div class="note info"><p>到公众号【iOS开发栈】学习更多SwiftUI、iOS开发相关内容。</p></div><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>这篇文章我们对iOS项目的启动入口进行了一次回顾和深入了解，相信你对iOS项目的发展有了一个更加清晰的认识。</p><p>感谢你的阅读💗。</p>]]></content>
    
    
    <summary type="html">&lt;p&gt;&lt;code&gt;UISceneDelegate&lt;/code&gt;是什么，它和&lt;code&gt;AppDelegate&lt;/code&gt;有什么关系，Swift中的&lt;code&gt;@main&lt;/code&gt;又是什么，本文将带你一一了解。&lt;/p&gt;
&lt;p&gt;这篇文章将主要讲解下面几点内容：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;iOS13之前的&lt;code&gt;AppDelegate&lt;/code&gt;启动项目的流程&lt;/li&gt;
&lt;li&gt;&lt;code&gt;UISceneDelegate&lt;/code&gt;的多窗口实现逻辑&lt;/li&gt;
&lt;li&gt;&lt;code&gt;UISceneDelegate&lt;/code&gt;和&lt;code&gt;AppDelegate&lt;/code&gt;的关系&lt;/li&gt;
&lt;li&gt;&lt;code&gt;int main()&lt;/code&gt;和&lt;code&gt;@main&lt;/code&gt;&lt;/li&gt;
&lt;/ol&gt;</summary>
    
    
    
    
    <category term="iOS" scheme="http://www.iosprogrammer.tech/tags/iOS/"/>
    
  </entry>
  
  <entry>
    <title>推荐！iOS应用使用Assets.xcassets进行图片国际化的2种方法</title>
    <link href="http://www.iosprogrammer.tech/xcode/localize-images/"/>
    <id>http://www.iosprogrammer.tech/xcode/localize-images/</id>
    <published>2021-05-01T06:38:38.000Z</published>
    <updated>2021-05-01T09:52:27.955Z</updated>
    
    <content type="html"><![CDATA[<p>iOS应用的国际化除了文字以外还需要对一些本地使用的资源进行国际化，这篇文章将分享一些关于Image图片国际化的方案。</p><p>主要包括iOS应用图片国际化有两种方法：</p><ol><li>Assets.xcassets中同一个ImageSet包含不同的本地化图片</li><li>使用名称不同的ImageSet</li></ol><a id="more"></a><div class="note info"><p>到公众号【iOS开发栈】学习更多SwiftUI、iOS开发相关内容。</p></div><p><img src="../../images/image-localize/first.png"></p><h1 id="同一个ImageSet包含不同的本地化图片"><a href="#同一个ImageSet包含不同的本地化图片" class="headerlink" title="同一个ImageSet包含不同的本地化图片"></a>同一个ImageSet包含不同的本地化图片</h1><p><img src="../../images/image-localize/1.png" alt="iOS图片本地化设置"></p><p>按照正常流程把一张png图片添加到Assets.xcassets中以后，选中其中任意一张图片然后就可以在Inspector的第四栏Attribute Inspector中看到<strong>Localization</strong>选项，点击后会出现项目中已经国际化的语言。<em>（添加语言的方法可以查看<a href="https://www.iosprogrammer.tech/xcode/language-internalization-ib/#%E5%AE%8C%E6%95%B4%E4%BA%86%E8%A7%A3%E5%9B%BD%E9%99%85%E5%8C%96%E6%AD%A5%E9%AA%A4">完整了解国际化步骤</a>）</em></p><p>在<em>Localization</em>中选中的语言就是要单独设置图片的语言，如果单独设置的语言图片是空的就会自动选择用第一个（Universal）的图片。</p><p>我的这个项目里有简体中文和英文两种语言，并且对avatar这个图片的中文设置了单独图片。当我在设置中切换简体中文和英文时图片就会被切换了。</p><h1 id="使用名称不同的ImageSet"><a href="#使用名称不同的ImageSet" class="headerlink" title="使用名称不同的ImageSet"></a>使用名称不同的ImageSet</h1><p>在Assets.xcassets中分别创建两个ImageSet，然后在ImageNamed中使用NSLocalizedString来设置图片名字。</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">avatarImageView.image <span class="operator">=</span> <span class="type">UIImage</span>(named: <span class="type">NSLocalizedString</span>(<span class="string">&quot;avatarImageName&quot;</span>, comment: <span class="string">&quot;This is the avatar image&#x27;s name&quot;</span>))</span><br></pre></td></tr></table></figure><p><code>NSLocalizedString()</code>宏中的第一个参数是多语言的key，而comment是用来生成多语言注释的，更深入的了解可以查看<a href="https://www.iosprogrammer.tech/xcode/international-user-facing-text/#%E6%A0%87%E8%AE%B0%E9%9C%80%E8%A6%81%E6%9C%AC%E5%9C%B0%E5%8C%96%E7%9A%84%E6%96%87%E6%9C%AC">标记需要本地化的文本</a></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; Localization.strings(English)</span><br><span class="line">&quot;avatarImageName&quot; &#x3D; &quot;avatar-en&quot;;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; Localization.strings((Chinese, Simplified))</span><br><span class="line">&quot;avatarImageName&quot; &#x3D; &quot;avatar-ch&quot;;</span><br></pre></td></tr></table></figure><p>分别在中文简体和英文的Localization.strings的多语言文件中添加对应的图片文件名。</p><p>之后分别在不同的语言环境下运行项目就可以看到不同的图片了。</p><div class="note info"><p>到公众号【iOS开发栈】学习更多SwiftUI、iOS开发相关内容。</p></div><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>通过上面的2种方法可以将图片进行本地化处理，其中第二种方法也可以用于<code>UIImage(contentsOfFile:)</code>方法。</p>]]></content>
    
    
    <summary type="html">&lt;p&gt;iOS应用的国际化除了文字以外还需要对一些本地使用的资源进行国际化，这篇文章将分享一些关于Image图片国际化的方案。&lt;/p&gt;
&lt;p&gt;主要包括iOS应用图片国际化有两种方法：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;Assets.xcassets中同一个ImageSet包含不同的本地化图片&lt;/li&gt;
&lt;li&gt;使用名称不同的ImageSet&lt;/li&gt;
&lt;/ol&gt;</summary>
    
    
    
    
    <category term="Xcode" scheme="http://www.iosprogrammer.tech/tags/Xcode/"/>
    
    <category term="国际化" scheme="http://www.iosprogrammer.tech/tags/%E5%9B%BD%E9%99%85%E5%8C%96/"/>
    
  </entry>
  
  <entry>
    <title>你应该知道的！关于SwiftUI中导航栏的4点知识</title>
    <link href="http://www.iosprogrammer.tech/swiftui/swiftui-navigate-get-start-tutorial/"/>
    <id>http://www.iosprogrammer.tech/swiftui/swiftui-navigate-get-start-tutorial/</id>
    <published>2021-04-23T00:44:11.000Z</published>
    <updated>2021-04-23T07:54:35.832Z</updated>
    
    <content type="html"><![CDATA[<p>得益于SwiftUI的声明式编程方式进行页面切换是非常方便的，这篇文章将对SwiftUI中的导航功能进行一个全面的了解，主要会涉及到这几个方面：</p><ol><li>NavigatinView的使用方法以及对应API的讲解</li><li>NavigationLink的使用方法</li><li>实现POP会上一级页面的效果</li><li>Xcode12的实时预览导航栏</li></ol><a id="more"></a><div class="note info"><p>到公众号【iOS开发栈】学习更多SwiftUI、iOS开发相关内容。</p></div><p><img src="../../images/first/swiftui-navigate.png"></p><h1 id="NavigationView"><a href="#NavigationView" class="headerlink" title="NavigationView"></a>NavigationView</h1><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">NavigationView</span> &#123;</span><br><span class="line">    <span class="type">Text</span>(<span class="string">&quot;Hellow World&quot;</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如上所示，将一个View包裹在<code>NavigationView</code>中，当前这个body就是一个“导航控制器”了，关于这种写法的说明可以查看我之前的<a href="https://www.iosprogrammer.tech/swiftui/swiftui-concept-essential/">学习SwiftUI，必须掌握的3个知识点</a>中的View部分。</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">NavigationView</span> &#123;</span><br><span class="line">    <span class="type">Text</span>(<span class="string">&quot;Hellow World&quot;</span>)</span><br><span class="line">        .navigationTitle(<span class="string">&quot;公众号：iOS开发栈&quot;</span>) <span class="comment">// 或者使用 navigationBarTitle</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>通过给NavagationView内部的Content设置<em>navigationTitle</em>修改器可以设置导航栏的标题。</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">.navigationBarTitleDisplayMode(.inline)</span><br></pre></td></tr></table></figure><p>通过设置<code>navigationBarTitleDisplayMode</code>修改器可以更改导航栏标题的展现样式，<em>inline</em>是居中展示并且导航栏高度是固定的44pt；<em>large</em>是在iOS前几个版本新引入的样式，这种样式默认是把标题显示在左上角并且字体加粗加大，随着屏幕的滚动导航栏的高度也会变化；<code>automic</code>是会和导航栈的上一个页面保持相同。</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">.navigationBarTitle(<span class="string">&quot;公众号：iOS开发栈&quot;</span>, displayMode: .inline)</span><br></pre></td></tr></table></figure><p>通过设置<code>navigationBarTitle</code>修改器可以将上面两个修改器合并成一个。</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">.navigationBarHidden()</span><br></pre></td></tr></table></figure><p>通过使用<code>navigationBarHidden</code>可以动态控制是否展示导航栏，结合<code>@State</code>的使用可以实现动态显示或者隐藏导航栏的效果了。</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">.navigationBarItems(leading:, trailing:)</span><br></pre></td></tr></table></figure><p>使用<code>navigationBarItems</code>可以给导航栏的左、右添加按钮，而且因为leading和trailing的类型都是View的，所以你可以很方便的添加文字、图片、图文等。</p><h1 id="NavigationLink"><a href="#NavigationLink" class="headerlink" title="NavigationLink"></a>NavigationLink</h1><p>上面创建出了一个navigationView了，下面来看一下怎么实现跳转。</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">NavigationLink</span>(<span class="string">&quot;界面跳转&quot;</span>, destination: <span class="type">Text</span>(<span class="string">&quot;公众号：iOS开发栈&quot;</span>))</span><br><span class="line">                </span><br><span class="line"><span class="type">NavigationLink</span>(destination: <span class="type">Text</span>(<span class="string">&quot;公众号：iOS开发栈&quot;</span>), label: &#123;</span><br><span class="line">        <span class="type">Text</span>(<span class="string">&quot;界面跳转&quot;</span>)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><p>这两种创建方式的效果是一样的，最终都是通过点击“界面跳转”的文字以后跳转到一个只有“公众号：iOS开发栈”的新页面。</p><h1 id="实现POP回上一级页面的效果"><a href="#实现POP回上一级页面的效果" class="headerlink" title="实现POP回上一级页面的效果"></a>实现POP回上一级页面的效果</h1><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// ContentView.swift</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">ContentView</span>: <span class="title">View</span> </span>&#123;</span><br><span class="line">    <span class="meta">@State</span> <span class="keyword">var</span> pushActive <span class="operator">=</span> <span class="literal">false</span></span><br><span class="line">    <span class="keyword">var</span> body: <span class="keyword">some</span> <span class="type">View</span> &#123;</span><br><span class="line">        <span class="type">NavigationView</span> &#123;</span><br><span class="line">            <span class="type">VStack</span> &#123;</span><br><span class="line">                <span class="type">NavigationLink</span>(<span class="string">&quot;跳转并返回&quot;</span>, destination: <span class="type">SecondView</span>(pushActive: <span class="variable">$pushActive</span>), isActive: <span class="variable">$pushActive</span>)</span><br><span class="line">            &#125;</span><br><span class="line">            .navigationTitle(<span class="string">&quot;公众号：iOS开发栈&quot;</span>)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// SecondView.swift</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">SecondView</span>: <span class="title">View</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Binding</span> <span class="keyword">var</span> pushActive: <span class="type">Bool</span></span><br><span class="line">    <span class="keyword">var</span> body: <span class="keyword">some</span> <span class="type">View</span> &#123;</span><br><span class="line">        <span class="type">Button</span>(<span class="string">&quot;返回&quot;</span>) &#123;</span><br><span class="line">            pushActive <span class="operator">=</span> <span class="literal">false</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>使用一个@State属性绑定到<code>NavigationLink</code>的初始化方法中的<code>isActive</code>参数，这样就会根据<code>pushActive</code>的Bool值来push和pop视图，如果默认设置成true那启动app后就会直接切换到SecondView。</p><p>把pushActive参数传递到SecondView以后通过在SecondView中修改这个参数的值，就可以实现返回上一级的效果。其中关于@State和@Bind的用法可以看一下<a href="(https://www.iosprogrammer.tech/swiftui/swiftui-data-flow">详解SwiftUI数据流是怎么在View间传递的</a>。</p><h1 id="Xcode12的实时预览导航栏"><a href="#Xcode12的实时预览导航栏" class="headerlink" title="Xcode12的实时预览导航栏"></a>Xcode12的实时预览导航栏</h1><p>在Xcode12中，对于SwiftUI的文件，我们可以通过打开Cavas（option+cmd+enter）来查看实时预览的界面，这是一个非常好用的功能。虽然有很多的局限性，不够也终于让iOS开发者品尝到了Web或者Android待遇了。感谢苹果爸爸🙏</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">SecondView_Previews</span>: <span class="title">PreviewProvider</span> </span>&#123;</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">var</span> previews: <span class="keyword">some</span> <span class="type">View</span> &#123;</span><br><span class="line">        <span class="type">SecondView</span>(pushActive: .constant(false))</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>创建SwiftUI的文件后默认会带有一个遵守了<code>PreviewProvider</code>协议并且以<em>_Previews</em>结尾的结构体，有了它就有了对界面的实时预览能力。</p><p>要想预览导航栏的push和pop效果需要在这个结构体中进行修改。</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">SecondView_Previews</span>: <span class="title">PreviewProvider</span> </span>&#123;</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">var</span> previews: <span class="keyword">some</span> <span class="type">View</span> &#123;</span><br><span class="line">        <span class="type">NavigationView</span> &#123;</span><br><span class="line">            <span class="type">SecondView</span>(pushActive: .constant(false))</span><br><span class="line">                .navigationTitle(<span class="string">&quot;公众号：iOS开发栈&quot;</span>)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>通过在预览结构体中增加一个NavigationView就可以在导航栈的次级页面实时预览带有导航条的效果。</p><div class="note info"><p>到公众号【iOS开发栈】学习更多SwiftUI、iOS开发相关内容。</p></div><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>这篇文章涵盖了NavigationView和NavigationLink的基础用法和常用API的讲解，又提到了在实战应用中会遇到了一些进阶需求以及提升开发效率的预览功能用法。</p><p>🎉 你已经掌握了SwiftUI框架中关于导航栏的知识，现在可以动手试试做一个带有导航控制的应用了。</p>]]></content>
    
    
    <summary type="html">&lt;p&gt;得益于SwiftUI的声明式编程方式进行页面切换是非常方便的，这篇文章将对SwiftUI中的导航功能进行一个全面的了解，主要会涉及到这几个方面：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;NavigatinView的使用方法以及对应API的讲解&lt;/li&gt;
&lt;li&gt;NavigationLink的使用方法&lt;/li&gt;
&lt;li&gt;实现POP会上一级页面的效果&lt;/li&gt;
&lt;li&gt;Xcode12的实时预览导航栏&lt;/li&gt;
&lt;/ol&gt;</summary>
    
    
    
    
    <category term="SwiftUI" scheme="http://www.iosprogrammer.tech/tags/SwiftUI/"/>
    
  </entry>
  
  <entry>
    <title>SwiftUI中Image自适应大小AspectFill、AspectFit</title>
    <link href="http://www.iosprogrammer.tech/swiftui/swiftui-image-fill-fit-mode/"/>
    <id>http://www.iosprogrammer.tech/swiftui/swiftui-image-fill-fit-mode/</id>
    <published>2021-04-16T01:30:16.000Z</published>
    <updated>2021-04-16T03:40:50.576Z</updated>
    
    <content type="html"><![CDATA[<p>SwiftUI中想要让Image能够实现类似于UIViewContentModeAspectFit或者ApectFill的效果需要把两个<a href="https://www.iosprogrammer.tech/swiftui/swiftui-concept-essential/">修改器(modifier)</a>结合起来使用。</p><a id="more"></a><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">Image</span>(<span class="string">&quot;xxx&quot;</span>)</span><br><span class="line">    .resizable(resizingMode: .stretch)</span><br><span class="line">    .aspectRatio(contentMode: .fit)</span><br></pre></td></tr></table></figure><p><code>func resizable(capInsets:, resizingMode:)</code>对应的是UIImage的<code>resizableImageWithCapInsets:resizingMode:</code>。<code>capInsets</code>确定了不被拉伸影响的上下左右四边距，四边距以外的部分会被<code>resizingMode</code>影响。<code>Image.ResizingMode.stretch</code>铺满整个空间，会发生形变,<code>Image.ResizingMode.stretch</code>平铺，也就是说如果图片的大小不足以占满空间就把图片复制多份，如果图片比空间大只会展示出来和空间一样大的部分并且图片的左上角和容器的左上角对齐，其他部分会被裁掉。</p><p><code>aspectRatio(_ aspectRatio:,contentMode:)</code>修改器设置长宽比和填充方式，<code>aspectRatio</code>参数是视图的<em>长:宽</em>，<code>contentMode</code>是填充方式其中Fill表示填满空间，长边会超出容器，Fit会保证长边填满空间短边会留出空白。</p><p><strong>据我观察，单独对Image使用aspectRatio修改器没有效果，需要结合<code>resizable</code>修改器才行。</strong></p><div class="note info"><p>到公众号【iOS开发栈】学习更多SwiftUI、iOS开发相关内容。</p></div>]]></content>
    
    
    <summary type="html">&lt;p&gt;SwiftUI中想要让Image能够实现类似于UIViewContentModeAspectFit或者ApectFill的效果需要把两个&lt;a href=&quot;https://www.iosprogrammer.tech/swiftui/swiftui-concept-essential/&quot;&gt;修改器(modifier)&lt;/a&gt;结合起来使用。&lt;/p&gt;</summary>
    
    
    
    
    <category term="SwiftUI" scheme="http://www.iosprogrammer.tech/tags/SwiftUI/"/>
    
  </entry>
  
  <entry>
    <title>SwiftUI自定义Modifier</title>
    <link href="http://www.iosprogrammer.tech/swiftui/swiftui-custom-modifier/"/>
    <id>http://www.iosprogrammer.tech/swiftui/swiftui-custom-modifier/</id>
    <published>2021-04-14T00:47:13.000Z</published>
    <updated>2021-04-14T01:16:39.832Z</updated>
    
    <content type="html"><![CDATA[<p>SwiftUI中已经自带了很多<a href="https://www.iosprogrammer.tech/swiftui/swiftui-concept-essential/">Modifier</a>，使用这些自带的modifier可以满足我们的大多数需求。有些情况下为了方便使用或者统一风格，我们还想要给View增加自己的Modifier。</p><a id="more"></a><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">CustomModifier</span>: <span class="title">ViewModifier</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">func</span> <span class="title">body</span><span class="params">(content: Content)</span></span> -&gt; <span class="keyword">some</span> <span class="type">View</span> &#123;</span><br><span class="line">        content</span><br><span class="line">            .background(<span class="type">Color</span>.yellow)</span><br><span class="line">            .cornerRadius(<span class="number">10</span>)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>遵守<code>ViewModifier</code>即可创建自定义的modifier。</p><p>modifier并不是对原来view的修改，而是创建了一个新的view，具体可以参考我之前的<a href="https://www.iosprogrammer.tech/swiftui/swiftui-concept-essential/">这篇文章</a>。</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">Text</span>(<span class="string">&quot;iOS开发栈&quot;</span>)</span><br><span class="line">    .modifier(customModifier())</span><br></pre></td></tr></table></figure><p><code>modier(:)</code>方法是View的一个扩展方法，通过这个方法可以让一个view通过应用modier来返回一个新的view，这也证实了上面提到的。</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">extension</span> <span class="title">View</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">func</span> <span class="title">customModifier</span><span class="params">()</span></span> -&gt; <span class="keyword">some</span> <span class="type">View</span> &#123;</span><br><span class="line">        <span class="keyword">self</span>.modifier(<span class="type">CustomModifier</span>())</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>通过给View添加一个扩展方法就可以像使用系统方法那样调用我们自己添加的modifier了。</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">Text</span>(<span class="string">&quot;iOS开发栈&quot;</span>)</span><br><span class="line">    .customModifier()</span><br></pre></td></tr></table></figure><p>当然，我们也可以给自定义的Modifier添加参数，来实现更为复杂的效果。</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">CustomModifier</span>: <span class="title">ViewModifier</span> </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> cornerRadius: <span class="type">CGFloat</span></span><br><span class="line">    <span class="function"><span class="keyword">func</span> <span class="title">body</span><span class="params">(content: Content)</span></span> -&gt; <span class="keyword">some</span> <span class="type">View</span> &#123;</span><br><span class="line">        content</span><br><span class="line">            .background(<span class="type">Color</span>.yellow)</span><br><span class="line">            .cornerRadius(cornerRadius)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">extension</span> <span class="title">View</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">func</span> <span class="title">customModifier</span><span class="params">(cornerRadius: CGFloat)</span></span> -&gt; <span class="keyword">some</span> <span class="type">View</span> &#123;</span><br><span class="line">        <span class="keyword">self</span>.modifier(<span class="type">CustomModifier</span>(cornerRadius: cornerRadius))</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">ContentView</span>: <span class="title">View</span> </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> body: <span class="keyword">some</span> <span class="type">View</span> &#123;</span><br><span class="line">        <span class="type">VStack</span> &#123;</span><br><span class="line">            <span class="type">Text</span>(<span class="string">&quot;iOS开发栈&quot;</span>)</span><br><span class="line">                .customModifier(cornerRadius: <span class="number">10</span>)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><div class="note info"><p>到公众号【iOS开发栈】学习更多SwiftUI、iOS开发相关内容。</p></div>]]></content>
    
    
    <summary type="html">&lt;p&gt;SwiftUI中已经自带了很多&lt;a href=&quot;https://www.iosprogrammer.tech/swiftui/swiftui-concept-essential/&quot;&gt;Modifier&lt;/a&gt;，使用这些自带的modifier可以满足我们的大多数需求。有些情况下为了方便使用或者统一风格，我们还想要给View增加自己的Modifier。&lt;/p&gt;</summary>
    
    
    
    
    <category term="SwiftUI" scheme="http://www.iosprogrammer.tech/tags/SwiftUI/"/>
    
  </entry>
  
  <entry>
    <title>iOS本地化日期、时间、货币数字（超全）</title>
    <link href="http://www.iosprogrammer.tech/xcode/international-data-format/"/>
    <id>http://www.iosprogrammer.tech/xcode/international-data-format/</id>
    <published>2021-04-11T02:44:40.000Z</published>
    <updated>2021-05-01T06:46:21.625Z</updated>
    
    <content type="html"><![CDATA[<p>不同的国家、地区对一些诸如日期、时间、数字、货币等方面有不同的表述方式，为了更好的满足当地人的使用习惯和习俗，App必须做好这些方面的国际化工作。这是一项重要且复杂的工作，希望通过这篇可以让你对这些内容有一个全面的了解。</p><a id="more"></a><div class="note info"><p>到公众号【iOS开发栈】学习更多SwiftUI、iOS开发相关内容。</p></div><p><img src="../../images/international-data-format/cover.png" alt="iOS app 日期和数字的本地化"></p><p>之前两篇关于iOS国际化的文章讨论了关于<a href="https://www.iosprogrammer.tech/xcode/language-internalization-ib/">使用IB将固定UI国际化</a>和<a href="https://www.iosprogrammer.tech/xcode/international-user-facing-text/">使用NSLocalizeString宏将可变文本国际化</a>，这篇文章将集中于处理一些日常表述方面的国际化问题，比如日期、时间、数字、货币等。</p><p>首先要明确一点，这里的本地化并不是完全依赖于语言的，也就是说同样的语言在本地化方面也会有不同的表现形式。比如说意大利和美国都是英语国家但是在美国数字使用的“,”分割，而意大利使用的是“.”，又对于货币符号就更多了。</p><p>在iPhone和Mac上都有地区的选择，在对应页面的下方就是一些示例。</p><p><img src="../../images/international-data-format/mac-region-pannel.png" alt="Mac地区选择示例"></p><p>在开发过程中还有一个快速修改所在区域的小技巧，在Edit Scheme -&gt; Options中修改App Region然后重新运行项目就可以修改所在区域了，这样就不需要每次到系统设置中去修改区域。</p><h1 id="获取当前系统的本地化信息"><a href="#获取当前系统的本地化信息" class="headerlink" title="获取当前系统的本地化信息"></a>获取当前系统的本地化信息</h1><ol><li>获取Locale对象</li></ol><p>可以通过两种方法获取到用户的本地化对象<code>Locale.current</code>和<code>Locale.autoupdatingCurrent</code>，官方文档说autoupdatingCurrent会随着系统设置的更改而改变，current是固定的。</p><p>但是我并没有发现这两者的区别，当用户修改系统语言或者所在地区以后所有app都会重启，不管使用那种方式都会重新获取最新的系统设置，而如果只是修改日历的话app不会重启但是<code>autoupdatingCurrent</code>方法获取到的locale也不会改变。</p><p>我不知道这是由于官方文档没有及时更新还是由于我没有找到这两个方法之间的区别，如果你知道他们的区别麻烦告诉我。</p><ol start="2"><li>获取Locale对象包含的本地化信息</li></ol><p>本地化信息会随着语言、地域、文化的不同而不同，总共包含了大概十几个条目，下面列举几个比较常用的条目并且以大陆地区为例来给出结果。</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 以中国大陆地区为例</span></span><br><span class="line"><span class="keyword">let</span> currentLocale <span class="operator">=</span> <span class="type">Locale</span>.autoupdatingCurrent</span><br><span class="line">currentLocale.identifier <span class="comment">// zh_CN</span></span><br><span class="line">currentLocale.languageCode <span class="operator">??</span> <span class="string">&quot;&quot;</span> <span class="comment">// zh</span></span><br><span class="line">currentLocale.regionCode <span class="operator">??</span> <span class="string">&quot;&quot;</span> <span class="comment">// CN</span></span><br><span class="line">currentLocale.scriptCode <span class="operator">??</span> <span class="string">&quot;&quot;</span> <span class="comment">// &quot;&quot;</span></span><br><span class="line">currentLocale.variantCode <span class="operator">??</span> <span class="string">&quot;&quot;</span> <span class="comment">// &quot;&quot;</span></span><br><span class="line">currentLocale.calendar <span class="comment">// gregorian (current)</span></span><br><span class="line">currentLocale.usesMetricSystem <span class="comment">// true</span></span><br><span class="line">currentLocale.currencySymbol <span class="operator">??</span> <span class="string">&quot;&quot;</span> <span class="comment">// ¥</span></span><br><span class="line">currentLocale.currencyCode <span class="operator">??</span> <span class="string">&quot;&quot;</span> <span class="comment">// CNY</span></span><br><span class="line">currentLocale.quotationBeginDelimiter <span class="operator">??</span> <span class="string">&quot;&quot;</span> <span class="comment">// “ 前引号</span></span><br><span class="line">currentLocale.quotationEndDelimiter <span class="operator">??</span> <span class="string">&quot;&quot;</span> <span class="comment">// ” 后引号</span></span><br></pre></td></tr></table></figure><ol start="3"><li>获取当前语言和方言</li></ol><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> languageId <span class="operator">=</span> <span class="type">Bundle</span>.main.preferredLocalizations.first<span class="operator">!</span> <span class="comment">// zh-Hans</span></span><br><span class="line"><span class="keyword">let</span> locale <span class="operator">=</span> <span class="type">Locale</span>.current</span><br><span class="line"><span class="keyword">let</span> languageName <span class="operator">=</span> locale.localizedString(forLanguageCode: languageId)<span class="operator">!</span> <span class="comment">// 中文</span></span><br></pre></td></tr></table></figure><p>这里的languageId是开发者需要的而不应该让用户看到，languageName是展示给用户的。</p><h1 id="格式化日期时间"><a href="#格式化日期时间" class="headerlink" title="格式化日期时间"></a>格式化日期时间</h1><ol><li>使用预设的格式</li></ol><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> date <span class="operator">=</span> <span class="type">DateFormatter</span>.localizedString(from: <span class="type">Date</span>(), dateStyle: .short, timeStyle: .short) <span class="comment">// 2021/4/11 下午9:15:16</span></span><br></pre></td></tr></table></figure><p>根据当前所在的Locale，将当前时间格式化，其中日期使用“短格式”、时间使用“中格式。下面是官方文档上面的一个对不同格式的示例：</p><table><thead><tr><th>Style</th><th>Date</th><th>Time</th><th>Description</th></tr></thead><tbody><tr><td>Short</td><td>6/10/13</td><td>11:03 AM</td><td>只有数字</td></tr><tr><td>Medium</td><td>Jun 10, 2013</td><td>11:03:15 AM</td><td>简短文本</td></tr><tr><td>Long</td><td>June 10, 2013</td><td>11:03:15 AM PDT</td><td>完整文本</td></tr><tr><td>Full</td><td>Friday, June 10, 2013</td><td>11:03:15 AM Pacific Daylight Time</td><td>更多细节</td></tr></tbody></table><p>下面是在不同的语言和地区中中长和短文本的时间格式：</p><table><thead><tr><th>Language (Region)</th><th>Medium style</th><th>Short style</th></tr></thead><tbody><tr><td>English (United States)</td><td>Jun 6, 2013</td><td>10:14 AM</td></tr><tr><td>French (France)</td><td>6 Jun 2013</td><td>10:14</td></tr><tr><td>Chinese (China)</td><td>2013年6月6日</td><td>上午10:14</td></tr></tbody></table><ol start="2"><li>使用自定义的日期和时间格式</li></ol><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> dateFormatter <span class="operator">=</span> <span class="type">DateFormatter</span>()</span><br><span class="line"><span class="keyword">let</span> formatterString <span class="operator">=</span> <span class="type">DateFormatter</span>.dateFormat(fromTemplate: <span class="string">&quot;MMM d&quot;</span>, options: <span class="number">0</span>, locale: dateFormatter.locale)<span class="operator">!</span>  <span class="comment">// 4月11日</span></span><br><span class="line"><span class="comment">//        let formaterString = &quot;MMM d&quot; // 4月 11</span></span><br><span class="line">dateFormatter.dateFormat <span class="operator">=</span> formatterString </span><br><span class="line"><span class="keyword">let</span> date2 <span class="operator">=</span> dateFormatter.string(from: <span class="type">Date</span>()) </span><br></pre></td></tr></table></figure><p>分两种方式创建formatterString，当使用<code>fromTemplate:options:locale</code>时得到的dateString是4月11日；直接使用普通文本时得到的dateString是4月11。</p><p>下面是几个不同语言和地区分别在使用和不使用地区格式化下的日期：</p><table><thead><tr><th>Language (Region)</th><th>Date using format string “MMM d”</th><th>Date using templat “dMMM”</th></tr></thead><tbody><tr><td>English (United States)</td><td>Nov 13</td><td>Nov 13</td></tr><tr><td>French (France)</td><td>nov. 13</td><td>13 nov.</td></tr><tr><td>Chinese (China)</td><td>11月13</td><td>11月13日｜</td></tr></tbody></table><h1 id="数字格式化"><a href="#数字格式化" class="headerlink" title="数字格式化"></a>数字格式化</h1><ol><li>使用预设样式格式化数字</li></ol><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> myNumber: <span class="type">NSNumber</span> <span class="operator">=</span> <span class="number">234231.231</span></span><br><span class="line"><span class="keyword">let</span> numberString <span class="operator">=</span> <span class="type">NumberFormatter</span>.localizedString(from: myNumber, number: .decimal)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;numberString = <span class="subst">\(numberString)</span>&quot;</span>) <span class="comment">// numberString = 234,231.231</span></span><br></pre></td></tr></table></figure><p>使用预设格式进行格式化数字时，在不同的语言和地区下的例子：</p><table><thead><tr><th>Style</th><th>Formatted string, <br> English (United States)</th><th>Formatted string,<br> Language (Region)</th></tr></thead><tbody><tr><td>Decimal（小数）</td><td>1,234.56</td><td>1.234,56 <br>Italian (Italy)</td></tr><tr><td>Currency（货币）</td><td>$1,234.56</td><td>¥1,234.56<br>Chinese (China)</td></tr><tr><td>Percent（百分数）</td><td>123,456%</td><td><img src="../../images/international-data-format/arabic_percent.svg" width="72.548" height="13.019"><br>Arabic (Egypt)</td></tr><tr><td>Scientific（科学计数法）</td><td>1.23456E+03</td><td>1,23456E3<br>Italian (Italy)</td></tr><tr><td>Spell Out（读）</td><td>one thousand two hundred thirty-four point five six</td><td>一千二百三十四点五六<br>Chinese (China)</td></tr></tbody></table><ol start="2"><li>获取用户输入的数字</li></ol><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> formatter <span class="operator">=</span> <span class="type">NumberFormatter</span>()</span><br><span class="line">formatter.numberStyle <span class="operator">=</span> .decimal</span><br><span class="line">formatter.isLenient <span class="operator">=</span> <span class="literal">true</span></span><br><span class="line"><span class="keyword">let</span> number <span class="operator">=</span> formatter.number(from: <span class="string">&quot;1,234,123.23&quot;</span>)<span class="operator">!</span></span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;number = <span class="subst">\(number)</span>&quot;</span>) <span class="comment">// number = 1234123.23</span></span><br></pre></td></tr></table></figure><p>使用系统当前的语言和地区把用户输入的带有当地特色的数字字符串转化成<code>Number</code>格式。其中<code>isLenient</code>表示是否允许格式不完全按照标准格式，例如如果这里使用<code>formatter.isLenient = false</code>，当输入字符串只要不是标准的<em>1,234,123.23</em>而是<em>1,23,4123.23</em>或者1,234123.23就会返回nil。</p><h1 id="关于日历的本地化"><a href="#关于日历的本地化" class="headerlink" title="关于日历的本地化"></a>关于日历的本地化</h1><p>不同地区之间的纪年方法有很大的差别，日本的年代变化很快（他们还在用天皇纪年，就像咱们中国的封建社会）而公历或者农历的年代变化就相对较慢，而有的地区一年有13个月，不同的日历对每周的第一天定义也不同（周六、周日、周一都有）。要处理这么复杂多变的日历相关问题就一定要用到<code>Calender</code>类。</p><p>获取用户当前使用的日历使用<code>Calendar.current</code>。</p><p>获取一个日期的组成部分：</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> calendar <span class="operator">=</span> <span class="type">Calendar</span>.current</span><br><span class="line"><span class="keyword">let</span> components <span class="operator">=</span> calendar.dateComponents([.era, .year, .month, .weekday, .day, .hour, .minute, .second], from: <span class="type">Date</span>())</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;当前时间组件：<span class="subst">\(String(describing: components.era<span class="operator">!</span>))</span>, <span class="subst">\(String(describing: components.year<span class="operator">!</span>))</span>, <span class="subst">\(String(describing: components.month<span class="operator">!</span>))</span>, <span class="subst">\(String(describing: components.weekday<span class="operator">!</span>))</span>, <span class="subst">\(String(describing: components.day<span class="operator">!</span>))</span>, <span class="subst">\(String(describing: components.hour<span class="operator">!</span>))</span>, <span class="subst">\(String(describing: components.minute<span class="operator">!</span>))</span>, <span class="subst">\(String(describing: components.second<span class="operator">!</span>))</span>&quot;</span>) <span class="comment">// 当前时间组件：1, 2021, 4, 1, 11, 22, 32, 4</span></span><br></pre></td></tr></table></figure><blockquote><p>当使用日本历或者佛教日历的时候，每次获取或者设置年份一定要同时获取或者设置年代。</p></blockquote><p>更多关于日历的内容可以参考一下<a href="https://developer.apple.com/library/archive/documentation/Cocoa/Conceptual/DatesAndTimes/DatesAndTimes.html#//apple_ref/doc/uid/10000039i">官方文档</a></p><h1 id="Locale和时区相关的通知"><a href="#Locale和时区相关的通知" class="headerlink" title="Locale和时区相关的通知"></a>Locale和时区相关的通知</h1><p>要及时的获取Locale或者时区变化的通知可以监听<code>NSCurrentLocaleDidChangeNotification</code>和<code>NSSystemTimeZoneDidChangeNotification</code>通知。</p><p>获取通知在用户进行跨国长途旅行的时候非常有用，当用户时区改变后app能够及时变化可以给用户一个非常棒的体验。</p><div class="note info"><p>到公众号【iOS开发栈】学习更多SwiftUI、iOS开发相关内容。</p></div><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>想要很完善的本地化一个App是不容易的，不仅要把文字本地化还要把日期、时间、日历、数字等内容本地化，这些内容在一个app中是无处不在的，这就要求我们要随时记着自己是在做一个国际化的App。为了能给全世界各地的用户一个更好的使用体验，尽力做好这项工作吧。</p>]]></content>
    
    
    <summary type="html">&lt;p&gt;不同的国家、地区对一些诸如日期、时间、数字、货币等方面有不同的表述方式，为了更好的满足当地人的使用习惯和习俗，App必须做好这些方面的国际化工作。这是一项重要且复杂的工作，希望通过这篇可以让你对这些内容有一个全面的了解。&lt;/p&gt;</summary>
    
    
    
    
    <category term="Xcode" scheme="http://www.iosprogrammer.tech/tags/Xcode/"/>
    
    <category term="国际化" scheme="http://www.iosprogrammer.tech/tags/%E5%9B%BD%E9%99%85%E5%8C%96/"/>
    
  </entry>
  
  <entry>
    <title>苹果官方的iOS App国际化工作流</title>
    <link href="http://www.iosprogrammer.tech/xcode/international-user-facing-text/"/>
    <id>http://www.iosprogrammer.tech/xcode/international-user-facing-text/</id>
    <published>2021-04-05T09:08:21.000Z</published>
    <updated>2021-05-01T06:46:28.083Z</updated>
    
    <content type="html"><![CDATA[<p>国际化是出海应用非常重要的一个基础步骤，其中多语言的适配是重中之重。Xcode自带了帮助开发者进行App本地化的功能，其中包括多语言文件的导入和导出，使用这些功能可以很丝滑的完成多语言的工作。</p><a id="more"></a><p><img src="../../images/first/international-user-facing-text.png" alt="iOS国际化"></p><div class="note info"><p>到公众号【iOS开发栈】学习更多SwiftUI、iOS开发相关内容。</p></div><p>App中有一些固定内容的控件是可以直接利用IB文件来做多语言的，具体方法可以查看一下之前的<a href="https://www.iosprogrammer.tech/xcode/language-internalization-ib/">这篇文章</a>，文章中也讲了怎么添加多语言的操作。</p><p>除了一些固定内容的控件之外还会有一些其他内容需要开发者通过代码的形式来本地化，比如可变内容的控件、错误提示信息、富文本、App名称等。通过下面几个步骤可以给这些内容添加多语言。</p><h1 id="标记需要本地化的文本"><a href="#标记需要本地化的文本" class="headerlink" title="标记需要本地化的文本"></a>标记需要本地化的文本</h1><p>Foundation框架中使用<code>NSLocalizedString(_:tableName:bundle:value:comment:)</code>来标记需要本地化的文本，通常tableName/bundle和value直接使用默认值就可以了。</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">NSLocalizedString</span>(<span class="string">&quot;Label1&quot;</span>, comment: <span class="string">&quot;This is the first label&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 上面的代码最终的样子</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* This is the first label */</span></span><br><span class="line"><span class="string">&quot;Label1&quot;</span> <span class="operator">=</span> <span class="string">&quot;First Label 111&quot;</span>;</span><br></pre></td></tr></table></figure><p>翻译文件是key-value的格式，其中key是<code>NSLocalizedString</code>函数中的第一个参数，在这里就是<em>Label1</em>。默认的value也是<em>Label1</em>。</p><p><code>comment</code>参数是这对key-value的注释，主要是在进行人工翻译的时候提供一个说明作用，尤其是当有多个相似的文本时这个注释就有作用了。</p><h1 id="使用Xcode导出本地化多语言文件"><a href="#使用Xcode导出本地化多语言文件" class="headerlink" title="使用Xcode导出本地化多语言文件"></a>使用Xcode导出本地化多语言文件</h1><p>当还没有进行翻译的时候，使用<code>NSLocalizedString</code>的地方就会显示<em>key</em>文本，Xcode会在导出多语言文件的时候在项目中搜寻这个函数。</p><p>导出多语言文件的步骤如下：</p><ol><li>使用Xcode打开项目</li><li>在左侧的目录导航栏中点击项目名打开.xcodeproj</li><li>在PROJECT中选择项目名，并在Info选项卡的Locations中添加上其他语言</li><li>点击Xcode菜单栏中Editor选项的Export for Localization</li><li>选择导出的文件夹并命名后点击导出</li></ol><h1 id="修改本地化多语言文件"><a href="#修改本地化多语言文件" class="headerlink" title="修改本地化多语言文件"></a>修改本地化多语言文件</h1><p>导出的文件中包含多个.xcloc子文件夹，每一个xloc文件夹中的Localized Contents下的.xliff文件就是要填写翻译内容的文件。</p><p>打开xliff文件并在其中搜索“<source>”，搜索到的文本就是需要翻译的内容。每个<source>对应一个<target>，把译文放到<target>和</target>中间。就像这样：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&lt;source&gt;First Label 111&lt;&#x2F;source&gt;</span><br><span class="line">&lt;target&gt;第一个文本&lt;&#x2F;target&gt;</span><br></pre></td></tr></table></figure><p>source是Development Language的语言文本，target是译文。上面这个例子的Development Language是英文，target是中文。</p><p>source不是<code>NSLocalizedString</code>第一个参数指定的key，而是Development Language下key对应的value，所以如果开发语言的译文变了，这里的source也会变。</p><h1 id="使用Xcode导入本地化多语言文件"><a href="#使用Xcode导入本地化多语言文件" class="headerlink" title="使用Xcode导入本地化多语言文件"></a>使用Xcode导入本地化多语言文件</h1><p>把所有需要翻译的内容翻译完成后，使用Xcode打开项目，并打开.xcodeproj后选择Editor-&gt;Import Localizations，打开翻译文件所在的目录把.xcloc挨个导入就可以了。</p><p>这里建议先翻译并导入Development Language的.xcloc文件夹，再执行一次导出操作后再翻译其他语言并导入。因为第一次导出时source是NSLocalizedString的第一个参数，而这个参数可能并不是主语言的最终翻译，如果其他语言都把第一个参数作为source来翻译就会造成找不到对应翻译的问题。</p><div class="note info"><p>到公众号【iOS开发栈】学习更多SwiftUI、iOS开发相关内容。</p></div><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>iOS和MacOS系统以及它们自带的App在本地化方面做的非常出色，所以我们在没有特殊要求的情况下尽量依赖Xcode提供的功能来实现本地化的需求。</p>]]></content>
    
    
    <summary type="html">&lt;p&gt;国际化是出海应用非常重要的一个基础步骤，其中多语言的适配是重中之重。Xcode自带了帮助开发者进行App本地化的功能，其中包括多语言文件的导入和导出，使用这些功能可以很丝滑的完成多语言的工作。&lt;/p&gt;</summary>
    
    
    
    
    <category term="Xcode" scheme="http://www.iosprogrammer.tech/tags/Xcode/"/>
    
    <category term="国际化" scheme="http://www.iosprogrammer.tech/tags/%E5%9B%BD%E9%99%85%E5%8C%96/"/>
    
  </entry>
  
  <entry>
    <title>必看！2个关于iOS开发多语言的知识点</title>
    <link href="http://www.iosprogrammer.tech/xcode/iphone-selected-language/"/>
    <id>http://www.iosprogrammer.tech/xcode/iphone-selected-language/</id>
    <published>2021-04-05T03:18:11.000Z</published>
    <updated>2021-05-01T06:46:23.768Z</updated>
    
    <content type="html"><![CDATA[<p>在把App进行国际化的过程中会遇到很多问题，这篇文章来看一下Development Language是什么以及怎么修改它，并且看一下系统是怎么来选择使用哪个语言的。</p><a id="more"></a><div class="note info"><p>到公众号【iOS开发栈】学习更多SwiftUI、iOS开发相关内容。</p></div><h1 id="什么是Development-Language和怎么修改它"><a href="#什么是Development-Language和怎么修改它" class="headerlink" title="什么是Development Language和怎么修改它"></a>什么是Development Language和怎么修改它</h1><p>在进行国际化的过程中需要把App中的文字翻译成多个语言，其中有一种语言是Development Language，当没有任何一种语言满足当前设备的时候系统会使用Development Language。</p><p>可以通过修改<em>project.pbxproj</em>文件来修改Development Language。</p><ol><li>打开项目所在文件夹</li><li>右击.xcodeproj文件并选择*Show package Content(显示包内容)*（应该是第三个选项）</li><li>双击<em>project.phxproj</em>打开文件</li><li>搜索<em>developmentRegion</em>，并将内容修改为想要的语言。这个地方的语言是在我们添加多语言时的缩写，比如English=en、Chinese, Simpilied=zh-Hans等等。</li></ol><h1 id="iPhone是怎么选择当前使用的语言的"><a href="#iPhone是怎么选择当前使用的语言的" class="headerlink" title="iPhone是怎么选择当前使用的语言的"></a>iPhone是怎么选择当前使用的语言的</h1><ol><li>在iPhone手机的设置中“语言与地区”选择的“iPhone语言”是最高优先级，如果App的多语言包含这里设置的语言会直接使用。</li><li>如果App的多语言不包含“iPhone语言”，那么会查找“首选语言顺序”中是否有包含在多语言中的语言，按照从上到下的顺序找到一个语言后会直接使用这个语言。</li><li>如果“首选语言顺序”中也没有符合要求的，那么会使用Development Language作为App的语言。</li></ol><div class="note info"><p>到公众号【iOS开发栈】学习更多SwiftUI、iOS开发相关内容。</p></div>]]></content>
    
    
    <summary type="html">&lt;p&gt;在把App进行国际化的过程中会遇到很多问题，这篇文章来看一下Development Language是什么以及怎么修改它，并且看一下系统是怎么来选择使用哪个语言的。&lt;/p&gt;</summary>
    
    
    
    
    <category term="Xcode" scheme="http://www.iosprogrammer.tech/tags/Xcode/"/>
    
    <category term="国际化" scheme="http://www.iosprogrammer.tech/tags/%E5%9B%BD%E9%99%85%E5%8C%96/"/>
    
  </entry>
  
  <entry>
    <title>iOS App国际化必看！使用Xib使App完成国际化功能</title>
    <link href="http://www.iosprogrammer.tech/xcode/language-internalization-ib/"/>
    <id>http://www.iosprogrammer.tech/xcode/language-internalization-ib/</id>
    <published>2021-03-28T13:50:56.000Z</published>
    <updated>2021-05-01T06:46:24.985Z</updated>
    
    <content type="html"><![CDATA[<p>利用Xib或者Storyboard来做iOS的国际化是一种特别方便且高效的方式。通过简单的设置后就可以在不同的文件中把内容翻译为不同的语种，这篇文章我们来了解一下利用IB来做国际化要注意的一些问题，希望能够对你有所帮助。</p><a id="more"></a><div class="note info"><p>到公众号【iOS开发栈】学习更多SwiftUI、iOS开发相关内容。</p></div><p><img src="../../images/xcode-internaiton-ib/cover.png"></p><h1 id="完整了解国际化步骤"><a href="#完整了解国际化步骤" class="headerlink" title="完整了解国际化步骤"></a>完整了解国际化步骤</h1><p><img src="../../images/xcode-internaiton-ib/overview.png"></p><ol><li>增加国际化语言。在xcode左侧的项目目录树中点击<strong>项目名称-&gt;点击“PROJECT”中的项目名称-&gt;Info-&gt;Locatlizations</strong>，之后点击+号就可以增加自己需要的语言了。</li><li>在选择要增加的语言之后会弹出设置弹窗，把需要国际化的IB（Xib、Storyboard）文件勾选上，并且在File Types选项中选择<em>Localizable Strings</em>。</li><li>项目目录树中对应的IB文件就会成为文件夹的形式，可以看到刚刚添加的语言文件（*.strings(xxx)）。</li></ol><h1 id="添加过语言后又要增加UILabel等控件国际化"><a href="#添加过语言后又要增加UILabel等控件国际化" class="headerlink" title="添加过语言后又要增加UILabel等控件国际化"></a>添加过语言后又要增加UILabel等控件国际化</h1><p>随着版本的升级或者需求的改变，我们的IB文件很可能会发生变化，由于我们使用了IB文件进行国际化，又不能每次改版重新做一遍国际化的工作，这就要求我们可以定位到新增的控件并设置语言。</p><p>在xxx.storyboad(Base)文件中选中增加的控件，打开右侧帮助栏，找到第四个选项卡(Show the Identity Inspector)，其中有一个<strong>Object ID</strong>。</p><p>把这个ID复制到其他语言的.strings文件中，就可以设置对应的语言翻译了。其中UILabel、UIButton和UITextFiled的placehoder的设置方法如下:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;* Class &#x3D; &quot;UITextField&quot;; placeholder &#x3D; &quot;ios&quot;; ObjectID &#x3D; &quot;RCg-HC-Mcn&quot;; *&#x2F;</span><br><span class="line">&quot;RCg-HC-Mcn.placeholder&quot; &#x3D; &quot;ios&quot;;</span><br><span class="line"></span><br><span class="line">&#x2F;* Class &#x3D; &quot;UIButton&quot;; normalTitle &#x3D; &quot;Button&quot;; ObjectID &#x3D; &quot;isH-qk-FQm&quot;; *&#x2F;</span><br><span class="line">&quot;isH-qk-FQm.normalTitle&quot; &#x3D; &quot;Button&quot;;</span><br><span class="line"></span><br><span class="line">&#x2F;* Class &#x3D; &quot;UILabel&quot;; text &#x3D; &quot;iosprogrammer.tech&quot;; ObjectID &#x3D; &quot;pLC-qp-tdZ&quot;; *&#x2F;</span><br><span class="line">&quot;pLC-qp-tdZ.text&quot; &#x3D; &quot;iosprogrammer.tech&quot;;</span><br></pre></td></tr></table></figure><h1 id="一些总结"><a href="#一些总结" class="headerlink" title="一些总结"></a>一些总结</h1><ol><li>如果一个用户的设备系统语言是没有进行适配的，他下载了应用后，将会使用Base语言。比如一个葡萄言语的用户下载了一个适配了日文和韩文的app，并且这个app的Base语言是日文，那么这个用户将会看到日文。</li><li>从一个已经适配的语言切换到一个没有适配的语言，仍然会使用切换前的语言。比如从适配了的中文简体切换到了没有适配的日文，那用户看到的仍然会是中文简体。</li></ol><div class="note info"><p>到公众号【iOS开发栈】学习更多SwiftUI、iOS开发相关内容。</p></div><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>通过这篇文章我们学习了几个在使用IB来做iOS国际化的过程中需要注意的地方，如果想要充分了解到这方面的知识建议通篇阅读一下<a href="https://developer.apple.com/library/archive/documentation/MacOSX/Conceptual/BPInternational/Introduction/Introduction.html#//apple_ref/doc/uid/10000171i-CH1-SW1">官方文档</a>。</p>]]></content>
    
    
    <summary type="html">&lt;p&gt;利用Xib或者Storyboard来做iOS的国际化是一种特别方便且高效的方式。通过简单的设置后就可以在不同的文件中把内容翻译为不同的语种，这篇文章我们来了解一下利用IB来做国际化要注意的一些问题，希望能够对你有所帮助。&lt;/p&gt;</summary>
    
    
    
    
    <category term="Xcode" scheme="http://www.iosprogrammer.tech/tags/Xcode/"/>
    
    <category term="国际化" scheme="http://www.iosprogrammer.tech/tags/%E5%9B%BD%E9%99%85%E5%8C%96/"/>
    
  </entry>
  
  <entry>
    <title>告诉你3个容易被忽略的可能造成循环引用的情况和2种不会造成循环引用的情况</title>
    <link href="http://www.iosprogrammer.tech/ios/retain-cycle-problems/"/>
    <id>http://www.iosprogrammer.tech/ios/retain-cycle-problems/</id>
    <published>2021-03-19T05:16:18.000Z</published>
    <updated>2021-04-14T00:57:35.196Z</updated>
    
    <content type="html"><![CDATA[<p>循环引用是iOS开发种十分常见的一个问题，也是面试中出现频率很高的一类问题，有些经验的开发者对循环引用都有所了解，也能在开发过程中尽量避免此类问题，但是随着项目的扩大和开发时间有限有时会不经意见给引用循环引用的问题。</p><p>这类问题虽然很多时候不会出现严重的影响，但是在其他一些条件下可能会带来很蹊跷的现象，本人就深受其害。所以在这里记录一下关于循环引用的一些常用知识，也希望对你有所帮助。</p><a id="more"></a><div class="note info"><p>到公众号【iOS开发栈】学习更多SwiftUI、iOS开发相关内容。</p></div><h1 id="什么是循环引用"><a href="#什么是循环引用" class="headerlink" title="什么是循环引用"></a>什么是循环引用</h1><p>造成循环引用问题的根本原因是iOS的引用计数机制，而在引用计数机制下如果有引用不能得到即时的释放就会造成了内存泄漏，这就是循环引用。</p><p>并且为了维持App的高性能，苹果并不没有也不打算引入类似Android中的垃圾回收机制。这就造成了如果我们导致了循环引用，那么这块内存就无法得到回收。</p><p>泄漏的内存多了会造成系统强制kill掉我们的应用程序，虽然这种现象我还没有见到过不过原理上来说会出现这种情况的。</p><p>一旦有没有得到即时回收的对象内存，还可能造成一些无可预期的问题。比方说我遇到的一个问题：由于一个VC没有得到即时释放，导致里面的一个定时任务不停执行，最终导致了营收不及预期。</p><p>所以循环引用的问题，我们在开发的过程中一定要重视起来。</p><h1 id="下面3种情况会造成循环引用"><a href="#下面3种情况会造成循环引用" class="headerlink" title="下面3种情况会造成循环引用"></a>下面3种情况会造成循环引用</h1><p>会造成循环引用问题的情形很多，下面我列举了3种情况，其中有一些是老生长谈，有些是需要特别注意的，有些真的是手滑造成的。</p><p>在编码过程中时刻谨记这些情况真的可以避免很多错误发生。</p><h3 id="block"><a href="#block" class="headerlink" title="block"></a>block</h3><p>这里的block指的是view对vc的回调、model对vc的回调或者子view对父view的回调。</p><p>不论是子view还是vc中的model，我们都习惯于用strong来修饰它们，这时候在它们的block回调里面用到<code>self</code>的时候一定要用<code>weak self</code>。</p><p>并且，切记成员变量<code>_xxx</code>如果在这种block中使用也会造成循环引用。使用弱指针来指向成员变量是一种解决方案，就像这样<code>self-&gt;_redView.backgroundColor = [UIColor greenColor];</code></p><h3 id="strong修饰的delegate"><a href="#strong修饰的delegate" class="headerlink" title="strong修饰的delegate"></a>strong修饰的delegate</h3><p>我们都知道delegate要使用weak来修饰，不过在编码过程中由于疏忽可能会误用strong来修饰delegate，所以如果当你遇到循环引用可是怎么也找不到原因时，不妨从这个思路找找。我就遇到过这种情况😭 。</p><h3 id="一些异步回调"><a href="#一些异步回调" class="headerlink" title="一些异步回调"></a>一些异步回调</h3><p>有一些异步回调是使用block的形式来处理的，这就可能引起循环引用。</p><p>有一些系统的功能比方说NSTimer的定时任务就会对self造成强引用。</p><p>还有一些是我们自己的功能比方说网络请求.</p><h1 id="下面2种情况不会造成循环引用"><a href="#下面2种情况不会造成循环引用" class="headerlink" title="下面2种情况不会造成循环引用"></a>下面2种情况不会造成循环引用</h1><h3 id="用Masonry给view添加约束"><a href="#用Masonry给view添加约束" class="headerlink" title="用Masonry给view添加约束"></a>用Masonry给view添加约束</h3><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">[<span class="keyword">self</span>.redView mas_makeConstraints:^(MASConstraintMaker *make) &#123;</span><br><span class="line">    make.top.equalTo(@<span class="number">130</span>);</span><br><span class="line">    make.left.equalTo(<span class="keyword">self</span>.view.mas_left).offset(<span class="number">10</span>);</span><br><span class="line">    make.width.equalTo(@<span class="number">60</span>);</span><br><span class="line">    make.height.equalTo(@<span class="number">40</span>);</span><br><span class="line">&#125;];</span><br></pre></td></tr></table></figure><p>这种用法是不会造成循环引用的，可以放心使用。</p><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">- (<span class="built_in">NSArray</span> *)mas_makeConstraints:(<span class="keyword">void</span>(^)(MASConstraintMaker *))block &#123;</span><br><span class="line">    <span class="keyword">self</span>.translatesAutoresizingMaskIntoConstraints = <span class="literal">NO</span>;</span><br><span class="line">    MASConstraintMaker *constraintMaker = [[MASConstraintMaker alloc] initWithView:<span class="keyword">self</span>];</span><br><span class="line">    block(constraintMaker);</span><br><span class="line">    <span class="keyword">return</span> [constraintMaker install];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>从源码来看，这里的block其实是一个同步的方法，所以这里是不会造成循环引用的。</p><h3 id="使用UIView静态方法实现动画"><a href="#使用UIView静态方法实现动画" class="headerlink" title="使用UIView静态方法实现动画"></a>使用UIView静态方法实现动画</h3><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">[<span class="built_in">UIView</span> animateWithDuration:<span class="number">3</span> animations:^&#123;</span><br><span class="line">    <span class="keyword">self</span>.redView.backgroundColor = [<span class="built_in">UIColor</span> greenColor];</span><br><span class="line">&#125;];</span><br></pre></td></tr></table></figure><p>这种情况虽然在block里面引用到了self，但是不会造成循环引用。因为<code>animateWithDuration:</code>是一个类方法。</p><h1 id="开发中怎么解决循环引用问题"><a href="#开发中怎么解决循环引用问题" class="headerlink" title="开发中怎么解决循环引用问题"></a>开发中怎么解决循环引用问题</h1><p>首先这里的方法并不是什么工程级别的高深方法，只是我在开发过程中总结到的一些实用、便捷的小技巧。</p><p>当怀疑某个控制器没有得到即时的释放时，可以在这个控制器里面重写<code>dealloc</code>函数然后打印一行文字，再在这行文字上加一个断点。这样我们就可以通过进出这个控制器来看到它的<code>dealloc</code>方法是不是即时被调用了。如果没有即时调用那就是有循环引用产生，相反则没有。</p><p>确定了某个控制器内确实出现了循环引用之后，就需要定位是哪里导致的循环引用了。</p><p>我个人习惯先看是不是block导致的，要想快速的搜索到一个文件里面所有的block可以通过搜索<code>^&#123;</code>来定位，之后就是检查每个block里面是不是按规范使用了<code>self</code>。检查过程一定要仔细，不然你很可能还得重来一遍😭 。</p><p>检查完所有的block后有99%的可能已经解决了循环引用的问题，不然的话就再去检查一下delegate和是不是使用了<code>NSTimer</code>。</p><p>这个过程下来100%可以解决掉循环引用的问题，否则你来公众号找我。</p><div class="note info"><p>到公众号【iOS开发栈】学习更多SwiftUI、iOS开发相关内容。</p></div>]]></content>
    
    
    <summary type="html">&lt;p&gt;循环引用是iOS开发种十分常见的一个问题，也是面试中出现频率很高的一类问题，有些经验的开发者对循环引用都有所了解，也能在开发过程中尽量避免此类问题，但是随着项目的扩大和开发时间有限有时会不经意见给引用循环引用的问题。&lt;/p&gt;
&lt;p&gt;这类问题虽然很多时候不会出现严重的影响，但是在其他一些条件下可能会带来很蹊跷的现象，本人就深受其害。所以在这里记录一下关于循环引用的一些常用知识，也希望对你有所帮助。&lt;/p&gt;</summary>
    
    
    
    
    <category term="iOS" scheme="http://www.iosprogrammer.tech/tags/iOS/"/>
    
  </entry>
  
  <entry>
    <title>SwiftUI怎么实现UISearchBar</title>
    <link href="http://www.iosprogrammer.tech/swiftui/swiftui-searchbar/"/>
    <id>http://www.iosprogrammer.tech/swiftui/swiftui-searchbar/</id>
    <published>2021-03-13T13:33:16.000Z</published>
    <updated>2021-03-13T14:08:04.238Z</updated>
    
    <content type="html"><![CDATA[<p>SwiftUI没有提供UISearchBar，虽然我们可以通过使用TextField来自己实现SeachBar的效果，不过要想实现一个和UISearchBar同样的控件并不容易，尤其是清除按钮和搜索图标。</p><p>这里推荐直接使用UISearchBar和UIViewRepresentable协议来一个SearchBar。</p><a id="more"></a><div class="note info"><p>到公众号【iOS开发栈】学习更多SwiftUI、iOS开发相关内容。</p></div><p><img src="../../images/first/swiftui-uisearchbar.png"></p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">SearchBar</span>: <span class="title">UIViewRepresentable</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Binding</span> <span class="keyword">var</span> text: <span class="type">String</span></span><br><span class="line">    <span class="keyword">var</span> placeholder: <span class="type">String</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">var</span> onCommit: ((<span class="keyword">_</span> text: <span class="type">String</span>) -&gt; <span class="type">Void</span>)<span class="operator">?</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">func</span> <span class="title">makeUIView</span><span class="params">(context: UIViewRepresentableContext&lt;SearchBar&gt;)</span></span> -&gt; <span class="type">UISearchBar</span> &#123;</span><br><span class="line">        <span class="keyword">let</span> searchBar <span class="operator">=</span> <span class="type">UISearchBar</span>(frame: .zero)</span><br><span class="line">        searchBar.delegate <span class="operator">=</span> context.coordinator</span><br><span class="line"></span><br><span class="line">        searchBar.placeholder <span class="operator">=</span> placeholder</span><br><span class="line">        searchBar.autocapitalizationType <span class="operator">=</span> .none</span><br><span class="line">        searchBar.searchBarStyle <span class="operator">=</span> .minimal</span><br><span class="line">        <span class="keyword">return</span> searchBar</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">func</span> <span class="title">updateUIView</span><span class="params">(<span class="keyword">_</span> uiView: UISearchBar, context: UIViewRepresentableContext&lt;SearchBar&gt;)</span></span> &#123;</span><br><span class="line">        uiView.text <span class="operator">=</span> text</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">func</span> <span class="title">makeCoordinator</span><span class="params">()</span></span> -&gt; <span class="type">SearchBar</span>.<span class="type">Coordinator</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="type">Coordinator</span>(text: <span class="variable">$text</span>, onCommit: <span class="keyword">self</span>.onCommit)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="class"><span class="keyword">class</span> <span class="title">Coordinator</span>: <span class="title">NSObject</span>, <span class="title">UISearchBarDelegate</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="meta">@Binding</span> <span class="keyword">var</span> text: <span class="type">String</span></span><br><span class="line">        <span class="keyword">var</span> onCommit: ((<span class="keyword">_</span> text: <span class="type">String</span>) -&gt; <span class="type">Void</span>)<span class="operator">?</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">init</span>(text: <span class="type">Binding</span>&lt;<span class="type">String</span>&gt;, onCommit: ((<span class="keyword">_</span> text: <span class="type">String</span>) -&gt; <span class="type">Void</span>)<span class="operator">?</span>) &#123;</span><br><span class="line">            _text <span class="operator">=</span> text</span><br><span class="line">            <span class="keyword">self</span>.onCommit <span class="operator">=</span> onCommit</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">func</span> <span class="title">searchBar</span><span class="params">(<span class="keyword">_</span> searchBar: UISearchBar, textDidChange searchText: String)</span></span> &#123;</span><br><span class="line">            text <span class="operator">=</span> searchText</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="function"><span class="keyword">func</span> <span class="title">searchBarSearchButtonClicked</span><span class="params">(<span class="keyword">_</span> searchBar: UISearchBar)</span></span> &#123;</span><br><span class="line">            <span class="keyword">if</span> <span class="keyword">let</span> onCommit <span class="operator">=</span> <span class="keyword">self</span>.onCommit &#123;</span><br><span class="line">                onCommit(searchBar.text <span class="operator">??</span> <span class="string">&quot;&quot;</span>)</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>UIViewRepresentable</code>是SwiftUI框架中提供的用于将UIView转换成SwiftUI中View的协议。</p><p><code>func makeUIView(context: Self.Context) -&gt; Self.UIViewType</code>用来创建View的方法，遵守UIViewRepresentable协议的类必须要实现这个方法。它的返回值是一个UIView类的实例。这个方法只会在创建View时调用一次，当View需要更新时会调用下面的这个方法。</p><p><code>func updateUIView(_ uiView: Self.UIViewType, context: Self.Context)</code>当UIView发生任何需要更新状态的事件时，这个方法就会被调用来更新View的状态。</p><p><code>func makeCoordinator() -&gt; Self.Coordinator</code>需要一个<code>Coordinator</code>的实例作为返回值。它通常用来处理一些事件（点击、时间、delegate、通知）引起了UIView的状态变化后，能够将新的状态反映到View上。</p><div class="note info"><p>到公众号【iOS开发栈】学习更多SwiftUI、iOS开发相关内容。</p></div>]]></content>
    
    
    <summary type="html">&lt;p&gt;SwiftUI没有提供UISearchBar，虽然我们可以通过使用TextField来自己实现SeachBar的效果，不过要想实现一个和UISearchBar同样的控件并不容易，尤其是清除按钮和搜索图标。&lt;/p&gt;
&lt;p&gt;这里推荐直接使用UISearchBar和UIViewRepresentable协议来一个SearchBar。&lt;/p&gt;</summary>
    
    
    
    
    <category term="SwiftUI" scheme="http://www.iosprogrammer.tech/tags/SwiftUI/"/>
    
  </entry>
  
  <entry>
    <title>iOS设置渐变色，给border设置渐变色</title>
    <link href="http://www.iosprogrammer.tech/ios/ios-gradient-color/"/>
    <id>http://www.iosprogrammer.tech/ios/ios-gradient-color/</id>
    <published>2021-03-07T12:50:56.000Z</published>
    <updated>2021-03-08T01:50:12.123Z</updated>
    
    <content type="html"><![CDATA[<p>本文将从4行代码出发给一个view设置渐变色，分别会谈到几个重要的渐变色相关属性，在使用过程中有几个需要特别关注的点。</p><p>给一个view的border设置渐变色是比较高阶的用法，希望本文可以在这个方面帮助到你。</p><a id="more"></a><p><img src="../../images/first/ios-gradient-color-border.png" alt="ios渐变色"></p><div class="note info"><p>到公众号【iOS开发栈】学习更多SwiftUI、iOS开发相关内容。</p></div><h1 id="给view设置渐变色"><a href="#给view设置渐变色" class="headerlink" title="给view设置渐变色"></a>给view设置渐变色</h1><p>通过4行代码就可以给一个view设置渐变色：</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> view <span class="operator">=</span> <span class="type">UIView</span>(frame: <span class="type">CGRect</span>(x: <span class="number">100</span>, y: <span class="number">100</span>, width: <span class="number">100</span>, height: <span class="number">100</span>))</span><br><span class="line"><span class="keyword">let</span> gradientLayer <span class="operator">=</span> <span class="type">CAGradientLayer</span>()</span><br><span class="line">gradientLayer.frame <span class="operator">=</span> view.bounds</span><br><span class="line"><span class="comment">// @[(__bridge id)[UIColor redColor].CGColor, (__bridge id)[UIColor yellowColor].CGColor]</span></span><br><span class="line">gradientLayer.colors <span class="operator">=</span> [<span class="type">UIColor</span>.red.cgColor, <span class="type">UIColor</span>.yellow.cgColor]</span><br><span class="line">view.layer.addSublayer(gradientLayer)</span><br></pre></td></tr></table></figure><p>在创建<code>CAGradientLayer</code>以后需要设置<code>frame</code>才能展示出来，否则它的大小会使用默认的0。</p><p>渐变色会根据<code>colors</code>数组来展示，这个数组的类型是<code>CGColorRef</code>，所以需要用<code>.cgColor</code>强制转换；如果使用的OC语法，必须加上<code>(__bridge id)</code>，否则渐变色会显示不出来。</p><p>默认情况下渐变会从上至下，可是通过设置<code>startPoint</code>和<code>endPoint</code>来改变这个顺序：</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">gradientLayer.startPoint <span class="operator">=</span> <span class="type">CGPoint</span>(x: <span class="number">0</span>, y: <span class="number">0</span>)</span><br><span class="line">gradientLayer.endPoint <span class="operator">=</span> <span class="type">CGPoint</span>(x: <span class="number">1</span>, y: <span class="number">1</span>)</span><br></pre></td></tr></table></figure><p>这两个点的范围是从0到1，也就是说最左边和最上边是0，最下和最右是1。这个例子中渐变会变成从左上角到右下角。</p><p>渐变色还有一个重要的属性是<code>locations</code>，这个属性是用来指定<code>colors</code>中设置的每个颜色的终点的。</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">gradientLayer.locations <span class="operator">=</span> [<span class="number">0.2</span>, <span class="number">0.8</span>]</span><br></pre></td></tr></table></figure><p>locations中元素的范围是从0到1。在这里，数组中的第一个元素<em>0.2</em>指定了colors数组中第一个元素<em>红色</em>的终点是0.2，也就是说把整个渐变色范围分成10份，从开始到<em>2/10</em>处都是纯红色，从<em>2/10</em>到<em>8/10</em>处是纯红色到纯黄色的渐变，而从<em>8/10</em>到<em>10/10</em>是纯黄色。</p><h1 id="给view的border设置渐变色"><a href="#给view的border设置渐变色" class="headerlink" title="给view的border设置渐变色"></a>给view的border设置渐变色</h1><p>使用<code>UIBezierPath</code>来创建一个带圆角的<code>CAShapeLayer</code>，并且把它的圆角设置成view的圆角，就可以把一个view的border设置为渐变色。</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="operator">...</span> <span class="comment">// 同上给view设置gradientLayer</span></span><br><span class="line">        </span><br><span class="line"><span class="keyword">let</span> shapeLayer <span class="operator">=</span> <span class="type">CAShapeLayer</span>()</span><br><span class="line">shapeLayer.borderWidth <span class="operator">=</span> <span class="number">1</span></span><br><span class="line">shapeLayer.path <span class="operator">=</span> <span class="type">UIBezierPath</span>(roundedRect: gradientLayer.bounds, cornerRadius: <span class="number">10</span>).cgPath</span><br><span class="line">shapeLayer.fillColor <span class="operator">=</span> <span class="type">UIColor</span>.clear.cgColor <span class="comment">// 必须要设置成clearColor或者nil，默认是黑色</span></span><br><span class="line">shapeLayer.strokeColor <span class="operator">=</span> <span class="type">UIColor</span>.white.cgColor <span class="comment">// 随便设置一个非clearColor的颜色</span></span><br><span class="line">        </span><br><span class="line">gradientLayer.mask <span class="operator">=</span> shapeLayer</span><br><span class="line"></span><br><span class="line">view.layer.addSublayer(gradientLayer)</span><br></pre></td></tr></table></figure><ol><li><em>borderWidth</em> shapeLayer的border宽度和view的相同，可以根据设计图来设置。</li><li><em>cornerRadius</em> UIBezierPath的圆角和view的圆角相同；<em>roundedRect</em>和<em>CAGradientLayer</em>的大小相同。</li><li><em>fillColor</em> 是shapeLayer的填充色，默认是黑色，建议设置成nil或者是透明色<code>clearColor</code></li><li><em>strokeColor</em> 是border的描边色，如果设置成clearColor的话就不会绘制出来border了，这里随便一个颜色就是让其能够绘制出来，实际使用的是渐变色</li><li><em>mask</em> 用shapeLayer作为gradientLayer的mask，可以让gradientLayer内部挖空，只保留边缘border的渐变颜色</li><li>最终把渐变色layer添加到view.layer上，shapeLayer只是用来修饰gradientlayer的，目的是把gradientlayer的内部挖空，并且把border和圆角做出来。</li></ol><div class="note info"><p>到公众号【iOS开发栈】学习更多SwiftUI、iOS开发相关内容。</p></div><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>通过这篇文章我们了解了怎么给一个view设置渐变色，并详细阐述了渐变色的几个重要属性。关于给border设置渐变色是一个进阶的知识点。</p><p>希望本篇文章能够帮助到你，也欢迎你把文章分享到朋友圈或微博。</p><p>有任何问题都可以到公众号给我发信息。</p>]]></content>
    
    
    <summary type="html">&lt;p&gt;本文将从4行代码出发给一个view设置渐变色，分别会谈到几个重要的渐变色相关属性，在使用过程中有几个需要特别关注的点。&lt;/p&gt;
&lt;p&gt;给一个view的border设置渐变色是比较高阶的用法，希望本文可以在这个方面帮助到你。&lt;/p&gt;</summary>
    
    
    
    
    <category term="iOS" scheme="http://www.iosprogrammer.tech/tags/iOS/"/>
    
  </entry>
  
  <entry>
    <title>environment和environmentObject的区别及适用场景</title>
    <link href="http://www.iosprogrammer.tech/swiftui/environment-vs-environmentObject/"/>
    <id>http://www.iosprogrammer.tech/swiftui/environment-vs-environmentObject/</id>
    <published>2021-03-05T03:25:18.000Z</published>
    <updated>2021-03-05T07:01:31.618Z</updated>
    
    <content type="html"><![CDATA[<p>SwiftUI中传递环境变量时会发现两个相似的方法：<code>environment&lt;V&gt;(_ keyPath:, _ value:)</code>和<code>environmentObject&lt;T&gt;(_ object:)</code>，这篇文章我们来看一下这两个方法的不同之处和分别的适用场景。</p><a id="more"></a><p><img src="../../images/first/swiftui-environmentobject-environment.png" alt="Swift环境变量对比"></p><div class="note info"><p>到公众号【iOS开发栈】学习更多SwiftUI、iOS开发相关内容。回复“博客”免费获取各大互联网公司面试题。</p></div><p>首先要明确的一点是，这两个方法都是用来设置环境变量的，而环境变量会影响到被设置变量的视图以及它的所有子视图，并且这个传递过程不需要明确指出。</p><p>也就是说，假设有三个视图，view1、view2、view3，其中view2和view3是view1的子视图，要想在view2和view3中使用view1设置的环境变量的话，只需要直接在view中使用<code>@EnvironmentObject</code>或者<code>@Environment</code>而不需要在创建view2和view3的时候显式传参。</p><h1 id="EnvironmentObject"><a href="#EnvironmentObject" class="headerlink" title="@EnvironmentObject"></a>@EnvironmentObject</h1><p>下面以<code>@EnvironmentObject</code>举例说明上面的这段话：</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 公众号——iOS开发栈</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">OfficalAccount</span>: <span class="title">ObservableObject</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Published</span> <span class="keyword">var</span> amount <span class="operator">=</span> <span class="number">3000</span> <span class="comment">// 订阅人数</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">DetailView</span>: <span class="title">View</span> </span>&#123;</span><br><span class="line">    <span class="meta">@EnvironmentObject</span> <span class="keyword">var</span> account: <span class="type">OfficalAccount</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">var</span> body: <span class="keyword">some</span> <span class="type">View</span> &#123;</span><br><span class="line">        <span class="type">VStack</span> &#123;</span><br><span class="line">            <span class="type">Button</span>(<span class="string">&quot;Increase Score in detailView&quot;</span>) &#123;</span><br><span class="line">                account.amount <span class="operator">+=</span> <span class="number">1</span></span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="type">Text</span>(<span class="string">&quot;account: <span class="subst">\(account.amount)</span>&quot;</span>)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">DetailView2</span>: <span class="title">View</span> </span>&#123;</span><br><span class="line">    <span class="meta">@EnvironmentObject</span> <span class="keyword">var</span> account: <span class="type">OfficalAccount</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">var</span> body: <span class="keyword">some</span> <span class="type">View</span> &#123;</span><br><span class="line">        <span class="type">Text</span>(<span class="string">&quot;Score: <span class="subst">\(account.amount)</span>&quot;</span>)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">ContentView</span>: <span class="title">View</span> </span>&#123;</span><br><span class="line">    <span class="meta">@StateObject</span> <span class="keyword">var</span> account <span class="operator">=</span> <span class="type">OfficalAccount</span>()</span><br><span class="line"></span><br><span class="line">    <span class="keyword">var</span> body: <span class="keyword">some</span> <span class="type">View</span> &#123;</span><br><span class="line">        <span class="type">VStack</span> &#123;</span><br><span class="line">            <span class="type">Button</span>(<span class="string">&quot;Increase Score&quot;</span>) &#123;</span><br><span class="line">                account.amount <span class="operator">+=</span> <span class="number">1</span></span><br><span class="line">            &#125;</span><br><span class="line">            </span><br><span class="line">            <span class="type">DetailView</span>()</span><br><span class="line">            <span class="type">DetailView2</span>()</span><br><span class="line">        &#125;</span><br><span class="line">        .environmentObject(account)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上面的例子是以我的公众号（”iOS开发栈“）的订阅人数做说明，可以看出<em>ContentView</em>创建<em>DetailView</em>和<em>DetailView2</em>时并没有直接传递变量<em>accout</em>，但是结果是这两个子视图中的数量显示会随着点击按钮而增加。</p><p>对上面使用<code>environmentObject</code>进行环境变量传递有几点需要注意：</p><ul><li>使用<code>@Environment</code>、<code>@StateObject</code>、<code>@ObservedObject</code>包装的类必须遵守<code>ObservableObject</code>协议，并且只能是类不能是结构体，否则会报错 <mark class="label danger">Non-class type OfficalAccount cannot conform to class protocol ObservableObject</mark></li><li><code>@Published</code>也只能在<em>class</em>中使用，如果放在了struct中，会报错<mark class="label danger">'wrappedValue' is unavailable: </mark></li><li>使用<code>@EnvironmentObject</code>包装的变量是不需要初始化的，编译器会从环境变量中获取这个对象的值</li><li>在子视图中可以修改了环境变量的值，并且这个改变会在当前的视图层级中传递</li></ul><h1 id="Environment"><a href="#Environment" class="headerlink" title="@Environment"></a>@Environment</h1><p>而对于<code>@Environment</code>来说，它主要是用来处理一些当前的系统设置的，比如说语言、时区、黑暗模式、CoreData的Context等。</p><p>在使用过程中一个很大的不同是，<code>@Environment(_ keyPath:)</code>需要指定一个类型为<code>KeyPath</code>的参数，而这个参数大多数情况下我们都是使用的<code>EnvironmentValues</code>中已经定义好的，比如<code>managedObjectContext</code>/<code>locale</code>等。</p><p>下面以使用<em>CoreData</em>为例说明使用方法：</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// App.swift</span></span><br><span class="line"><span class="operator">...</span></span><br><span class="line"><span class="keyword">let</span> persistenceController <span class="operator">=</span> <span class="type">PersistenceController</span>.shared</span><br><span class="line"><span class="operator">...</span></span><br><span class="line"><span class="keyword">var</span> body: <span class="keyword">some</span> <span class="type">Scene</span> &#123;</span><br><span class="line">    <span class="type">WindowGroup</span> &#123;</span><br><span class="line">        <span class="type">ContentView</span>()</span><br><span class="line">            .environment(\.managedObjectContext, persistenceController.container.viewContext)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="operator">...</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// ContentView.swift</span></span><br><span class="line"><span class="operator">...</span></span><br><span class="line"><span class="meta">@Environment</span>(\.managedObjectContext) <span class="keyword">private</span> <span class="keyword">var</span> viewContext</span><br><span class="line"><span class="operator">...</span></span><br><span class="line"><span class="keyword">let</span> newItem <span class="operator">=</span> <span class="type">Item</span>(context: viewContext)</span><br><span class="line">newItem.platform <span class="operator">=</span> <span class="number">1</span></span><br><span class="line"><span class="operator">...</span></span><br></pre></td></tr></table></figure><p>在这个例子中，我们在<em>App.swift</em>中创建了<code>persistenceController</code>并通过调用<code>.environment</code>把值传递给了<em>ContentView</em>。<em>ContentView</em>中使用<code>@Environment(\.managedObjectContext) private var viewContext</code>获取到了这个环境变量。</p><p>除了需要一个KeyPath和上面提到的主要用来处理系统自带的环境变量外，<code>@Environment</code>和<code>@EnvironmentObject</code>在用法上相差不大。</p><div class="note info"><p>到公众号【iOS开发栈】学习更多SwiftUI、iOS开发相关内容。回复“博客”免费获取各大互联网公司面试题。</p></div><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>通过灵活使用环境变量，可以让开发过程更加简单，页面之间可以写更少的值传递（正向、反相）相关代码。通过本文对<code>Environment</code>和<code>EnvironmentObject</code>的对比，我们更深入的了解了SwiftUI中环境变量的一些使用细节。</p><p>如果本文对你有帮助请帮忙分享到朋友圈或者微博。</p><p>如果有任何问题也可以到公众号联系我。</p>]]></content>
    
    
    <summary type="html">&lt;p&gt;SwiftUI中传递环境变量时会发现两个相似的方法：&lt;code&gt;environment&amp;lt;V&amp;gt;(_ keyPath:, _ value:)&lt;/code&gt;和&lt;code&gt;environmentObject&amp;lt;T&amp;gt;(_ object:)&lt;/code&gt;，这篇文章我们来看一下这两个方法的不同之处和分别的适用场景。&lt;/p&gt;</summary>
    
    
    
    
    <category term="SwiftUI" scheme="http://www.iosprogrammer.tech/tags/SwiftUI/"/>
    
  </entry>
  
  <entry>
    <title>在SwiftUI中实现UISegmentControl</title>
    <link href="http://www.iosprogrammer.tech/swiftui/swiftui-uisegmentcontrol/"/>
    <id>http://www.iosprogrammer.tech/swiftui/swiftui-uisegmentcontrol/</id>
    <published>2021-03-04T03:09:44.000Z</published>
    <updated>2021-03-04T10:24:09.339Z</updated>
    
    <content type="html"><![CDATA[<p>在SwiftUI中官方把控件做了精简，造成有些在UIKit中使用的控件找不到了。这篇文章来看一下UIPickerView在SwiftUI中是怎么表示的。</p><a id="more"></a><p>了解了一些SwiftUI的基础知识以后，应该就知道有一个<code>Picker</code>控件，想要实现UISegmentControl的效果就要用到这个控件。</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@State</span> <span class="keyword">var</span> platform <span class="operator">=</span> <span class="number">1</span></span><br><span class="line">    </span><br><span class="line"><span class="keyword">var</span> body: <span class="keyword">some</span> <span class="type">View</span> &#123;</span><br><span class="line">    <span class="type">VStack</span> &#123;</span><br><span class="line">        <span class="type">Picker</span>(<span class="string">&quot;平台名称&quot;</span>, selection: <span class="variable">$platform</span>) &#123;</span><br><span class="line">            <span class="type">Text</span>(<span class="string">&quot;支付宝&quot;</span>).tag(<span class="number">1</span>).navigationTitle(<span class="string">&quot;选择平台&quot;</span>)</span><br><span class="line">            <span class="type">Text</span>(<span class="string">&quot;京东金融&quot;</span>).tag(<span class="number">2</span>)</span><br><span class="line">        &#125;</span><br><span class="line">        .pickerStyle(<span class="type">SegmentedPickerStyle</span>())</span><br><span class="line">        </span><br><span class="line">        <span class="type">Text</span>(<span class="string">&quot;<span class="subst">\(platform)</span>&quot;</span>)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>使用这段代码就可以得到一个UISegmentControl效果的Picker了。</p><p>其中关键部分是<code>.pickerStyle(SegmentedPickerStyle())</code>，pickerStyle是一个设置Picker样式的Modifier，<code>SegmentedPickerStyle</code>就是外型和UISegmentControl一摸一样的效果。</p><p>除了SegmentedPickerStyle以外，pickerStyle还有下面几种类型：</p><ul><li><code>DefaultPickerStyle</code> 在不同平台有不同的展现形式。iOS平台上和<em>InlinePickerStyle</em>相同都是滚轮样式；MacOS平台和<em>MenuPickerStyle</em>相同；tvOS平台上和<em>SegmentedPickerStyle</em>相同</li><li><code>InlinePickerStyle</code>/<code>WheelPickerStyle</code> 滚轮样式</li><li><code>MenuPickerStyle</code> 点击后Picker的text后弹出选项，有点类似于<code>MenuController</code></li><li><code>RadioGroupPickerStyle</code> MacOS上使用的，所有选项一字排开，每个前面都有一个复选框☑️</li><li><code>SegmentedPickerStyle</code> 上面说的模仿UISegmentControl的外形，使用这种style的时候，Picker的content只能是Text或者Image</li></ul><div class="note info"><p>到公众号【iOS开发栈】学习更多SwiftUI、iOS开发相关内容。</p></div>]]></content>
    
    
    <summary type="html">&lt;p&gt;在SwiftUI中官方把控件做了精简，造成有些在UIKit中使用的控件找不到了。这篇文章来看一下UIPickerView在SwiftUI中是怎么表示的。&lt;/p&gt;</summary>
    
    
    
    
    <category term="SwiftUI" scheme="http://www.iosprogrammer.tech/tags/SwiftUI/"/>
    
  </entry>
  
</feed>

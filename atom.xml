<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>iOS开发栈 - 专注于分享iOS开发相关知识</title>
  
  <subtitle>关注公众号【iOS开发栈】及时免费获取更多iOS开发知识</subtitle>
  <link href="http://www.iosprogrammer.tech/atom.xml" rel="self"/>
  
  <link href="http://www.iosprogrammer.tech/"/>
  <updated>2021-04-16T03:40:50.576Z</updated>
  <id>http://www.iosprogrammer.tech/</id>
  
  <author>
    <name>施治昂</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>SwiftUI中Image自适应大小AspectFill、AspectFit</title>
    <link href="http://www.iosprogrammer.tech/swiftui/swiftui-image-fill-fit-mode/"/>
    <id>http://www.iosprogrammer.tech/swiftui/swiftui-image-fill-fit-mode/</id>
    <published>2021-04-16T01:30:16.000Z</published>
    <updated>2021-04-16T03:40:50.576Z</updated>
    
    <content type="html"><![CDATA[<p>SwiftUI中想要让Image能够实现类似于UIViewContentModeAspectFit或者ApectFill的效果需要把两个<a href="https://www.iosprogrammer.tech/swiftui/swiftui-concept-essential/">修改器(modifier)</a>结合起来使用。</p><a id="more"></a><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">Image</span>(<span class="string">&quot;xxx&quot;</span>)</span><br><span class="line">    .resizable(resizingMode: .stretch)</span><br><span class="line">    .aspectRatio(contentMode: .fit)</span><br></pre></td></tr></table></figure><p><code>func resizable(capInsets:, resizingMode:)</code>对应的是UIImage的<code>resizableImageWithCapInsets:resizingMode:</code>。<code>capInsets</code>确定了不被拉伸影响的上下左右四边距，四边距以外的部分会被<code>resizingMode</code>影响。<code>Image.ResizingMode.stretch</code>铺满整个空间，会发生形变,<code>Image.ResizingMode.stretch</code>平铺，也就是说如果图片的大小不足以占满空间就把图片复制多份，如果图片比空间大只会展示出来和空间一样大的部分并且图片的左上角和容器的左上角对齐，其他部分会被裁掉。</p><p><code>aspectRatio(_ aspectRatio:,contentMode:)</code>修改器设置长宽比和填充方式，<code>aspectRatio</code>参数是视图的<em>长:宽</em>，<code>contentMode</code>是填充方式其中Fill表示填满空间，长边会超出容器，Fit会保证长边填满空间短边会留出空白。</p><p><strong>据我观察，单独对Image使用aspectRatio修改器没有效果，需要结合<code>resizable</code>修改器才行。</strong></p><div class="note info"><p>到公众号【iOS开发栈】学习更多SwiftUI、iOS开发相关内容。</p></div>]]></content>
    
    
    <summary type="html">&lt;p&gt;SwiftUI中想要让Image能够实现类似于UIViewContentModeAspectFit或者ApectFill的效果需要把两个&lt;a href=&quot;https://www.iosprogrammer.tech/swiftui/swiftui-concept-essential/&quot;&gt;修改器(modifier)&lt;/a&gt;结合起来使用。&lt;/p&gt;</summary>
    
    
    
    
    <category term="SwiftUI" scheme="http://www.iosprogrammer.tech/tags/SwiftUI/"/>
    
  </entry>
  
  <entry>
    <title>SwiftUI自定义Modifier</title>
    <link href="http://www.iosprogrammer.tech/swiftui/swiftui-custom-modifier/"/>
    <id>http://www.iosprogrammer.tech/swiftui/swiftui-custom-modifier/</id>
    <published>2021-04-14T00:47:13.000Z</published>
    <updated>2021-04-14T01:16:39.832Z</updated>
    
    <content type="html"><![CDATA[<p>SwiftUI中已经自带了很多<a href="https://www.iosprogrammer.tech/swiftui/swiftui-concept-essential/">Modifier</a>，使用这些自带的modifier可以满足我们的大多数需求。有些情况下为了方便使用或者统一风格，我们还想要给View增加自己的Modifier。</p><a id="more"></a><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">CustomModifier</span>: <span class="title">ViewModifier</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">func</span> <span class="title">body</span><span class="params">(content: Content)</span></span> -&gt; <span class="keyword">some</span> <span class="type">View</span> &#123;</span><br><span class="line">        content</span><br><span class="line">            .background(<span class="type">Color</span>.yellow)</span><br><span class="line">            .cornerRadius(<span class="number">10</span>)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>遵守<code>ViewModifier</code>即可创建自定义的modifier。</p><p>modifier并不是对原来view的修改，而是创建了一个新的view，具体可以参考我之前的<a href="https://www.iosprogrammer.tech/swiftui/swiftui-concept-essential/">这篇文章</a>。</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">Text</span>(<span class="string">&quot;iOS开发栈&quot;</span>)</span><br><span class="line">    .modifier(customModifier())</span><br></pre></td></tr></table></figure><p><code>modier(:)</code>方法是View的一个扩展方法，通过这个方法可以让一个view通过应用modier来返回一个新的view，这也证实了上面提到的。</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">extension</span> <span class="title">View</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">func</span> <span class="title">customModifier</span><span class="params">()</span></span> -&gt; <span class="keyword">some</span> <span class="type">View</span> &#123;</span><br><span class="line">        <span class="keyword">self</span>.modifier(<span class="type">CustomModifier</span>())</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>通过给View添加一个扩展方法就可以像使用系统方法那样调用我们自己添加的modifier了。</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">Text</span>(<span class="string">&quot;iOS开发栈&quot;</span>)</span><br><span class="line">    .customModifier()</span><br></pre></td></tr></table></figure><p>当然，我们也可以给自定义的Modifier添加参数，来实现更为复杂的效果。</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">CustomModifier</span>: <span class="title">ViewModifier</span> </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> cornerRadius: <span class="type">CGFloat</span></span><br><span class="line">    <span class="function"><span class="keyword">func</span> <span class="title">body</span><span class="params">(content: Content)</span></span> -&gt; <span class="keyword">some</span> <span class="type">View</span> &#123;</span><br><span class="line">        content</span><br><span class="line">            .background(<span class="type">Color</span>.yellow)</span><br><span class="line">            .cornerRadius(cornerRadius)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">extension</span> <span class="title">View</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">func</span> <span class="title">customModifier</span><span class="params">(cornerRadius: CGFloat)</span></span> -&gt; <span class="keyword">some</span> <span class="type">View</span> &#123;</span><br><span class="line">        <span class="keyword">self</span>.modifier(<span class="type">CustomModifier</span>(cornerRadius: cornerRadius))</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">ContentView</span>: <span class="title">View</span> </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> body: <span class="keyword">some</span> <span class="type">View</span> &#123;</span><br><span class="line">        <span class="type">VStack</span> &#123;</span><br><span class="line">            <span class="type">Text</span>(<span class="string">&quot;iOS开发栈&quot;</span>)</span><br><span class="line">                .customModifier(cornerRadius: <span class="number">10</span>)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><div class="note info"><p>到公众号【iOS开发栈】学习更多SwiftUI、iOS开发相关内容。</p></div>]]></content>
    
    
    <summary type="html">&lt;p&gt;SwiftUI中已经自带了很多&lt;a href=&quot;https://www.iosprogrammer.tech/swiftui/swiftui-concept-essential/&quot;&gt;Modifier&lt;/a&gt;，使用这些自带的modifier可以满足我们的大多数需求。有些情况下为了方便使用或者统一风格，我们还想要给View增加自己的Modifier。&lt;/p&gt;</summary>
    
    
    
    
    <category term="SwiftUI" scheme="http://www.iosprogrammer.tech/tags/SwiftUI/"/>
    
  </entry>
  
  <entry>
    <title>iOS本地化日期、时间、货币数字（超全）</title>
    <link href="http://www.iosprogrammer.tech/xcode/international-data-format/"/>
    <id>http://www.iosprogrammer.tech/xcode/international-data-format/</id>
    <published>2021-04-11T02:44:40.000Z</published>
    <updated>2021-04-11T15:00:15.870Z</updated>
    
    <content type="html"><![CDATA[<p>不同的国家、地区对一些诸如日期、时间、数字、货币等方面有不同的表述方式，为了更好的满足当地人的使用习惯和习俗，App必须做好这些方面的国际化工作。这是一项重要且复杂的工作，希望通过这篇可以让你对这些内容有一个全面的了解。</p><a id="more"></a><div class="note info"><p>到公众号【iOS开发栈】学习更多SwiftUI、iOS开发相关内容。</p></div><p><img src="../../images/international-data-format/cover.png" alt="iOS app 日期和数字的本地化"></p><p>之前两篇关于iOS国际化的文章讨论了关于<a href="https://www.iosprogrammer.tech/xcode/language-internalization-ib/">使用IB将固定UI国际化</a>和<a href="https://www.iosprogrammer.tech/xcode/international-user-facing-text/">使用NSLocalizeString宏将可变文本国际化</a>，这篇文章将集中于处理一些日常表述方面的国际化问题，比如日期、时间、数字、货币等。</p><p>首先要明确一点，这里的本地化并不是完全依赖于语言的，也就是说同样的语言在本地化方面也会有不同的表现形式。比如说意大利和美国都是英语国家但是在美国数字使用的“,”分割，而意大利使用的是“.”，又对于货币符号就更多了。</p><p>在iPhone和Mac上都有地区的选择，在对应页面的下方就是一些示例。</p><p><img src="../../images/international-data-format/mac-region-pannel.png" alt="Mac地区选择示例"></p><p>在开发过程中还有一个快速修改所在区域的小技巧，在Edit Scheme -&gt; Options中修改App Region然后重新运行项目就可以修改所在区域了，这样就不需要每次到系统设置中去修改区域。</p><h1 id="获取当前系统的本地化信息"><a href="#获取当前系统的本地化信息" class="headerlink" title="获取当前系统的本地化信息"></a>获取当前系统的本地化信息</h1><ol><li>获取Locale对象</li></ol><p>可以通过两种方法获取到用户的本地化对象<code>Locale.current</code>和<code>Locale.autoupdatingCurrent</code>，官方文档说autoupdatingCurrent会随着系统设置的更改而改变，current是固定的。</p><p>但是我并没有发现这两者的区别，当用户修改系统语言或者所在地区以后所有app都会重启，不管使用那种方式都会重新获取最新的系统设置，而如果只是修改日历的话app不会重启但是<code>autoupdatingCurrent</code>方法获取到的locale也不会改变。</p><p>我不知道这是由于官方文档没有及时更新还是由于我没有找到这两个方法之间的区别，如果你知道他们的区别麻烦告诉我。</p><ol start="2"><li>获取Locale对象包含的本地化信息</li></ol><p>本地化信息会随着语言、地域、文化的不同而不同，总共包含了大概十几个条目，下面列举几个比较常用的条目并且以大陆地区为例来给出结果。</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 以中国大陆地区为例</span></span><br><span class="line"><span class="keyword">let</span> currentLocale <span class="operator">=</span> <span class="type">Locale</span>.autoupdatingCurrent</span><br><span class="line">currentLocale.identifier <span class="comment">// zh_CN</span></span><br><span class="line">currentLocale.languageCode <span class="operator">??</span> <span class="string">&quot;&quot;</span> <span class="comment">// zh</span></span><br><span class="line">currentLocale.regionCode <span class="operator">??</span> <span class="string">&quot;&quot;</span> <span class="comment">// CN</span></span><br><span class="line">currentLocale.scriptCode <span class="operator">??</span> <span class="string">&quot;&quot;</span> <span class="comment">// &quot;&quot;</span></span><br><span class="line">currentLocale.variantCode <span class="operator">??</span> <span class="string">&quot;&quot;</span> <span class="comment">// &quot;&quot;</span></span><br><span class="line">currentLocale.calendar <span class="comment">// gregorian (current)</span></span><br><span class="line">currentLocale.usesMetricSystem <span class="comment">// true</span></span><br><span class="line">currentLocale.currencySymbol <span class="operator">??</span> <span class="string">&quot;&quot;</span> <span class="comment">// ¥</span></span><br><span class="line">currentLocale.currencyCode <span class="operator">??</span> <span class="string">&quot;&quot;</span> <span class="comment">// CNY</span></span><br><span class="line">currentLocale.quotationBeginDelimiter <span class="operator">??</span> <span class="string">&quot;&quot;</span> <span class="comment">// “ 前引号</span></span><br><span class="line">currentLocale.quotationEndDelimiter <span class="operator">??</span> <span class="string">&quot;&quot;</span> <span class="comment">// ” 后引号</span></span><br></pre></td></tr></table></figure><ol start="3"><li>获取当前语言和方言</li></ol><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> languageId <span class="operator">=</span> <span class="type">Bundle</span>.main.preferredLocalizations.first<span class="operator">!</span> <span class="comment">// zh-Hans</span></span><br><span class="line"><span class="keyword">let</span> locale <span class="operator">=</span> <span class="type">Locale</span>.current</span><br><span class="line"><span class="keyword">let</span> languageName <span class="operator">=</span> locale.localizedString(forLanguageCode: languageId)<span class="operator">!</span> <span class="comment">// 中文</span></span><br></pre></td></tr></table></figure><p>这里的languageId是开发者需要的而不应该让用户看到，languageName是展示给用户的。</p><h1 id="格式化日期时间"><a href="#格式化日期时间" class="headerlink" title="格式化日期时间"></a>格式化日期时间</h1><ol><li>使用预设的格式</li></ol><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> date <span class="operator">=</span> <span class="type">DateFormatter</span>.localizedString(from: <span class="type">Date</span>(), dateStyle: .short, timeStyle: .short) <span class="comment">// 2021/4/11 下午9:15:16</span></span><br></pre></td></tr></table></figure><p>根据当前所在的Locale，将当前时间格式化，其中日期使用“短格式”、时间使用“中格式。下面是官方文档上面的一个对不同格式的示例：</p><table><thead><tr><th>Style</th><th>Date</th><th>Time</th><th>Description</th></tr></thead><tbody><tr><td>Short</td><td>6/10/13</td><td>11:03 AM</td><td>只有数字</td></tr><tr><td>Medium</td><td>Jun 10, 2013</td><td>11:03:15 AM</td><td>简短文本</td></tr><tr><td>Long</td><td>June 10, 2013</td><td>11:03:15 AM PDT</td><td>完整文本</td></tr><tr><td>Full</td><td>Friday, June 10, 2013</td><td>11:03:15 AM Pacific Daylight Time</td><td>更多细节</td></tr></tbody></table><p>下面是在不同的语言和地区中中长和短文本的时间格式：</p><table><thead><tr><th>Language (Region)</th><th>Medium style</th><th>Short style</th></tr></thead><tbody><tr><td>English (United States)</td><td>Jun 6, 2013</td><td>10:14 AM</td></tr><tr><td>French (France)</td><td>6 Jun 2013</td><td>10:14</td></tr><tr><td>Chinese (China)</td><td>2013年6月6日</td><td>上午10:14</td></tr></tbody></table><ol start="2"><li>使用自定义的日期和时间格式</li></ol><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> dateFormatter <span class="operator">=</span> <span class="type">DateFormatter</span>()</span><br><span class="line"><span class="keyword">let</span> formatterString <span class="operator">=</span> <span class="type">DateFormatter</span>.dateFormat(fromTemplate: <span class="string">&quot;MMM d&quot;</span>, options: <span class="number">0</span>, locale: dateFormatter.locale)<span class="operator">!</span>  <span class="comment">// 4月11日</span></span><br><span class="line"><span class="comment">//        let formaterString = &quot;MMM d&quot; // 4月 11</span></span><br><span class="line">dateFormatter.dateFormat <span class="operator">=</span> formatterString </span><br><span class="line"><span class="keyword">let</span> date2 <span class="operator">=</span> dateFormatter.string(from: <span class="type">Date</span>()) </span><br></pre></td></tr></table></figure><p>分两种方式创建formatterString，当使用<code>fromTemplate:options:locale</code>时得到的dateString是4月11日；直接使用普通文本时得到的dateString是4月11。</p><p>下面是几个不同语言和地区分别在使用和不使用地区格式化下的日期：</p><table><thead><tr><th>Language (Region)</th><th>Date using format string “MMM d”</th><th>Date using templat “dMMM”</th></tr></thead><tbody><tr><td>English (United States)</td><td>Nov 13</td><td>Nov 13</td></tr><tr><td>French (France)</td><td>nov. 13</td><td>13 nov.</td></tr><tr><td>Chinese (China)</td><td>11月13</td><td>11月13日｜</td></tr></tbody></table><h1 id="数字格式化"><a href="#数字格式化" class="headerlink" title="数字格式化"></a>数字格式化</h1><ol><li>使用预设样式格式化数字</li></ol><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> myNumber: <span class="type">NSNumber</span> <span class="operator">=</span> <span class="number">234231.231</span></span><br><span class="line"><span class="keyword">let</span> numberString <span class="operator">=</span> <span class="type">NumberFormatter</span>.localizedString(from: myNumber, number: .decimal)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;numberString = <span class="subst">\(numberString)</span>&quot;</span>) <span class="comment">// numberString = 234,231.231</span></span><br></pre></td></tr></table></figure><p>使用预设格式进行格式化数字时，在不同的语言和地区下的例子：</p><table><thead><tr><th>Style</th><th>Formatted string, <br> English (United States)</th><th>Formatted string,<br> Language (Region)</th></tr></thead><tbody><tr><td>Decimal（小数）</td><td>1,234.56</td><td>1.234,56 <br>Italian (Italy)</td></tr><tr><td>Currency（货币）</td><td>$1,234.56</td><td>¥1,234.56<br>Chinese (China)</td></tr><tr><td>Percent（百分数）</td><td>123,456%</td><td><img src="../../images/international-data-format/arabic_percent.svg" width="72.548" height="13.019"><br>Arabic (Egypt)</td></tr><tr><td>Scientific（科学计数法）</td><td>1.23456E+03</td><td>1,23456E3<br>Italian (Italy)</td></tr><tr><td>Spell Out（读）</td><td>one thousand two hundred thirty-four point five six</td><td>一千二百三十四点五六<br>Chinese (China)</td></tr></tbody></table><ol start="2"><li>获取用户输入的数字</li></ol><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> formatter <span class="operator">=</span> <span class="type">NumberFormatter</span>()</span><br><span class="line">formatter.numberStyle <span class="operator">=</span> .decimal</span><br><span class="line">formatter.isLenient <span class="operator">=</span> <span class="literal">true</span></span><br><span class="line"><span class="keyword">let</span> number <span class="operator">=</span> formatter.number(from: <span class="string">&quot;1,234,123.23&quot;</span>)<span class="operator">!</span></span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;number = <span class="subst">\(number)</span>&quot;</span>) <span class="comment">// number = 1234123.23</span></span><br></pre></td></tr></table></figure><p>使用系统当前的语言和地区把用户输入的带有当地特色的数字字符串转化成<code>Number</code>格式。其中<code>isLenient</code>表示是否允许格式不完全按照标准格式，例如如果这里使用<code>formatter.isLenient = false</code>，当输入字符串只要不是标准的<em>1,234,123.23</em>而是<em>1,23,4123.23</em>或者1,234123.23就会返回nil。</p><h1 id="关于日历的本地化"><a href="#关于日历的本地化" class="headerlink" title="关于日历的本地化"></a>关于日历的本地化</h1><p>不同地区之间的纪年方法有很大的差别，日本的年代变化很快（他们还在用天皇纪年，就像咱们中国的封建社会）而公历或者农历的年代变化就相对较慢，而有的地区一年有13个月，不同的日历对每周的第一天定义也不同（周六、周日、周一都有）。要处理这么复杂多变的日历相关问题就一定要用到<code>Calender</code>类。</p><p>获取用户当前使用的日历使用<code>Calendar.current</code>。</p><p>获取一个日期的组成部分：</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> calendar <span class="operator">=</span> <span class="type">Calendar</span>.current</span><br><span class="line"><span class="keyword">let</span> components <span class="operator">=</span> calendar.dateComponents([.era, .year, .month, .weekday, .day, .hour, .minute, .second], from: <span class="type">Date</span>())</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;当前时间组件：<span class="subst">\(String(describing: components.era<span class="operator">!</span>))</span>, <span class="subst">\(String(describing: components.year<span class="operator">!</span>))</span>, <span class="subst">\(String(describing: components.month<span class="operator">!</span>))</span>, <span class="subst">\(String(describing: components.weekday<span class="operator">!</span>))</span>, <span class="subst">\(String(describing: components.day<span class="operator">!</span>))</span>, <span class="subst">\(String(describing: components.hour<span class="operator">!</span>))</span>, <span class="subst">\(String(describing: components.minute<span class="operator">!</span>))</span>, <span class="subst">\(String(describing: components.second<span class="operator">!</span>))</span>&quot;</span>) <span class="comment">// 当前时间组件：1, 2021, 4, 1, 11, 22, 32, 4</span></span><br></pre></td></tr></table></figure><blockquote><p>当使用日本历或者佛教日历的时候，每次获取或者设置年份一定要同时获取或者设置年代。</p></blockquote><p>更多关于日历的内容可以参考一下<a href="https://developer.apple.com/library/archive/documentation/Cocoa/Conceptual/DatesAndTimes/DatesAndTimes.html#//apple_ref/doc/uid/10000039i">官方文档</a></p><h1 id="Locale和时区相关的通知"><a href="#Locale和时区相关的通知" class="headerlink" title="Locale和时区相关的通知"></a>Locale和时区相关的通知</h1><p>要及时的获取Locale或者时区变化的通知可以监听<code>NSCurrentLocaleDidChangeNotification</code>和<code>NSSystemTimeZoneDidChangeNotification</code>通知。</p><p>获取通知在用户进行跨国长途旅行的时候非常有用，当用户时区改变后app能够及时变化可以给用户一个非常棒的体验。</p><div class="note info"><p>到公众号【iOS开发栈】学习更多SwiftUI、iOS开发相关内容。</p></div><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>想要很完善的本地化一个App是不容易的，不仅要把文字本地化还要把日期、时间、日历、数字等内容本地化，这些内容在一个app中是无处不在的，这就要求我们要随时记着自己是在做一个国际化的App。为了能给全世界各地的用户一个更好的使用体验，尽力做好这项工作吧。</p>]]></content>
    
    
    <summary type="html">&lt;p&gt;不同的国家、地区对一些诸如日期、时间、数字、货币等方面有不同的表述方式，为了更好的满足当地人的使用习惯和习俗，App必须做好这些方面的国际化工作。这是一项重要且复杂的工作，希望通过这篇可以让你对这些内容有一个全面的了解。&lt;/p&gt;</summary>
    
    
    
    
    <category term="Xcode" scheme="http://www.iosprogrammer.tech/tags/Xcode/"/>
    
  </entry>
  
  <entry>
    <title>苹果官方的iOS App国际化工作流</title>
    <link href="http://www.iosprogrammer.tech/xcode/international-user-facing-text/"/>
    <id>http://www.iosprogrammer.tech/xcode/international-user-facing-text/</id>
    <published>2021-04-05T09:08:21.000Z</published>
    <updated>2021-04-05T10:25:27.017Z</updated>
    
    <content type="html"><![CDATA[<p>国际化是出海应用非常重要的一个基础步骤，其中多语言的适配是重中之重。Xcode自带了帮助开发者进行App本地化的功能，其中包括多语言文件的导入和导出，使用这些功能可以很丝滑的完成多语言的工作。</p><a id="more"></a><p><img src="../../images/first/international-user-facing-text.png" alt="iOS国际化"></p><div class="note info"><p>到公众号【iOS开发栈】学习更多SwiftUI、iOS开发相关内容。</p></div><p>App中有一些固定内容的控件是可以直接利用IB文件来做多语言的，具体方法可以查看一下之前的<a href="https://www.iosprogrammer.tech/xcode/language-internalization-ib/">这篇文章</a>，文章中也讲了怎么添加多语言的操作。</p><p>除了一些固定内容的控件之外还会有一些其他内容需要开发者通过代码的形式来本地化，比如可变内容的控件、错误提示信息、富文本、App名称等。通过下面几个步骤可以给这些内容添加多语言。</p><h1 id="标记需要本地化的文本"><a href="#标记需要本地化的文本" class="headerlink" title="标记需要本地化的文本"></a>标记需要本地化的文本</h1><p>Foundation框架中使用<code>NSLocalizedString(_:tableName:bundle:value:comment:)</code>来标记需要本地化的文本，通常tableName/bundle和value直接使用默认值就可以了。</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">NSLocalizedString</span>(<span class="string">&quot;Label1&quot;</span>, comment: <span class="string">&quot;This is the first label&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 上面的代码最终的样子</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* This is the first label */</span></span><br><span class="line"><span class="string">&quot;Label1&quot;</span> <span class="operator">=</span> <span class="string">&quot;First Label 111&quot;</span>;</span><br></pre></td></tr></table></figure><p>翻译文件是key-value的格式，其中key是<code>NSLocalizedString</code>函数中的第一个参数，在这里就是<em>Label1</em>。默认的value也是<em>Label1</em>。</p><p><code>comment</code>参数是这对key-value的注释，主要是在进行人工翻译的时候提供一个说明作用，尤其是当有多个相似的文本时这个注释就有作用了。</p><h1 id="使用Xcode导出本地化多语言文件"><a href="#使用Xcode导出本地化多语言文件" class="headerlink" title="使用Xcode导出本地化多语言文件"></a>使用Xcode导出本地化多语言文件</h1><p>当还没有进行翻译的时候，使用<code>NSLocalizedString</code>的地方就会显示<em>key</em>文本，Xcode会在导出多语言文件的时候在项目中搜寻这个函数。</p><p>导出多语言文件的步骤如下：</p><ol><li>使用Xcode打开项目</li><li>在左侧的目录导航栏中点击项目名打开.xcodeproj</li><li>在PROJECT中选择项目名，并在Info选项卡的Locations中添加上其他语言</li><li>点击Xcode菜单栏中Editor选项的Export for Localization</li><li>选择导出的文件夹并命名后点击导出</li></ol><h1 id="修改本地化多语言文件"><a href="#修改本地化多语言文件" class="headerlink" title="修改本地化多语言文件"></a>修改本地化多语言文件</h1><p>导出的文件中包含多个.xcloc子文件夹，每一个xloc文件夹中的Localized Contents下的.xliff文件就是要填写翻译内容的文件。</p><p>打开xliff文件并在其中搜索“<source>”，搜索到的文本就是需要翻译的内容。每个<source>对应一个<target>，把译文放到<target>和</target>中间。就像这样：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&lt;source&gt;First Label 111&lt;&#x2F;source&gt;</span><br><span class="line">&lt;target&gt;第一个文本&lt;&#x2F;target&gt;</span><br></pre></td></tr></table></figure><p>source是Development Language的语言文本，target是译文。上面这个例子的Development Language是英文，target是中文。</p><p>source不是<code>NSLocalizedString</code>第一个参数指定的key，而是Development Language下key对应的value，所以如果开发语言的译文变了，这里的source也会变。</p><h1 id="使用Xcode导入本地化多语言文件"><a href="#使用Xcode导入本地化多语言文件" class="headerlink" title="使用Xcode导入本地化多语言文件"></a>使用Xcode导入本地化多语言文件</h1><p>把所有需要翻译的内容翻译完成后，使用Xcode打开项目，并打开.xcodeproj后选择Editor-&gt;Import Localizations，打开翻译文件所在的目录把.xcloc挨个导入就可以了。</p><p>这里建议先翻译并导入Development Language的.xcloc文件夹，再执行一次导出操作后再翻译其他语言并导入。因为第一次导出时source是NSLocalizedString的第一个参数，而这个参数可能并不是主语言的最终翻译，如果其他语言都把第一个参数作为source来翻译就会造成找不到对应翻译的问题。</p><div class="note info"><p>到公众号【iOS开发栈】学习更多SwiftUI、iOS开发相关内容。</p></div><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>iOS和MacOS系统以及它们自带的App在本地化方面做的非常出色，所以我们在没有特殊要求的情况下尽量依赖Xcode提供的功能来实现本地化的需求。</p>]]></content>
    
    
    <summary type="html">&lt;p&gt;国际化是出海应用非常重要的一个基础步骤，其中多语言的适配是重中之重。Xcode自带了帮助开发者进行App本地化的功能，其中包括多语言文件的导入和导出，使用这些功能可以很丝滑的完成多语言的工作。&lt;/p&gt;</summary>
    
    
    
    
    <category term="Xcode" scheme="http://www.iosprogrammer.tech/tags/Xcode/"/>
    
  </entry>
  
  <entry>
    <title>必看！2个关于iOS开发多语言的知识点</title>
    <link href="http://www.iosprogrammer.tech/xcode/iphone-selected-language/"/>
    <id>http://www.iosprogrammer.tech/xcode/iphone-selected-language/</id>
    <published>2021-04-05T03:18:11.000Z</published>
    <updated>2021-04-05T09:20:15.145Z</updated>
    
    <content type="html"><![CDATA[<p>在把App进行国际化的过程中会遇到很多问题，这篇文章来看一下Development Language是什么以及怎么修改它，并且看一下系统是怎么来选择使用哪个语言的。</p><a id="more"></a><div class="note info"><p>到公众号【iOS开发栈】学习更多SwiftUI、iOS开发相关内容。</p></div><h1 id="什么是Development-Language和怎么修改它"><a href="#什么是Development-Language和怎么修改它" class="headerlink" title="什么是Development Language和怎么修改它"></a>什么是Development Language和怎么修改它</h1><p>在进行国际化的过程中需要把App中的文字翻译成多个语言，其中有一种语言是Development Language，当没有任何一种语言满足当前设备的时候系统会使用Development Language。</p><p>可以通过修改<em>project.pbxproj</em>文件来修改Development Language。</p><ol><li>打开项目所在文件夹</li><li>右击.xcodeproj文件并选择*Show package Content(显示包内容)*（应该是第三个选项）</li><li>双击<em>project.phxproj</em>打开文件</li><li>搜索<em>developmentRegion</em>，并将内容修改为想要的语言。这个地方的语言是在我们添加多语言时的缩写，比如English=en、Chinese, Simpilied=zh-Hans等等。</li></ol><h1 id="iPhone是怎么选择当前使用的语言的"><a href="#iPhone是怎么选择当前使用的语言的" class="headerlink" title="iPhone是怎么选择当前使用的语言的"></a>iPhone是怎么选择当前使用的语言的</h1><ol><li>在iPhone手机的设置中“语言与地区”选择的“iPhone语言”是最高优先级，如果App的多语言包含这里设置的语言会直接使用。</li><li>如果App的多语言不包含“iPhone语言”，那么会查找“首选语言顺序”中是否有包含在多语言中的语言，按照从上到下的顺序找到一个语言后会直接使用这个语言。</li><li>如果“首选语言顺序”中也没有符合要求的，那么会使用Development Language作为App的语言。</li></ol><div class="note info"><p>到公众号【iOS开发栈】学习更多SwiftUI、iOS开发相关内容。</p></div>]]></content>
    
    
    <summary type="html">&lt;p&gt;在把App进行国际化的过程中会遇到很多问题，这篇文章来看一下Development Language是什么以及怎么修改它，并且看一下系统是怎么来选择使用哪个语言的。&lt;/p&gt;</summary>
    
    
    
    
    <category term="Xcode" scheme="http://www.iosprogrammer.tech/tags/Xcode/"/>
    
  </entry>
  
  <entry>
    <title>iOS App国际化必看！使用Xib使App完成国际化功能</title>
    <link href="http://www.iosprogrammer.tech/xcode/language-internalization-ib/"/>
    <id>http://www.iosprogrammer.tech/xcode/language-internalization-ib/</id>
    <published>2021-03-28T13:50:56.000Z</published>
    <updated>2021-03-28T14:31:11.023Z</updated>
    
    <content type="html"><![CDATA[<p>利用Xib或者Storyboard来做iOS的国际化是一种特别方便且高效的方式。通过简单的设置后就可以在不同的文件中把内容翻译为不同的语种，这篇文章我们来了解一下利用IB来做国际化要注意的一些问题，希望能够对你有所帮助。</p><a id="more"></a><div class="note info"><p>到公众号【iOS开发栈】学习更多SwiftUI、iOS开发相关内容。</p></div><p><img src="../../images/xcode-internaiton-ib/cover.png"></p><h1 id="完整了解国际化步骤"><a href="#完整了解国际化步骤" class="headerlink" title="完整了解国际化步骤"></a>完整了解国际化步骤</h1><p><img src="../../images/xcode-internaiton-ib/overview.png"></p><ol><li>增加国际化语言。在xcode左侧的项目目录树中点击<strong>项目名称-&gt;点击“PROJECT”中的项目名称-&gt;Info-&gt;Locatlizations</strong>，之后点击+号就可以增加自己需要的语言了。</li><li>在选择要增加的语言之后会弹出设置弹窗，把需要国际化的IB（Xib、Storyboard）文件勾选上，并且在File Types选项中选择<em>Localizable Strings</em>。</li><li>项目目录树中对应的IB文件就会成为文件夹的形式，可以看到刚刚添加的语言文件（*.strings(xxx)）。</li></ol><h1 id="添加过语言后又要增加UILabel等控件国际化"><a href="#添加过语言后又要增加UILabel等控件国际化" class="headerlink" title="添加过语言后又要增加UILabel等控件国际化"></a>添加过语言后又要增加UILabel等控件国际化</h1><p>随着版本的升级或者需求的改变，我们的IB文件很可能会发生变化，由于我们使用了IB文件进行国际化，又不能每次改版重新做一遍国际化的工作，这就要求我们可以定位到新增的控件并设置语言。</p><p>在xxx.storyboad(Base)文件中选中增加的控件，打开右侧帮助栏，找到第四个选项卡(Show the Identity Inspector)，其中有一个<strong>Object ID</strong>。</p><p>把这个ID复制到其他语言的.strings文件中，就可以设置对应的语言翻译了。其中UILabel、UIButton和UITextFiled的placehoder的设置方法如下:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;* Class &#x3D; &quot;UITextField&quot;; placeholder &#x3D; &quot;ios&quot;; ObjectID &#x3D; &quot;RCg-HC-Mcn&quot;; *&#x2F;</span><br><span class="line">&quot;RCg-HC-Mcn.placeholder&quot; &#x3D; &quot;ios&quot;;</span><br><span class="line"></span><br><span class="line">&#x2F;* Class &#x3D; &quot;UIButton&quot;; normalTitle &#x3D; &quot;Button&quot;; ObjectID &#x3D; &quot;isH-qk-FQm&quot;; *&#x2F;</span><br><span class="line">&quot;isH-qk-FQm.normalTitle&quot; &#x3D; &quot;Button&quot;;</span><br><span class="line"></span><br><span class="line">&#x2F;* Class &#x3D; &quot;UILabel&quot;; text &#x3D; &quot;iosprogrammer.tech&quot;; ObjectID &#x3D; &quot;pLC-qp-tdZ&quot;; *&#x2F;</span><br><span class="line">&quot;pLC-qp-tdZ.text&quot; &#x3D; &quot;iosprogrammer.tech&quot;;</span><br></pre></td></tr></table></figure><h1 id="一些总结"><a href="#一些总结" class="headerlink" title="一些总结"></a>一些总结</h1><ol><li>如果一个用户的设备系统语言是没有进行适配的，他下载了应用后，将会使用Base语言。比如一个葡萄言语的用户下载了一个适配了日文和韩文的app，并且这个app的Base语言是日文，那么这个用户将会看到日文。</li><li>从一个已经适配的语言切换到一个没有适配的语言，仍然会使用切换前的语言。比如从适配了的中文简体切换到了没有适配的日文，那用户看到的仍然会是中文简体。</li></ol><div class="note info"><p>到公众号【iOS开发栈】学习更多SwiftUI、iOS开发相关内容。</p></div><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>通过这篇文章我们学习了几个在使用IB来做iOS国际化的过程中需要注意的地方，如果想要充分了解到这方面的知识建议通篇阅读一下<a href="https://developer.apple.com/library/archive/documentation/MacOSX/Conceptual/BPInternational/Introduction/Introduction.html#//apple_ref/doc/uid/10000171i-CH1-SW1">官方文档</a>。</p>]]></content>
    
    
    <summary type="html">&lt;p&gt;利用Xib或者Storyboard来做iOS的国际化是一种特别方便且高效的方式。通过简单的设置后就可以在不同的文件中把内容翻译为不同的语种，这篇文章我们来了解一下利用IB来做国际化要注意的一些问题，希望能够对你有所帮助。&lt;/p&gt;</summary>
    
    
    
    
    <category term="Xcode" scheme="http://www.iosprogrammer.tech/tags/Xcode/"/>
    
  </entry>
  
  <entry>
    <title>告诉你3个容易被忽略的可能造成循环引用的情况和2种不会造成循环引用的情况</title>
    <link href="http://www.iosprogrammer.tech/ios/retain-cycle-problems/"/>
    <id>http://www.iosprogrammer.tech/ios/retain-cycle-problems/</id>
    <published>2021-03-19T05:16:18.000Z</published>
    <updated>2021-04-14T00:57:35.196Z</updated>
    
    <content type="html"><![CDATA[<p>循环引用是iOS开发种十分常见的一个问题，也是面试中出现频率很高的一类问题，有些经验的开发者对循环引用都有所了解，也能在开发过程中尽量避免此类问题，但是随着项目的扩大和开发时间有限有时会不经意见给引用循环引用的问题。</p><p>这类问题虽然很多时候不会出现严重的影响，但是在其他一些条件下可能会带来很蹊跷的现象，本人就深受其害。所以在这里记录一下关于循环引用的一些常用知识，也希望对你有所帮助。</p><a id="more"></a><div class="note info"><p>到公众号【iOS开发栈】学习更多SwiftUI、iOS开发相关内容。</p></div><h1 id="什么是循环引用"><a href="#什么是循环引用" class="headerlink" title="什么是循环引用"></a>什么是循环引用</h1><p>造成循环引用问题的根本原因是iOS的引用计数机制，而在引用计数机制下如果有引用不能得到即时的释放就会造成了内存泄漏，这就是循环引用。</p><p>并且为了维持App的高性能，苹果并不没有也不打算引入类似Android中的垃圾回收机制。这就造成了如果我们导致了循环引用，那么这块内存就无法得到回收。</p><p>泄漏的内存多了会造成系统强制kill掉我们的应用程序，虽然这种现象我还没有见到过不过原理上来说会出现这种情况的。</p><p>一旦有没有得到即时回收的对象内存，还可能造成一些无可预期的问题。比方说我遇到的一个问题：由于一个VC没有得到即时释放，导致里面的一个定时任务不停执行，最终导致了营收不及预期。</p><p>所以循环引用的问题，我们在开发的过程中一定要重视起来。</p><h1 id="下面3种情况会造成循环引用"><a href="#下面3种情况会造成循环引用" class="headerlink" title="下面3种情况会造成循环引用"></a>下面3种情况会造成循环引用</h1><p>会造成循环引用问题的情形很多，下面我列举了3种情况，其中有一些是老生长谈，有些是需要特别注意的，有些真的是手滑造成的。</p><p>在编码过程中时刻谨记这些情况真的可以避免很多错误发生。</p><h3 id="block"><a href="#block" class="headerlink" title="block"></a>block</h3><p>这里的block指的是view对vc的回调、model对vc的回调或者子view对父view的回调。</p><p>不论是子view还是vc中的model，我们都习惯于用strong来修饰它们，这时候在它们的block回调里面用到<code>self</code>的时候一定要用<code>weak self</code>。</p><p>并且，切记成员变量<code>_xxx</code>如果在这种block中使用也会造成循环引用。使用弱指针来指向成员变量是一种解决方案，就像这样<code>self-&gt;_redView.backgroundColor = [UIColor greenColor];</code></p><h3 id="strong修饰的delegate"><a href="#strong修饰的delegate" class="headerlink" title="strong修饰的delegate"></a>strong修饰的delegate</h3><p>我们都知道delegate要使用weak来修饰，不过在编码过程中由于疏忽可能会误用strong来修饰delegate，所以如果当你遇到循环引用可是怎么也找不到原因时，不妨从这个思路找找。我就遇到过这种情况😭 。</p><h3 id="一些异步回调"><a href="#一些异步回调" class="headerlink" title="一些异步回调"></a>一些异步回调</h3><p>有一些异步回调是使用block的形式来处理的，这就可能引起循环引用。</p><p>有一些系统的功能比方说NSTimer的定时任务就会对self造成强引用。</p><p>还有一些是我们自己的功能比方说网络请求.</p><h1 id="下面2种情况不会造成循环引用"><a href="#下面2种情况不会造成循环引用" class="headerlink" title="下面2种情况不会造成循环引用"></a>下面2种情况不会造成循环引用</h1><h3 id="用Masonry给view添加约束"><a href="#用Masonry给view添加约束" class="headerlink" title="用Masonry给view添加约束"></a>用Masonry给view添加约束</h3><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">[<span class="keyword">self</span>.redView mas_makeConstraints:^(MASConstraintMaker *make) &#123;</span><br><span class="line">    make.top.equalTo(@<span class="number">130</span>);</span><br><span class="line">    make.left.equalTo(<span class="keyword">self</span>.view.mas_left).offset(<span class="number">10</span>);</span><br><span class="line">    make.width.equalTo(@<span class="number">60</span>);</span><br><span class="line">    make.height.equalTo(@<span class="number">40</span>);</span><br><span class="line">&#125;];</span><br></pre></td></tr></table></figure><p>这种用法是不会造成循环引用的，可以放心使用。</p><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">- (<span class="built_in">NSArray</span> *)mas_makeConstraints:(<span class="keyword">void</span>(^)(MASConstraintMaker *))block &#123;</span><br><span class="line">    <span class="keyword">self</span>.translatesAutoresizingMaskIntoConstraints = <span class="literal">NO</span>;</span><br><span class="line">    MASConstraintMaker *constraintMaker = [[MASConstraintMaker alloc] initWithView:<span class="keyword">self</span>];</span><br><span class="line">    block(constraintMaker);</span><br><span class="line">    <span class="keyword">return</span> [constraintMaker install];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>从源码来看，这里的block其实是一个同步的方法，所以这里是不会造成循环引用的。</p><h3 id="使用UIView静态方法实现动画"><a href="#使用UIView静态方法实现动画" class="headerlink" title="使用UIView静态方法实现动画"></a>使用UIView静态方法实现动画</h3><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">[<span class="built_in">UIView</span> animateWithDuration:<span class="number">3</span> animations:^&#123;</span><br><span class="line">    <span class="keyword">self</span>.redView.backgroundColor = [<span class="built_in">UIColor</span> greenColor];</span><br><span class="line">&#125;];</span><br></pre></td></tr></table></figure><p>这种情况虽然在block里面引用到了self，但是不会造成循环引用。因为<code>animateWithDuration:</code>是一个类方法。</p><h1 id="开发中怎么解决循环引用问题"><a href="#开发中怎么解决循环引用问题" class="headerlink" title="开发中怎么解决循环引用问题"></a>开发中怎么解决循环引用问题</h1><p>首先这里的方法并不是什么工程级别的高深方法，只是我在开发过程中总结到的一些实用、便捷的小技巧。</p><p>当怀疑某个控制器没有得到即时的释放时，可以在这个控制器里面重写<code>dealloc</code>函数然后打印一行文字，再在这行文字上加一个断点。这样我们就可以通过进出这个控制器来看到它的<code>dealloc</code>方法是不是即时被调用了。如果没有即时调用那就是有循环引用产生，相反则没有。</p><p>确定了某个控制器内确实出现了循环引用之后，就需要定位是哪里导致的循环引用了。</p><p>我个人习惯先看是不是block导致的，要想快速的搜索到一个文件里面所有的block可以通过搜索<code>^&#123;</code>来定位，之后就是检查每个block里面是不是按规范使用了<code>self</code>。检查过程一定要仔细，不然你很可能还得重来一遍😭 。</p><p>检查完所有的block后有99%的可能已经解决了循环引用的问题，不然的话就再去检查一下delegate和是不是使用了<code>NSTimer</code>。</p><p>这个过程下来100%可以解决掉循环引用的问题，否则你来公众号找我。</p><div class="note info"><p>到公众号【iOS开发栈】学习更多SwiftUI、iOS开发相关内容。</p></div>]]></content>
    
    
    <summary type="html">&lt;p&gt;循环引用是iOS开发种十分常见的一个问题，也是面试中出现频率很高的一类问题，有些经验的开发者对循环引用都有所了解，也能在开发过程中尽量避免此类问题，但是随着项目的扩大和开发时间有限有时会不经意见给引用循环引用的问题。&lt;/p&gt;
&lt;p&gt;这类问题虽然很多时候不会出现严重的影响，但是在其他一些条件下可能会带来很蹊跷的现象，本人就深受其害。所以在这里记录一下关于循环引用的一些常用知识，也希望对你有所帮助。&lt;/p&gt;</summary>
    
    
    
    
    <category term="iOS" scheme="http://www.iosprogrammer.tech/tags/iOS/"/>
    
  </entry>
  
  <entry>
    <title>SwiftUI怎么实现UISearchBar</title>
    <link href="http://www.iosprogrammer.tech/swiftui/swiftui-searchbar/"/>
    <id>http://www.iosprogrammer.tech/swiftui/swiftui-searchbar/</id>
    <published>2021-03-13T13:33:16.000Z</published>
    <updated>2021-03-13T14:08:04.238Z</updated>
    
    <content type="html"><![CDATA[<p>SwiftUI没有提供UISearchBar，虽然我们可以通过使用TextField来自己实现SeachBar的效果，不过要想实现一个和UISearchBar同样的控件并不容易，尤其是清除按钮和搜索图标。</p><p>这里推荐直接使用UISearchBar和UIViewRepresentable协议来一个SearchBar。</p><a id="more"></a><div class="note info"><p>到公众号【iOS开发栈】学习更多SwiftUI、iOS开发相关内容。</p></div><p><img src="../../images/first/swiftui-uisearchbar.png"></p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">SearchBar</span>: <span class="title">UIViewRepresentable</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Binding</span> <span class="keyword">var</span> text: <span class="type">String</span></span><br><span class="line">    <span class="keyword">var</span> placeholder: <span class="type">String</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">var</span> onCommit: ((<span class="keyword">_</span> text: <span class="type">String</span>) -&gt; <span class="type">Void</span>)<span class="operator">?</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">func</span> <span class="title">makeUIView</span><span class="params">(context: UIViewRepresentableContext&lt;SearchBar&gt;)</span></span> -&gt; <span class="type">UISearchBar</span> &#123;</span><br><span class="line">        <span class="keyword">let</span> searchBar <span class="operator">=</span> <span class="type">UISearchBar</span>(frame: .zero)</span><br><span class="line">        searchBar.delegate <span class="operator">=</span> context.coordinator</span><br><span class="line"></span><br><span class="line">        searchBar.placeholder <span class="operator">=</span> placeholder</span><br><span class="line">        searchBar.autocapitalizationType <span class="operator">=</span> .none</span><br><span class="line">        searchBar.searchBarStyle <span class="operator">=</span> .minimal</span><br><span class="line">        <span class="keyword">return</span> searchBar</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">func</span> <span class="title">updateUIView</span><span class="params">(<span class="keyword">_</span> uiView: UISearchBar, context: UIViewRepresentableContext&lt;SearchBar&gt;)</span></span> &#123;</span><br><span class="line">        uiView.text <span class="operator">=</span> text</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">func</span> <span class="title">makeCoordinator</span><span class="params">()</span></span> -&gt; <span class="type">SearchBar</span>.<span class="type">Coordinator</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="type">Coordinator</span>(text: <span class="variable">$text</span>, onCommit: <span class="keyword">self</span>.onCommit)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="class"><span class="keyword">class</span> <span class="title">Coordinator</span>: <span class="title">NSObject</span>, <span class="title">UISearchBarDelegate</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="meta">@Binding</span> <span class="keyword">var</span> text: <span class="type">String</span></span><br><span class="line">        <span class="keyword">var</span> onCommit: ((<span class="keyword">_</span> text: <span class="type">String</span>) -&gt; <span class="type">Void</span>)<span class="operator">?</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">init</span>(text: <span class="type">Binding</span>&lt;<span class="type">String</span>&gt;, onCommit: ((<span class="keyword">_</span> text: <span class="type">String</span>) -&gt; <span class="type">Void</span>)<span class="operator">?</span>) &#123;</span><br><span class="line">            _text <span class="operator">=</span> text</span><br><span class="line">            <span class="keyword">self</span>.onCommit <span class="operator">=</span> onCommit</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">func</span> <span class="title">searchBar</span><span class="params">(<span class="keyword">_</span> searchBar: UISearchBar, textDidChange searchText: String)</span></span> &#123;</span><br><span class="line">            text <span class="operator">=</span> searchText</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="function"><span class="keyword">func</span> <span class="title">searchBarSearchButtonClicked</span><span class="params">(<span class="keyword">_</span> searchBar: UISearchBar)</span></span> &#123;</span><br><span class="line">            <span class="keyword">if</span> <span class="keyword">let</span> onCommit <span class="operator">=</span> <span class="keyword">self</span>.onCommit &#123;</span><br><span class="line">                onCommit(searchBar.text <span class="operator">??</span> <span class="string">&quot;&quot;</span>)</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>UIViewRepresentable</code>是SwiftUI框架中提供的用于将UIView转换成SwiftUI中View的协议。</p><p><code>func makeUIView(context: Self.Context) -&gt; Self.UIViewType</code>用来创建View的方法，遵守UIViewRepresentable协议的类必须要实现这个方法。它的返回值是一个UIView类的实例。这个方法只会在创建View时调用一次，当View需要更新时会调用下面的这个方法。</p><p><code>func updateUIView(_ uiView: Self.UIViewType, context: Self.Context)</code>当UIView发生任何需要更新状态的事件时，这个方法就会被调用来更新View的状态。</p><p><code>func makeCoordinator() -&gt; Self.Coordinator</code>需要一个<code>Coordinator</code>的实例作为返回值。它通常用来处理一些事件（点击、时间、delegate、通知）引起了UIView的状态变化后，能够将新的状态反映到View上。</p><div class="note info"><p>到公众号【iOS开发栈】学习更多SwiftUI、iOS开发相关内容。</p></div>]]></content>
    
    
    <summary type="html">&lt;p&gt;SwiftUI没有提供UISearchBar，虽然我们可以通过使用TextField来自己实现SeachBar的效果，不过要想实现一个和UISearchBar同样的控件并不容易，尤其是清除按钮和搜索图标。&lt;/p&gt;
&lt;p&gt;这里推荐直接使用UISearchBar和UIViewRepresentable协议来一个SearchBar。&lt;/p&gt;</summary>
    
    
    
    
    <category term="SwiftUI" scheme="http://www.iosprogrammer.tech/tags/SwiftUI/"/>
    
  </entry>
  
  <entry>
    <title>iOS设置渐变色，给border设置渐变色</title>
    <link href="http://www.iosprogrammer.tech/ios/ios-gradient-color/"/>
    <id>http://www.iosprogrammer.tech/ios/ios-gradient-color/</id>
    <published>2021-03-07T12:50:56.000Z</published>
    <updated>2021-03-08T01:50:12.123Z</updated>
    
    <content type="html"><![CDATA[<p>本文将从4行代码出发给一个view设置渐变色，分别会谈到几个重要的渐变色相关属性，在使用过程中有几个需要特别关注的点。</p><p>给一个view的border设置渐变色是比较高阶的用法，希望本文可以在这个方面帮助到你。</p><a id="more"></a><p><img src="../../images/first/ios-gradient-color-border.png" alt="ios渐变色"></p><div class="note info"><p>到公众号【iOS开发栈】学习更多SwiftUI、iOS开发相关内容。</p></div><h1 id="给view设置渐变色"><a href="#给view设置渐变色" class="headerlink" title="给view设置渐变色"></a>给view设置渐变色</h1><p>通过4行代码就可以给一个view设置渐变色：</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> view <span class="operator">=</span> <span class="type">UIView</span>(frame: <span class="type">CGRect</span>(x: <span class="number">100</span>, y: <span class="number">100</span>, width: <span class="number">100</span>, height: <span class="number">100</span>))</span><br><span class="line"><span class="keyword">let</span> gradientLayer <span class="operator">=</span> <span class="type">CAGradientLayer</span>()</span><br><span class="line">gradientLayer.frame <span class="operator">=</span> view.bounds</span><br><span class="line"><span class="comment">// @[(__bridge id)[UIColor redColor].CGColor, (__bridge id)[UIColor yellowColor].CGColor]</span></span><br><span class="line">gradientLayer.colors <span class="operator">=</span> [<span class="type">UIColor</span>.red.cgColor, <span class="type">UIColor</span>.yellow.cgColor]</span><br><span class="line">view.layer.addSublayer(gradientLayer)</span><br></pre></td></tr></table></figure><p>在创建<code>CAGradientLayer</code>以后需要设置<code>frame</code>才能展示出来，否则它的大小会使用默认的0。</p><p>渐变色会根据<code>colors</code>数组来展示，这个数组的类型是<code>CGColorRef</code>，所以需要用<code>.cgColor</code>强制转换；如果使用的OC语法，必须加上<code>(__bridge id)</code>，否则渐变色会显示不出来。</p><p>默认情况下渐变会从上至下，可是通过设置<code>startPoint</code>和<code>endPoint</code>来改变这个顺序：</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">gradientLayer.startPoint <span class="operator">=</span> <span class="type">CGPoint</span>(x: <span class="number">0</span>, y: <span class="number">0</span>)</span><br><span class="line">gradientLayer.endPoint <span class="operator">=</span> <span class="type">CGPoint</span>(x: <span class="number">1</span>, y: <span class="number">1</span>)</span><br></pre></td></tr></table></figure><p>这两个点的范围是从0到1，也就是说最左边和最上边是0，最下和最右是1。这个例子中渐变会变成从左上角到右下角。</p><p>渐变色还有一个重要的属性是<code>locations</code>，这个属性是用来指定<code>colors</code>中设置的每个颜色的终点的。</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">gradientLayer.locations <span class="operator">=</span> [<span class="number">0.2</span>, <span class="number">0.8</span>]</span><br></pre></td></tr></table></figure><p>locations中元素的范围是从0到1。在这里，数组中的第一个元素<em>0.2</em>指定了colors数组中第一个元素<em>红色</em>的终点是0.2，也就是说把整个渐变色范围分成10份，从开始到<em>2/10</em>处都是纯红色，从<em>2/10</em>到<em>8/10</em>处是纯红色到纯黄色的渐变，而从<em>8/10</em>到<em>10/10</em>是纯黄色。</p><h1 id="给view的border设置渐变色"><a href="#给view的border设置渐变色" class="headerlink" title="给view的border设置渐变色"></a>给view的border设置渐变色</h1><p>使用<code>UIBezierPath</code>来创建一个带圆角的<code>CAShapeLayer</code>，并且把它的圆角设置成view的圆角，就可以把一个view的border设置为渐变色。</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="operator">...</span> <span class="comment">// 同上给view设置gradientLayer</span></span><br><span class="line">        </span><br><span class="line"><span class="keyword">let</span> shapeLayer <span class="operator">=</span> <span class="type">CAShapeLayer</span>()</span><br><span class="line">shapeLayer.borderWidth <span class="operator">=</span> <span class="number">1</span></span><br><span class="line">shapeLayer.path <span class="operator">=</span> <span class="type">UIBezierPath</span>(roundedRect: gradientLayer.bounds, cornerRadius: <span class="number">10</span>).cgPath</span><br><span class="line">shapeLayer.fillColor <span class="operator">=</span> <span class="type">UIColor</span>.clear.cgColor <span class="comment">// 必须要设置成clearColor或者nil，默认是黑色</span></span><br><span class="line">shapeLayer.strokeColor <span class="operator">=</span> <span class="type">UIColor</span>.white.cgColor <span class="comment">// 随便设置一个非clearColor的颜色</span></span><br><span class="line">        </span><br><span class="line">gradientLayer.mask <span class="operator">=</span> shapeLayer</span><br><span class="line"></span><br><span class="line">view.layer.addSublayer(gradientLayer)</span><br></pre></td></tr></table></figure><ol><li><em>borderWidth</em> shapeLayer的border宽度和view的相同，可以根据设计图来设置。</li><li><em>cornerRadius</em> UIBezierPath的圆角和view的圆角相同；<em>roundedRect</em>和<em>CAGradientLayer</em>的大小相同。</li><li><em>fillColor</em> 是shapeLayer的填充色，默认是黑色，建议设置成nil或者是透明色<code>clearColor</code></li><li><em>strokeColor</em> 是border的描边色，如果设置成clearColor的话就不会绘制出来border了，这里随便一个颜色就是让其能够绘制出来，实际使用的是渐变色</li><li><em>mask</em> 用shapeLayer作为gradientLayer的mask，可以让gradientLayer内部挖空，只保留边缘border的渐变颜色</li><li>最终把渐变色layer添加到view.layer上，shapeLayer只是用来修饰gradientlayer的，目的是把gradientlayer的内部挖空，并且把border和圆角做出来。</li></ol><div class="note info"><p>到公众号【iOS开发栈】学习更多SwiftUI、iOS开发相关内容。</p></div><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>通过这篇文章我们了解了怎么给一个view设置渐变色，并详细阐述了渐变色的几个重要属性。关于给border设置渐变色是一个进阶的知识点。</p><p>希望本篇文章能够帮助到你，也欢迎你把文章分享到朋友圈或微博。</p><p>有任何问题都可以到公众号给我发信息。</p>]]></content>
    
    
    <summary type="html">&lt;p&gt;本文将从4行代码出发给一个view设置渐变色，分别会谈到几个重要的渐变色相关属性，在使用过程中有几个需要特别关注的点。&lt;/p&gt;
&lt;p&gt;给一个view的border设置渐变色是比较高阶的用法，希望本文可以在这个方面帮助到你。&lt;/p&gt;</summary>
    
    
    
    
    <category term="iOS" scheme="http://www.iosprogrammer.tech/tags/iOS/"/>
    
  </entry>
  
  <entry>
    <title>environment和environmentObject的区别及适用场景</title>
    <link href="http://www.iosprogrammer.tech/swiftui/environment-vs-environmentObject/"/>
    <id>http://www.iosprogrammer.tech/swiftui/environment-vs-environmentObject/</id>
    <published>2021-03-05T03:25:18.000Z</published>
    <updated>2021-03-05T07:01:31.618Z</updated>
    
    <content type="html"><![CDATA[<p>SwiftUI中传递环境变量时会发现两个相似的方法：<code>environment&lt;V&gt;(_ keyPath:, _ value:)</code>和<code>environmentObject&lt;T&gt;(_ object:)</code>，这篇文章我们来看一下这两个方法的不同之处和分别的适用场景。</p><a id="more"></a><p><img src="../../images/first/swiftui-environmentobject-environment.png" alt="Swift环境变量对比"></p><div class="note info"><p>到公众号【iOS开发栈】学习更多SwiftUI、iOS开发相关内容。回复“博客”免费获取各大互联网公司面试题。</p></div><p>首先要明确的一点是，这两个方法都是用来设置环境变量的，而环境变量会影响到被设置变量的视图以及它的所有子视图，并且这个传递过程不需要明确指出。</p><p>也就是说，假设有三个视图，view1、view2、view3，其中view2和view3是view1的子视图，要想在view2和view3中使用view1设置的环境变量的话，只需要直接在view中使用<code>@EnvironmentObject</code>或者<code>@Environment</code>而不需要在创建view2和view3的时候显式传参。</p><h1 id="EnvironmentObject"><a href="#EnvironmentObject" class="headerlink" title="@EnvironmentObject"></a>@EnvironmentObject</h1><p>下面以<code>@EnvironmentObject</code>举例说明上面的这段话：</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 公众号——iOS开发栈</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">OfficalAccount</span>: <span class="title">ObservableObject</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Published</span> <span class="keyword">var</span> amount <span class="operator">=</span> <span class="number">3000</span> <span class="comment">// 订阅人数</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">DetailView</span>: <span class="title">View</span> </span>&#123;</span><br><span class="line">    <span class="meta">@EnvironmentObject</span> <span class="keyword">var</span> account: <span class="type">OfficalAccount</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">var</span> body: <span class="keyword">some</span> <span class="type">View</span> &#123;</span><br><span class="line">        <span class="type">VStack</span> &#123;</span><br><span class="line">            <span class="type">Button</span>(<span class="string">&quot;Increase Score in detailView&quot;</span>) &#123;</span><br><span class="line">                account.amount <span class="operator">+=</span> <span class="number">1</span></span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="type">Text</span>(<span class="string">&quot;account: <span class="subst">\(account.amount)</span>&quot;</span>)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">DetailView2</span>: <span class="title">View</span> </span>&#123;</span><br><span class="line">    <span class="meta">@EnvironmentObject</span> <span class="keyword">var</span> account: <span class="type">OfficalAccount</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">var</span> body: <span class="keyword">some</span> <span class="type">View</span> &#123;</span><br><span class="line">        <span class="type">Text</span>(<span class="string">&quot;Score: <span class="subst">\(account.amount)</span>&quot;</span>)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">ContentView</span>: <span class="title">View</span> </span>&#123;</span><br><span class="line">    <span class="meta">@StateObject</span> <span class="keyword">var</span> account <span class="operator">=</span> <span class="type">OfficalAccount</span>()</span><br><span class="line"></span><br><span class="line">    <span class="keyword">var</span> body: <span class="keyword">some</span> <span class="type">View</span> &#123;</span><br><span class="line">        <span class="type">VStack</span> &#123;</span><br><span class="line">            <span class="type">Button</span>(<span class="string">&quot;Increase Score&quot;</span>) &#123;</span><br><span class="line">                account.amount <span class="operator">+=</span> <span class="number">1</span></span><br><span class="line">            &#125;</span><br><span class="line">            </span><br><span class="line">            <span class="type">DetailView</span>()</span><br><span class="line">            <span class="type">DetailView2</span>()</span><br><span class="line">        &#125;</span><br><span class="line">        .environmentObject(account)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上面的例子是以我的公众号（”iOS开发栈“）的订阅人数做说明，可以看出<em>ContentView</em>创建<em>DetailView</em>和<em>DetailView2</em>时并没有直接传递变量<em>accout</em>，但是结果是这两个子视图中的数量显示会随着点击按钮而增加。</p><p>对上面使用<code>environmentObject</code>进行环境变量传递有几点需要注意：</p><ul><li>使用<code>@Environment</code>、<code>@StateObject</code>、<code>@ObservedObject</code>包装的类必须遵守<code>ObservableObject</code>协议，并且只能是类不能是结构体，否则会报错 <mark class="label danger">Non-class type OfficalAccount cannot conform to class protocol ObservableObject</mark></li><li><code>@Published</code>也只能在<em>class</em>中使用，如果放在了struct中，会报错<mark class="label danger">'wrappedValue' is unavailable: </mark></li><li>使用<code>@EnvironmentObject</code>包装的变量是不需要初始化的，编译器会从环境变量中获取这个对象的值</li><li>在子视图中可以修改了环境变量的值，并且这个改变会在当前的视图层级中传递</li></ul><h1 id="Environment"><a href="#Environment" class="headerlink" title="@Environment"></a>@Environment</h1><p>而对于<code>@Environment</code>来说，它主要是用来处理一些当前的系统设置的，比如说语言、时区、黑暗模式、CoreData的Context等。</p><p>在使用过程中一个很大的不同是，<code>@Environment(_ keyPath:)</code>需要指定一个类型为<code>KeyPath</code>的参数，而这个参数大多数情况下我们都是使用的<code>EnvironmentValues</code>中已经定义好的，比如<code>managedObjectContext</code>/<code>locale</code>等。</p><p>下面以使用<em>CoreData</em>为例说明使用方法：</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// App.swift</span></span><br><span class="line"><span class="operator">...</span></span><br><span class="line"><span class="keyword">let</span> persistenceController <span class="operator">=</span> <span class="type">PersistenceController</span>.shared</span><br><span class="line"><span class="operator">...</span></span><br><span class="line"><span class="keyword">var</span> body: <span class="keyword">some</span> <span class="type">Scene</span> &#123;</span><br><span class="line">    <span class="type">WindowGroup</span> &#123;</span><br><span class="line">        <span class="type">ContentView</span>()</span><br><span class="line">            .environment(\.managedObjectContext, persistenceController.container.viewContext)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="operator">...</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// ContentView.swift</span></span><br><span class="line"><span class="operator">...</span></span><br><span class="line"><span class="meta">@Environment</span>(\.managedObjectContext) <span class="keyword">private</span> <span class="keyword">var</span> viewContext</span><br><span class="line"><span class="operator">...</span></span><br><span class="line"><span class="keyword">let</span> newItem <span class="operator">=</span> <span class="type">Item</span>(context: viewContext)</span><br><span class="line">newItem.platform <span class="operator">=</span> <span class="number">1</span></span><br><span class="line"><span class="operator">...</span></span><br></pre></td></tr></table></figure><p>在这个例子中，我们在<em>App.swift</em>中创建了<code>persistenceController</code>并通过调用<code>.environment</code>把值传递给了<em>ContentView</em>。<em>ContentView</em>中使用<code>@Environment(\.managedObjectContext) private var viewContext</code>获取到了这个环境变量。</p><p>除了需要一个KeyPath和上面提到的主要用来处理系统自带的环境变量外，<code>@Environment</code>和<code>@EnvironmentObject</code>在用法上相差不大。</p><div class="note info"><p>到公众号【iOS开发栈】学习更多SwiftUI、iOS开发相关内容。回复“博客”免费获取各大互联网公司面试题。</p></div><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>通过灵活使用环境变量，可以让开发过程更加简单，页面之间可以写更少的值传递（正向、反相）相关代码。通过本文对<code>Environment</code>和<code>EnvironmentObject</code>的对比，我们更深入的了解了SwiftUI中环境变量的一些使用细节。</p><p>如果本文对你有帮助请帮忙分享到朋友圈或者微博。</p><p>如果有任何问题也可以到公众号联系我。</p>]]></content>
    
    
    <summary type="html">&lt;p&gt;SwiftUI中传递环境变量时会发现两个相似的方法：&lt;code&gt;environment&amp;lt;V&amp;gt;(_ keyPath:, _ value:)&lt;/code&gt;和&lt;code&gt;environmentObject&amp;lt;T&amp;gt;(_ object:)&lt;/code&gt;，这篇文章我们来看一下这两个方法的不同之处和分别的适用场景。&lt;/p&gt;</summary>
    
    
    
    
    <category term="SwiftUI" scheme="http://www.iosprogrammer.tech/tags/SwiftUI/"/>
    
  </entry>
  
  <entry>
    <title>在SwiftUI中实现UISegmentControl</title>
    <link href="http://www.iosprogrammer.tech/swiftui/swiftui-uisegmentcontrol/"/>
    <id>http://www.iosprogrammer.tech/swiftui/swiftui-uisegmentcontrol/</id>
    <published>2021-03-04T03:09:44.000Z</published>
    <updated>2021-03-04T10:24:09.339Z</updated>
    
    <content type="html"><![CDATA[<p>在SwiftUI中官方把控件做了精简，造成有些在UIKit中使用的控件找不到了。这篇文章来看一下UIPickerView在SwiftUI中是怎么表示的。</p><a id="more"></a><p>了解了一些SwiftUI的基础知识以后，应该就知道有一个<code>Picker</code>控件，想要实现UISegmentControl的效果就要用到这个控件。</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@State</span> <span class="keyword">var</span> platform <span class="operator">=</span> <span class="number">1</span></span><br><span class="line">    </span><br><span class="line"><span class="keyword">var</span> body: <span class="keyword">some</span> <span class="type">View</span> &#123;</span><br><span class="line">    <span class="type">VStack</span> &#123;</span><br><span class="line">        <span class="type">Picker</span>(<span class="string">&quot;平台名称&quot;</span>, selection: <span class="variable">$platform</span>) &#123;</span><br><span class="line">            <span class="type">Text</span>(<span class="string">&quot;支付宝&quot;</span>).tag(<span class="number">1</span>).navigationTitle(<span class="string">&quot;选择平台&quot;</span>)</span><br><span class="line">            <span class="type">Text</span>(<span class="string">&quot;京东金融&quot;</span>).tag(<span class="number">2</span>)</span><br><span class="line">        &#125;</span><br><span class="line">        .pickerStyle(<span class="type">SegmentedPickerStyle</span>())</span><br><span class="line">        </span><br><span class="line">        <span class="type">Text</span>(<span class="string">&quot;<span class="subst">\(platform)</span>&quot;</span>)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>使用这段代码就可以得到一个UISegmentControl效果的Picker了。</p><p>其中关键部分是<code>.pickerStyle(SegmentedPickerStyle())</code>，pickerStyle是一个设置Picker样式的Modifier，<code>SegmentedPickerStyle</code>就是外型和UISegmentControl一摸一样的效果。</p><p>除了SegmentedPickerStyle以外，pickerStyle还有下面几种类型：</p><ul><li><code>DefaultPickerStyle</code> 在不同平台有不同的展现形式。iOS平台上和<em>InlinePickerStyle</em>相同都是滚轮样式；MacOS平台和<em>MenuPickerStyle</em>相同；tvOS平台上和<em>SegmentedPickerStyle</em>相同</li><li><code>InlinePickerStyle</code>/<code>WheelPickerStyle</code> 滚轮样式</li><li><code>MenuPickerStyle</code> 点击后Picker的text后弹出选项，有点类似于<code>MenuController</code></li><li><code>RadioGroupPickerStyle</code> MacOS上使用的，所有选项一字排开，每个前面都有一个复选框☑️</li><li><code>SegmentedPickerStyle</code> 上面说的模仿UISegmentControl的外形，使用这种style的时候，Picker的content只能是Text或者Image</li></ul><div class="note info"><p>到公众号【iOS开发栈】学习更多SwiftUI、iOS开发相关内容。</p></div>]]></content>
    
    
    <summary type="html">&lt;p&gt;在SwiftUI中官方把控件做了精简，造成有些在UIKit中使用的控件找不到了。这篇文章来看一下UIPickerView在SwiftUI中是怎么表示的。&lt;/p&gt;</summary>
    
    
    
    
    <category term="SwiftUI" scheme="http://www.iosprogrammer.tech/tags/SwiftUI/"/>
    
  </entry>
  
  <entry>
    <title>3个关于SwiftUI中TextField不得不看的知识点</title>
    <link href="http://www.iosprogrammer.tech/swiftui/swiftui-textfield/"/>
    <id>http://www.iosprogrammer.tech/swiftui/swiftui-textfield/</id>
    <published>2021-02-27T12:21:57.000Z</published>
    <updated>2021-02-27T13:12:43.176Z</updated>
    
    <content type="html"><![CDATA[<p>几乎每一个iOS App都需要处理用户交互，输入框作为获取用户输入内容的最常用控件之一是开发者经常用到的一个控件。这篇文章我们来看一下在iOS14中怎么使用全新的SwiftUI框架来处理TextField。</p><a id="more"></a><div class="note info"><p>到公众号【iOS开发栈】学习更多SwiftUI、iOS开发相关内容。</p></div><p><img src="../../images/first/swiftui-textfiled.png" alt="SwiftUI TextField知识点"></p><h1 id="SwiftUI创建一个基础的TextField"><a href="#SwiftUI创建一个基础的TextField" class="headerlink" title="SwiftUI创建一个基础的TextField"></a>SwiftUI创建一个基础的TextField</h1><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">ContentView</span>: <span class="title">View</span> </span>&#123;</span><br><span class="line">    <span class="meta">@State</span> <span class="keyword">private</span> <span class="keyword">var</span> aStr <span class="operator">=</span> <span class="string">&quot;&quot;</span></span><br><span class="line">    <span class="keyword">var</span> body: <span class="keyword">some</span> <span class="type">View</span> &#123;</span><br><span class="line">        <span class="type">VStack</span> &#123;</span><br><span class="line">            <span class="type">TextField</span>(<span class="string">&quot;公众号&lt;iOS开发栈&gt;&quot;</span>, text: <span class="variable">$aStr</span>)</span><br><span class="line">            </span><br><span class="line">            <span class="type">Text</span>(aStr)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>创建一个<code>TextField</code>需要两个参数，一个占位符和一个<a href="https://www.iosprogrammer.tech/swiftui/swiftui-data-flow.html"><code>Bind&lt;Binding&lt;String</code></a>。</p><h1 id="TextFieldStyle"><a href="#TextFieldStyle" class="headerlink" title="TextFieldStyle"></a>TextFieldStyle</h1><p>通过设置<code>textFieldStyle</code>可以修改<code>TextField</code>的展现样式，在SwiftUI中系统自带了UIKit框架中的几个样式：<code>DefaultTextFieldStyle</code>/<code>PlainTextFieldStyle</code>/<code>RoundedBorderTextFieldStyle</code>。</p><p>设置的方法是：</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">TextField</span>(<span class="string">&quot;公众号&lt;iOS开发栈&gt;&quot;</span>, text: <span class="variable">$aStr</span>)</span><br><span class="line">    .textFieldStyle(<span class="type">DefaultTextFieldStyle</span>())</span><br></pre></td></tr></table></figure><blockquote><p>如果系统自带的这三种样式都不能满足需求，也可以自定义TextField的样式</p></blockquote><h1 id="TextField文本对齐方式"><a href="#TextField文本对齐方式" class="headerlink" title="TextField文本对齐方式"></a>TextField文本对齐方式</h1><p>在SwiftUI中设置TextField的文本对齐方式使用的modifier是<code>multilineTextAlignment</code>，其中包含<code>leading</code>/<code>center</code>/<code>trailing</code>三种对齐方式。</p><p>使用这个modifier的方法如下：</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">TextField</span>(<span class="string">&quot;公众号&lt;iOS开发栈&gt;&quot;</span>, text: <span class="variable">$aStr</span>)</span><br><span class="line">    .multilineTextAlignment(.trailing)</span><br></pre></td></tr></table></figure><div class="note info"><p>到公众号【iOS开发栈】学习更多SwiftUI、iOS开发相关内容。</p></div><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>这篇文章对SwiftUI框架中的<code>TextFiled</code>控件进行了讲解，主要涉及了创建方法、修改展示样式和设置文本对齐方法三个方面，希望对你有所帮助。</p>]]></content>
    
    
    <summary type="html">&lt;p&gt;几乎每一个iOS App都需要处理用户交互，输入框作为获取用户输入内容的最常用控件之一是开发者经常用到的一个控件。这篇文章我们来看一下在iOS14中怎么使用全新的SwiftUI框架来处理TextField。&lt;/p&gt;</summary>
    
    
    
    
    <category term="SwiftUI" scheme="http://www.iosprogrammer.tech/tags/SwiftUI/"/>
    
  </entry>
  
  <entry>
    <title>SwiftUI给Color添加扩展支持十六进制字符串</title>
    <link href="http://www.iosprogrammer.tech/swiftui/SwiftUI-Color-Hex/"/>
    <id>http://www.iosprogrammer.tech/swiftui/SwiftUI-Color-Hex/</id>
    <published>2021-02-26T03:06:25.000Z</published>
    <updated>2021-02-26T03:21:50.689Z</updated>
    
    <content type="html"><![CDATA[<p>SwiftUI中使用<code>Color</code>表示颜色，为了能够尽量独立的使用SwiftUI特性，我们通过给Color添加一个简单的扩展来满足对十六进制颜色的使用。</p><a id="more"></a><p>下面是这个扩展的所有代码：</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">extension</span> <span class="title">Color</span> </span>&#123;</span><br><span class="line">    <span class="keyword">init</span>(hex: <span class="type">String</span>) &#123;</span><br><span class="line">        <span class="keyword">let</span> hex <span class="operator">=</span> hex.trimmingCharacters(<span class="keyword">in</span>: <span class="type">CharacterSet</span>.alphanumerics.inverted)</span><br><span class="line">        <span class="keyword">var</span> int: <span class="type">UInt64</span> <span class="operator">=</span> <span class="number">0</span></span><br><span class="line">        <span class="type">Scanner</span>(string: hex).scanHexInt64(<span class="operator">&amp;</span>int)</span><br><span class="line">        <span class="keyword">let</span> a, r, g, b: <span class="type">UInt64</span></span><br><span class="line">        <span class="keyword">switch</span> hex.count &#123;</span><br><span class="line">        <span class="keyword">case</span> <span class="number">3</span>: <span class="comment">// RGB (12-bit)</span></span><br><span class="line">            (a, r, g, b) <span class="operator">=</span> (<span class="number">255</span>, (int <span class="operator">&gt;&gt;</span> <span class="number">8</span>) <span class="operator">*</span> <span class="number">17</span>, (int <span class="operator">&gt;&gt;</span> <span class="number">4</span> <span class="operator">&amp;</span> <span class="number">0xF</span>) <span class="operator">*</span> <span class="number">17</span>, (int <span class="operator">&amp;</span> <span class="number">0xF</span>) <span class="operator">*</span> <span class="number">17</span>)</span><br><span class="line">        <span class="keyword">case</span> <span class="number">6</span>: <span class="comment">// RGB (24-bit)</span></span><br><span class="line">            (a, r, g, b) <span class="operator">=</span> (<span class="number">255</span>, int <span class="operator">&gt;&gt;</span> <span class="number">16</span>, int <span class="operator">&gt;&gt;</span> <span class="number">8</span> <span class="operator">&amp;</span> <span class="number">0xFF</span>, int <span class="operator">&amp;</span> <span class="number">0xFF</span>)</span><br><span class="line">        <span class="keyword">case</span> <span class="number">8</span>: <span class="comment">// ARGB (32-bit)</span></span><br><span class="line">            (a, r, g, b) <span class="operator">=</span> (int <span class="operator">&gt;&gt;</span> <span class="number">24</span>, int <span class="operator">&gt;&gt;</span> <span class="number">16</span> <span class="operator">&amp;</span> <span class="number">0xFF</span>, int <span class="operator">&gt;&gt;</span> <span class="number">8</span> <span class="operator">&amp;</span> <span class="number">0xFF</span>, int <span class="operator">&amp;</span> <span class="number">0xFF</span>)</span><br><span class="line">        <span class="keyword">default</span>:</span><br><span class="line">            (a, r, g, b) <span class="operator">=</span> (<span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">0</span>)</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">self</span>.<span class="keyword">init</span>(</span><br><span class="line">            .sRGB,</span><br><span class="line">            red: <span class="type">Double</span>(r) <span class="operator">/</span> <span class="number">255</span>,</span><br><span class="line">            green: <span class="type">Double</span>(g) <span class="operator">/</span> <span class="number">255</span>,</span><br><span class="line">            blue:  <span class="type">Double</span>(b) <span class="operator">/</span> <span class="number">255</span>,</span><br><span class="line">            opacity: <span class="type">Double</span>(a) <span class="operator">/</span> <span class="number">255</span></span><br><span class="line">        )</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>使用方法如下：</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">Color</span>(hex: <span class="string">&quot;#FF6D5D&quot;</span>)</span><br></pre></td></tr></table></figure><div class="note info"><p>到公众号【iOS开发栈】学习更多SwiftUI、iOS开发相关内容。</p></div>]]></content>
    
    
    <summary type="html">&lt;p&gt;SwiftUI中使用&lt;code&gt;Color&lt;/code&gt;表示颜色，为了能够尽量独立的使用SwiftUI特性，我们通过给Color添加一个简单的扩展来满足对十六进制颜色的使用。&lt;/p&gt;</summary>
    
    
    
    
    <category term="SwiftUI" scheme="http://www.iosprogrammer.tech/tags/SwiftUI/"/>
    
  </entry>
  
  <entry>
    <title>详解SwiftUI中Divider和Spacer的用法和区别（最新）</title>
    <link href="http://www.iosprogrammer.tech/swiftui/swiftui-divide-spacer/"/>
    <id>http://www.iosprogrammer.tech/swiftui/swiftui-divide-spacer/</id>
    <published>2021-02-17T11:43:10.000Z</published>
    <updated>2021-02-25T06:53:41.437Z</updated>
    
    <content type="html"><![CDATA[<p>Divider和Spacer都可以用到分割两个视图，但是它们也有一些区别。通过这篇文章我们将学到这两个控件的使用方式和它们之间的区别。</p><a id="more"></a><div class="note info"><p>到公众号【iOS开发栈】学习更多SwiftUI、iOS开发相关内容。</p></div><p><img src="../../images/first/SwiftUI-Divider-Spacer.jpg" alt="SwiftUI-Divider-vs-Spacer"></p><h1 id="Spacer"><a href="#Spacer" class="headerlink" title="Spacer"></a>Spacer</h1><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">ContentView</span>: <span class="title">View</span> </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> body: <span class="keyword">some</span> <span class="type">View</span> &#123;</span><br><span class="line">        <span class="type">VStack</span> &#123;</span><br><span class="line">            <span class="type">Text</span>(<span class="string">&quot;Top&quot;</span>).background(<span class="type">Color</span>.red)</span><br><span class="line">            <span class="type">Spacer</span>()</span><br><span class="line">            <span class="type">Text</span>(<span class="string">&quot;Bottom&quot;</span>).background(<span class="type">Color</span>.red)</span><br><span class="line">        &#125;</span><br><span class="line">        .frame(width: <span class="number">100</span>, height: <span class="number">400</span>, alignment: .center)</span><br><span class="line">        .background(<span class="type">Color</span>.yellow)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在“Top”和“Bottom”之间添加一个<code>Spacer</code>控件，会把这两个文字隔开，使这两个文字分别位于最上和最下面。</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">Spacer</span>(minLength: <span class="number">30</span>)</span><br></pre></td></tr></table></figure><p>通过设置<code>minLength</code>可以指定被分开的两个视图的最小距离，如果不指定的话，会有一个默认的距离。</p><h1 id="Divider"><a href="#Divider" class="headerlink" title="Divider"></a>Divider</h1><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">VStack</span> &#123;</span><br><span class="line">    <span class="type">Text</span>(<span class="string">&quot;Top&quot;</span>).background(<span class="type">Color</span>.red)</span><br><span class="line">    <span class="type">Divider</span>().background(<span class="type">Color</span>.red)</span><br><span class="line">    <span class="type">Text</span>(<span class="string">&quot;Bottom&quot;</span>).background(<span class="type">Color</span>.red)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Top和Bottom之间添加一个Divider控件可以在两个视图之间添加一个间隔，和上面的<code>Spacer</code>不同的是中间会出现一根线，<code>background</code>设置的颜色会影响到这根线的颜色。</p><p>并且，被Divider分割的两个视图中间的距离是固定的，它们不会移动到父视图的两端。</p><p>另外，把<code>Divider</code>的高度分别设置为0之后，被它分割的两个视图不会靠在一起。但是把<code>Spacer</code>的高度设置为0，被它分割的两个视图会靠在一起，就和没有被分割一样。</p><div class="note info"><p>到公众号【iOS开发栈】学习更多SwiftUI、iOS开发相关内容。回复“博客”免费获取各大互联网公司面试题。</p></div><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>这篇文章学习了SwiftUI中<code>Spacer</code>和<code>Divider</code>的用法以及它们之间的区别，这两个控件在SwiftUI中虽然简单但是非常的常用，我们一定要熟悉。如果你有任何的问题、建议都可以通过<a href="https://weibo.com/7414691003/profile">微博</a>或<a href="mailto:shizhiang@126.com">邮件</a>联系到我本人。</p>]]></content>
    
    
    <summary type="html">&lt;p&gt;Divider和Spacer都可以用到分割两个视图，但是它们也有一些区别。通过这篇文章我们将学到这两个控件的使用方式和它们之间的区别。&lt;/p&gt;</summary>
    
    
    
    
    <category term="SwiftUI" scheme="http://www.iosprogrammer.tech/tags/SwiftUI/"/>
    
  </entry>
  
  <entry>
    <title>iOS完整集成admob教程（2021）</title>
    <link href="http://www.iosprogrammer.tech/ios/ios-integrate-admob/"/>
    <id>http://www.iosprogrammer.tech/ios/ios-integrate-admob/</id>
    <published>2021-02-06T11:57:33.000Z</published>
    <updated>2021-02-25T06:53:41.437Z</updated>
    
    <content type="html"><![CDATA[<p>Admob是谷歌推出的广告服务，其中包含的广告类型有：banner、插屏、激励、开屏（最近添加的）。利用Admob的中介组可以引入其他广告商的广告，比如FaceBook、unity等10多家平台。对于出海的App集成Admob是非常必要的变现手段。</p><a id="more"></a><div class="note info"><p>到公众号【iOS开发栈】学习更多SwiftUI、iOS开发相关内容。</p></div><p><img src="../../images/admob/admob.png" alt="Admob 集成"></p><h1 id="通过Cocoapods导入Admob-SDK"><a href="#通过Cocoapods导入Admob-SDK" class="headerlink" title="通过Cocoapods导入Admob SDK"></a>通过Cocoapods导入Admob SDK</h1><p>通过Cocoapods导入SDK是最简单的方法，如果不知道Cocoapods的使用方法可以看一下<a href="https://cocoapods.org/">官方文档</a>。在Podfile中添加一行代码：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">pod &#39;Google-Mobile-Ads-SDK&#39;</span><br></pre></td></tr></table></figure><p>之后在终端执行命令行：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">pod install --repo-update</span><br></pre></td></tr></table></figure><h1 id="修改主工程的info-plist文件"><a href="#修改主工程的info-plist文件" class="headerlink" title="修改主工程的info.plist文件"></a>修改主工程的info.plist文件</h1><p>在主工程的info.plist文件中添加两个键值对：</p><ol><li><code>GADApplicationIdentifier</code>对应的是你的app在Admob申请到的App ID。</li><li><code>SKAdNetworkItems</code>对应的是一个固定的<code>cstr6suwn9.skadnetwork</code>。</li></ol><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">&lt;key&gt;GADApplicationIdentifier&lt;&#x2F;key&gt;</span><br><span class="line">&lt;string&gt;ca-app-pub-3940256099942544~1458002511&lt;&#x2F;string&gt;</span><br><span class="line">&lt;key&gt;SKAdNetworkItems&lt;&#x2F;key&gt;</span><br><span class="line">  &lt;array&gt;</span><br><span class="line">    &lt;dict&gt;</span><br><span class="line">      &lt;key&gt;SKAdNetworkIdentifier&lt;&#x2F;key&gt;</span><br><span class="line">      &lt;string&gt;cstr6suwn9.skadnetwork&lt;&#x2F;string&gt;</span><br><span class="line">    &lt;&#x2F;dict&gt;</span><br><span class="line">  &lt;&#x2F;array&gt;</span><br></pre></td></tr></table></figure><p>添加之后的info.plist效果：<br><img src="../../images/admob/quick_start_skadnetwork.png" alt="info.plist添加Admob"></p><p>关于注册Admob账号和获取App ID的内容可以到<a href="https://apps.admob.com/v2/home">Admob的官方网站</a>查看。</p><h1 id="初始化Admob-SDK"><a href="#初始化Admob-SDK" class="headerlink" title="初始化Admob SDK"></a>初始化Admob SDK</h1><p>在<code>AppDelegate</code>中添加初始化Admob SDK的代码</p><div class="tabs" id="initialize-admob-sdk"><ul class="nav-tabs"><li class="tab active"><a href="#initialize-admob-sdk-1">Objective-C</a></li><li class="tab"><a href="#initialize-admob-sdk-2">Swift</a></li></ul><div class="tab-content"><div class="tab-pane active" id="initialize-admob-sdk-1"><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">@import</span> GoogleMobileAds;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">@implementation</span> <span class="title">AppDelegate</span></span></span><br><span class="line"></span><br><span class="line">- (<span class="built_in">BOOL</span>)application:(<span class="built_in">UIApplication</span> *)application</span><br><span class="line">    didFinishLaunchingWithOptions:(<span class="built_in">NSDictionary</span> *)launchOptions &#123;</span><br><span class="line"></span><br><span class="line">  [[GADMobileAds sharedInstance] startWithCompletionHandler:<span class="literal">nil</span>];</span><br><span class="line">  <span class="keyword">return</span> <span class="literal">YES</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">@end</span></span><br></pre></td></tr></table></figure></div><div class="tab-pane" id="initialize-admob-sdk-2"><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> GoogleMobileAds</span><br><span class="line"></span><br><span class="line"><span class="keyword">@UIApplicationMain</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">AppDelegate</span>: <span class="title">UIResponde</span>, <span class="title">UIApplicationDelegate</span> </span>&#123;</span><br><span class="line">  <span class="function"><span class="keyword">func</span> <span class="title">application</span><span class="params">(<span class="keyword">_</span> application: UIApplication,</span></span></span><br><span class="line"><span class="function"><span class="params">      didFinishLaunchingWithOptions launchOptions: [UIApplicationLaunchOptionsKey: <span class="keyword">Any</span>]?)</span></span> -&gt; <span class="type">Bool</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="type">GADMobileAds</span>.sharedInstance().start(completionHandler: <span class="literal">nil</span>)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div></div></div><p>到这里，我们就可以根据需要来在App的不同位置添加需要的广告类型了。</p><p>因为类型比较多，这里如果分别介绍的话篇幅就太长了。所以在这篇文章只说一下需要注意的地方，详细的集成方法可以到<a href="https://developers.google.com/admob/ios/quick-start">Admob开发官网</a>查看。</p><h1 id="各种Admob广告类型的最佳实践方案"><a href="#各种Admob广告类型的最佳实践方案" class="headerlink" title="各种Admob广告类型的最佳实践方案"></a>各种Admob广告类型的最佳实践方案</h1><p>不同类型的Admob广告适用于不同的场景，按照场景放广告不仅更能被用户接受，而且对广告营收有一定的益处。相反，如果不按照推荐方法来展示广告有可能会被广告商警告，严重的话可能会被禁止投放（我们就被Facebook警告了）。</p><ol><li>Banner广告是那种长条状的横幅形式，建议放在屏幕的边缘处，对于手机屏幕建议放在屏幕的最上面或者最下面。</li><li>插屏广告是一种全屏展示的广告，可能是一张图片或者一个视频，只有用户点击关闭按钮是才会关闭。这种广告对用户打扰非常大，建议放在界面切换的时候才展示这种广告，<strong>并且不能在push到一个新页面以后再展示</strong>，比如说不能在到一个新页面后网络请求服务端的过程中展示这个广告。</li><li>Native广告（原生广告）是一种比较特殊的广告形式，它通过SDK来实现广告加载，加载到的是广告的一些组件（文字、图片、视频），我们可以自定义组件的展示位置和大小。<strong>这种广告适合用在启动图或者列表（UITableView/UICollectionView）中。</strong></li><li>激励视频广告是一种可以让用户通过观看广告获取App内奖励的广告形式，在游戏类App中十分常见。在弹出这种广告前一定要让用户选择是否要通过看广告获取“更多奖励”。</li></ol><h1 id="使用Admob中介组聚合多个平台广告"><a href="#使用Admob中介组聚合多个平台广告" class="headerlink" title="使用Admob中介组聚合多个平台广告"></a>使用Admob中介组聚合多个平台广告</h1><p>谷歌广告平台不仅有自家的Admob广告还有很多其他广告平台的资源，我们在集成了<code>Google-Mobile-Ads-SDK</code>的基础上通过添加不同平台的中介组（Mediation）来快速获取不同平台的广告。</p><p>在这里我们仅以集成Facebook的广告为例做一下说明，其他平台的广告也都大同小异。如果在集成过程中有什么问题也可以到公众号“iOS开发栈”问我。</p><p>在<code>Podfile</code>文件中添加Admob SDK和Facebook的中介组：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">pod &#39;Google-Mobile-Ads-SDK&#39;,</span><br><span class="line">pod &#39;GoogleMobileAdsMediationFacebook&#39;</span><br></pre></td></tr></table></figure><p>之后在终端切换到项目所在目录，并执行</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">cd &lt;当前项目目录&gt;</span><br><span class="line">pod install --repo-update</span><br></pre></td></tr></table></figure><p>安装完Admob SDk和FB的广告中介组以后，就可以直接使用对应的广告形式了。对应广告形式的使用方式可以到上一节查看，这里不再赘述。</p><p>这里有一点需要强调的是在初始化不同的广告形式需要调用<code>initWithAdUnitID:</code>方法，这里的<em>UnitID</em>是广告但愿ID，可以在Admob的管理后台-&gt;广告单元页面查看。</p><p><img src="../../images/admob/UnitId.png" alt="Admob UnitID"></p><div class="note info"><p>到公众号【iOS开发栈】学习更多SwiftUI、iOS开发相关内容。回复“博客”免费获取各大互联网公司面试题。</p></div><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>谷歌的Admob服务和其他广告商相比文档更加全面（不过文档中也可能有错误），社区也非常活跃（我曾经提过一个问题，很快可以得到回复）。这篇文章是我在使用过程中的一些总结，里面除了基础的集成方法外，大都是使用过程中的注意事项，至于详细的集成过程推荐到<a href="https://developers.google.com/admob/ios/quick-start">官方文档</a>中查看。如果你有任何的问题、建议都可以通过<a href="https://weibo.com/7414691003/profile">微博</a>或<a href="mailto:shizhiang@126.com">邮件</a>联系到我本人。</p>]]></content>
    
    
    <summary type="html">&lt;p&gt;Admob是谷歌推出的广告服务，其中包含的广告类型有：banner、插屏、激励、开屏（最近添加的）。利用Admob的中介组可以引入其他广告商的广告，比如FaceBook、unity等10多家平台。对于出海的App集成Admob是非常必要的变现手段。&lt;/p&gt;</summary>
    
    
    
    
    <category term="iOS" scheme="http://www.iosprogrammer.tech/tags/iOS/"/>
    
  </entry>
  
  <entry>
    <title>详解SwiftUI数据流是怎么在View间传递的</title>
    <link href="http://www.iosprogrammer.tech/swiftui/swiftui-data-flow/"/>
    <id>http://www.iosprogrammer.tech/swiftui/swiftui-data-flow/</id>
    <published>2021-02-02T06:35:42.234Z</published>
    <updated>2021-02-25T06:53:41.437Z</updated>
    
    <content type="html"><![CDATA[<p>作为一个声明式的UI框架，SwiftUI帮我们处理了几乎所有关于UI和数据之间的交互，这使我们不再需要关注数据变化时刷新UI和用户交互以后更新数据的逻辑。</p><p>为了实现数据和UI的绑定，我们需要利用Swift的一些关属性包装器来向SwiftUI描述它们之间的关系，那么让我们开始吧。</p><a id="more"></a><div class="note info"><p>到公众号【iOS开发栈】学习更多SwiftUI、iOS开发相关内容。</p></div><p><img src="../../image/../images/first/SwiftUI-Data-Flow.jpg"></p><h1 id="State-Properties-State"><a href="#State-Properties-State" class="headerlink" title="State Properties @State"></a>State Properties @State</h1><p>在<a href="https://www.iosprogrammer.tech/swiftui/what-is-the-different-between-foreach-and-list">前面的一篇文章</a>中当我们给数组添加或者删除元素时，<a href="https://www.iosprogrammer.tech/swiftui/swiftui-concept-essential.md">列表</a>会自动响应变化，正是因为使用了<code>@State</code>来标记View中的model。</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">ContentView</span>: <span class="title">View</span> </span>&#123;</span><br><span class="line">    <span class="meta">@State</span> <span class="keyword">private</span> <span class="keyword">var</span> title: <span class="type">String</span> <span class="operator">=</span> <span class="string">&quot;&quot;</span></span><br><span class="line">    <span class="keyword">var</span> body: <span class="keyword">some</span> <span class="type">View</span> &#123;</span><br><span class="line">        <span class="type">VStack</span> &#123;</span><br><span class="line">            <span class="type">Text</span>(<span class="string">&quot;<span class="subst">\(title)</span>&quot;</span>)</span><br><span class="line">            <span class="type">TextField</span>(<span class="string">&quot;Please Enter Title&quot;</span>, text: <span class="variable">$title</span>)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>使用<code>@State</code>包装的变量是可以被SwiftUI读取的值，这些值通常是一些字符串或数字等常量值。</p><p>当被State包装的属性改变时，SwiftUI会重新计算和绘制使用到该属性的视图所在的整个视图层级，通常是说变量所在View的Body会被重新绘制，在本例子中就是指<code>ContentView</code>的body。</p><blockquote><p>被<code>@State</code>包装的变量一定要用<code>private</code>修饰，并且这个变量只能在当前view以及其子View的body中使用。</p></blockquote><p>正如TextField中的<code>$title</code>一样，我们可以通过*$*前缀把变量和另一个view绑定起来，这样就可以在另一个view中对这个变量进行修改了。下面的代码使用一个Toggle来控制Wi-Fi的开关：</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">ContentView</span>: <span class="title">View</span> </span>&#123;</span><br><span class="line">    <span class="meta">@State</span> <span class="keyword">private</span> <span class="keyword">var</span> isOn <span class="operator">=</span> <span class="literal">false</span></span><br><span class="line">    <span class="keyword">var</span> body: <span class="keyword">some</span> <span class="type">View</span> &#123;</span><br><span class="line">        <span class="type">VStack</span> &#123;</span><br><span class="line">            <span class="type">Text</span>(<span class="string">&quot;Wi-Fi State: <span class="subst">\(isOn <span class="operator">?</span> <span class="string">&quot;On&quot;</span> : <span class="string">&quot;Off&quot;</span>)</span>&quot;</span>)</span><br><span class="line">            <span class="type">Image</span>(systemName: <span class="string">&quot;<span class="subst">\(isOn <span class="operator">?</span> <span class="string">&quot;wifi&quot;</span> : <span class="string">&quot;wifi.slash&quot;</span>)</span>&quot;</span>)</span><br><span class="line">            <span class="type">Toggle</span>(<span class="string">&quot;Wi-Fi State&quot;</span>, isOn: <span class="variable">$isOn</span>)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>正如上面的代码所示，我们在<code>isOn</code>属性和Toggle控件之间建立了一个绑定。Toggle可以修改isOn的值，另外当isOn改变的时候，Text和Image的内容都会发生变化。</p><h1 id="State-Binding-状态绑定"><a href="#State-Binding-状态绑定" class="headerlink" title="State Binding 状态绑定"></a>State Binding 状态绑定</h1><p>使用@state包装的属性只在它所属view的内部使用，那么当它的子视图要访问这个属性的时候就要用到<code>@binding</code>了。就像上面例子用到的<code>Toggle</code>，我们把Text和Image放到一个自定义的View中。</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">WiFiView</span>: <span class="title">View</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Binding</span> <span class="keyword">var</span> isOn: <span class="type">Bool</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">var</span> body: <span class="keyword">some</span> <span class="type">View</span> &#123;</span><br><span class="line">        <span class="type">Text</span>(<span class="string">&quot;Wi-Fi State: <span class="subst">\(isOn <span class="operator">?</span> <span class="string">&quot;On&quot;</span> : <span class="string">&quot;Off&quot;</span>)</span>&quot;</span>)</span><br><span class="line">        <span class="type">Image</span>(systemName: <span class="string">&quot;<span class="subst">\(isOn <span class="operator">?</span> <span class="string">&quot;wifi&quot;</span> : <span class="string">&quot;wifi.slash&quot;</span>)</span>&quot;</span>)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在这里我们使用了<code>@Binding</code>来创建数据和界面之间的依赖，它和<code>@State</code>不同的地方在于，binding的属性并不被当前的视图所持有，并且binding的值是可以被state的属性值导出的。</p><p>在这里如果把@Binding换成@State就会使WiFiView和它的父视图分别拥有各自的isOn属性，其中一个修改不会影响到另一个，而这显然不是我们想要的结果。</p><h1 id="使用Combine框架的Publisher"><a href="#使用Combine框架的Publisher" class="headerlink" title="使用Combine框架的Publisher"></a>使用<em>Combine</em>框架的<em>Publisher</em></h1><p>使用@State包装的属性只能在当前View内部或者它的子视图中使用，并且state属性时临时的——由于state包装的属性是隶属于它所在view的，当view被销毁时对应的state属性也会消失，这明显是不够的，另外我们在开发过程中还要处理一些非界面的信息，比如说<em>Timer</em>、<em>Notification</em>等，它们携带的信息通常也会有更新界面的需求。这种情况就要用到Combine中的Publisher了。</p><p><em>Combine</em>是在iOS13中被引入的，主要目的是为了处理App中的各种事件消息。如果你之前接触过<em>RxSwift</em>或者<em>ReactiveCocoa</em>那你对这个概念应该很容易理解，它的原理就是发布者和订阅者的模式。</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Contact</span>: <span class="title">ObservableObject</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Published</span> <span class="keyword">var</span> name: <span class="type">String</span></span><br><span class="line">    <span class="meta">@Published</span> <span class="keyword">var</span> age: <span class="type">Int</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">init</span>(name: <span class="type">String</span>, age: <span class="type">Int</span>) &#123;</span><br><span class="line">        <span class="keyword">self</span>.name <span class="operator">=</span> name</span><br><span class="line">        <span class="keyword">self</span>.age <span class="operator">=</span> age</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">ContentView</span>: <span class="title">View</span> </span>&#123;</span><br><span class="line">    <span class="meta">@ObservedObject</span> <span class="keyword">var</span> xiaowang <span class="operator">=</span> <span class="type">Contact</span>(name: <span class="string">&quot;xiaowang&quot;</span>, age: <span class="number">21</span>)</span><br><span class="line">    <span class="keyword">var</span> body: <span class="keyword">some</span> <span class="type">View</span> &#123;</span><br><span class="line">        <span class="type">VStack</span> &#123;</span><br><span class="line">            <span class="type">Text</span>(<span class="string">&quot;小王：<span class="subst">\(xiaowang.name)</span>&quot;</span>)</span><br><span class="line">            </span><br><span class="line">            <span class="comment">// 这里只是一个例子，通常不会在这里对Publisher进行修改</span></span><br><span class="line">            <span class="type">Button</span>(<span class="string">&quot;修改联系人&quot;</span>) &#123;</span><br><span class="line">                xiaowang.name <span class="operator">=</span> <span class="string">&quot;小王&quot;</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>我们先创建一个遵守<em>ObservableObject</em>协议的联系人类，然后在SwiftUI视图中添加一个被<em>ObservedObject</em>包装的变量，在body中使用这个变量，当被<em><em>@Published</em></em>包装的变量改变时，body会使用新值重新加载。</p><blockquote><p>如果你在看WWDC2019的<a href="https://developer.apple.com/wwdc19/226">Introducing Combile</a>视频的时候发现<em>BindableObject</em>/<em>didChange.send()</em>/<em>onReceive</em>，这些内容现在已经被<a href="https://developer.apple.com/forums/thread/127243">移除了</a>。</p></blockquote><blockquote><p>只有class可以遵守ObservableObject协议，否则会报错 <mark class="label danger">Non-class type Contact cannot conform to class protocol ObservableObject</mark></p></blockquote><p>在iOS14中，引入了一个新的<em><em>@StateObject</em></em>来丰富这种使用场景。它和ObservedObject的区别在于当view刷新时被ObservedObject包装的属性会重置到初始值，而被StateObject使用的不会。</p><blockquote><p>除非在某些必要的情况下需要使用ObservedObject之外，大多数情况都适用于StateObject。</p></blockquote><h1 id="环境变量-Evironment-Objects"><a href="#环境变量-Evironment-Objects" class="headerlink" title="环境变量 Evironment Objects"></a>环境变量 Evironment Objects</h1><p>除了以上列出的几个场景之外，假设我们的app需要从一个页面跳转到另一个页面，这是一个很常见的场景，并且在后一个页面要用到前面页面的一些属性。通常可以这样做：</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">NavigationLink</span>(destination: nextView(aModel: aModel)) &#123;</span><br><span class="line">    <span class="type">Text</span>(<span class="string">&quot;Detail&quot;</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上面用到了<strong><em>NavigationLink</em></strong>来做导航，destination是要弹出的页面，初始化时带着当前页面的一个属性。</p><p>这样处理没有什么大的问题，不过如果层级变多，后面层级又出现很多新层级，再有反向传值的话就会很复杂容易出错——就像使用UIKit的时候。而为了解决这个问题，SwiftUI引入了<strong><em>Evironment Objects</em></strong>。</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// DataSource.swift</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">DataSource</span>: <span class="title">ObservableObject</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Published</span> <span class="keyword">var</span> counter <span class="operator">=</span> <span class="number">0</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// ContentView.swift</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">ContentView</span>: <span class="title">View</span> </span>&#123;</span><br><span class="line">    <span class="keyword">let</span> dataSource <span class="operator">=</span> <span class="type">DataSource</span>()</span><br><span class="line">    <span class="keyword">var</span> body: <span class="keyword">some</span> <span class="type">View</span> &#123;</span><br><span class="line">        <span class="type">NavigationView</span> &#123;</span><br><span class="line">            <span class="type">VStack</span> &#123;</span><br><span class="line">                <span class="type">Button</span>(<span class="string">&quot;Click&quot;</span>) &#123;</span><br><span class="line">                    dataSource.counter <span class="operator">+=</span> <span class="number">1</span></span><br><span class="line">                &#125;</span><br><span class="line">                <span class="type">NavigationLink</span>(</span><br><span class="line">                    destination: <span class="type">ContactView</span>()) &#123;</span><br><span class="line">                    <span class="type">Text</span>(<span class="string">&quot;Enter Next Page&quot;</span>)</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        .environmentObject(dataSource)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// ContactView.swift</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">ContactView</span>: <span class="title">View</span> </span>&#123;</span><br><span class="line">    <span class="meta">@EnvironmentObject</span> <span class="keyword">var</span> dataSource: <span class="type">DataSource</span></span><br><span class="line">    <span class="keyword">var</span> body: <span class="keyword">some</span> <span class="type">View</span> &#123;</span><br><span class="line">        <span class="type">Text</span>(<span class="string">&quot;<span class="subst">\(dataSource.counter)</span>&quot;</span>)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Environment Object和ObservedObject/StateObject用法非常相似，首先DataSource遵守ObservableObject协议，要观察的属性counter使用Publisher包装。</p><p>被<em><em>@EnvironmentObject</em></em>包装的属性会随着Publised属性的改变而变化，所在的view也会重新加载。</p><p><em>.environmentObject</em>是一个<a href="https://www.iosprogrammer.tech/swiftui-concept-essential">Modifier</a>，它向环境变量中注入一个属性，如果不在使用@EnvironmentObject之前使用把属性注入到环境变量中，就会包错 <mark class="label danger">MissingEnvironmentObjectError: Missing EnvironmentObject</mark></p><div class="note info"><p>到公众号【iOS开发栈】回复“博客”免费获取各大互联网公司面试题。</p></div><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>在这篇文章中我们学习了SwiftUI框架中数据的流动相关知识，其中主要涉及了几个常用的属性包装器（property wrapper）：@State @Binding @ObservedObject @StateObject @EnvironmentObject用法和适用场景，希望对你所有帮助。如果你有任何的问题、建议都可以通过<a href="https://weibo.com/7414691003/profile">微博</a>或<a href="mailto:shizhiang@126.com">邮件</a>联系到我本人。</p>]]></content>
    
    
    <summary type="html">&lt;p&gt;作为一个声明式的UI框架，SwiftUI帮我们处理了几乎所有关于UI和数据之间的交互，这使我们不再需要关注数据变化时刷新UI和用户交互以后更新数据的逻辑。&lt;/p&gt;
&lt;p&gt;为了实现数据和UI的绑定，我们需要利用Swift的一些关属性包装器来向SwiftUI描述它们之间的关系，那么让我们开始吧。&lt;/p&gt;</summary>
    
    
    
    
    <category term="SwiftUI" scheme="http://www.iosprogrammer.tech/tags/SwiftUI/"/>
    
  </entry>
  
  <entry>
    <title>一文解决UIKeyboard的疑难杂症</title>
    <link href="http://www.iosprogrammer.tech/UIScrollView-Keyboard/"/>
    <id>http://www.iosprogrammer.tech/UIScrollView-Keyboard/</id>
    <published>2021-01-30T02:58:39.000Z</published>
    <updated>2021-02-25T06:53:41.437Z</updated>
    
    <content type="html"><![CDATA[<p>我们在iOS的开发过程中，经常要在包含UIScrollView的view中监听键盘的通知，有时候会出现一些bug，比方说<code>UIKeyboardWillShowNotification</code>可能会调用多次。</p><p>通过这篇文章我们来讨论几个经常出现的问题，并且了解一下对应的解决方案。</p><a id="more"></a><div class="note info"><p>到公众号【iOS开发栈】学习更多SwiftUI、iOS开发相关内容。回复“博客”免费获取各大互联网公司面试题。</p></div><p><img src="../../images/first/UIkeyBoard.jpg" alt="UIkeyboard的bugs"></p><h1 id="UIScrollView退出键盘"><a href="#UIScrollView退出键盘" class="headerlink" title="UIScrollView退出键盘"></a>UIScrollView退出键盘</h1><p>拖动UIScrollView退出键盘的方法：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">typedef NS_ENUM(NSInteger, UIScrollViewKeyboardDismissMode) &#123;</span><br><span class="line">    UIScrollViewKeyboardDismissModeNone,</span><br><span class="line">    UIScrollViewKeyboardDismissModeOnDrag,      &#x2F;&#x2F; dismisses the keyboard when a drag begins</span><br><span class="line">    UIScrollViewKeyboardDismissModeInteractive, &#x2F;&#x2F; the keyboard follows the dragging touch off screen, and may be pulled upward again to cancel the dismiss</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">@property(nonatomic) UIScrollViewKeyboardDismissMode keyboardDismissMode &#x2F;&#x2F; 默认是None，UIScrollView和Keyboar不会有任何交互效果</span><br></pre></td></tr></table></figure><ul><li><code>UIScrollViewKeyboardDismissModeOnDrag</code> 当开始拖动时，keyboard会退出屏幕。在iOS14的模拟器上动画有点不流畅。</li><li><code>UIScrollViewKeyboardDismissModeInteractive</code> <strong>当拖动手势进入键盘区域时</strong>，键盘会跟随拖动上升或者下降。</li></ul><h1 id="UIKeyboardWillShowNotification多次重复通知"><a href="#UIKeyboardWillShowNotification多次重复通知" class="headerlink" title="UIKeyboardWillShowNotification多次重复通知"></a><code>UIKeyboardWillShowNotification</code>多次重复通知</h1><p>多个TextField或者TextView之间切换时，<code>UIKeyboardWillShowNotification</code>、<code>UIKeyboardWillChangeFrameNotification</code>每次都会调用（但是<code>UIKeyboardWillHideNotification</code>却不会调用），当你使用上面提到的<code>UIScrollViewKeyboardDismissModeInteractive</code>时，通知甚至会在一个动画过程中频繁调用。</p><p>我们在处理一些业务逻辑的时候需要谨记这个特点，不要寄希望于只会调用一次。比方说要在<code>UIKeyboardWillShowNotification</code>的回调中把某个视图上移。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line">[[NSNotificationCenter defaultCenter] addObserver:self selector:@selector(willShow:) name:UIKeyboardWillShowNotification object:nil]; &#x2F;&#x2F; 订阅通知</span><br><span class="line"></span><br><span class="line">❌</span><br><span class="line">- (void)willShow:(NSNotification *)noti &#123;</span><br><span class="line">    NSLog(@&quot;willShow&quot;);</span><br><span class="line">    CGRect keyboarFrame &#x3D; [noti.userInfo[UIKeyboardFrameBeginUserInfoKey] CGRectValue];</span><br><span class="line">    CGRect bottomViewFrame &#x3D; _bottomView.frame;</span><br><span class="line">    bottomViewFrame.origin.y -&#x3D; keyboarFrame.size.height;</span><br><span class="line">    _bottomView.frame &#x3D; bottomViewFrame;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">✅</span><br><span class="line">&#x2F;&#x2F; 使用固定高度的方法</span><br><span class="line">- (void)willShow:(NSNotification *)noti &#123;</span><br><span class="line">    NSLog(@&quot;willShow&quot;);</span><br><span class="line">    CGRect keyboarFrame &#x3D; [noti.userInfo[UIKeyboardFrameEndUserInfoKey] CGRectValue];</span><br><span class="line">    CGRect bottomViewFrame &#x3D; _bottomView.frame;</span><br><span class="line">    bottomViewFrame.origin.y &#x3D; self.view.bounds.size.height - keyboarFrame.size.height - _bottomView.bounds.size.height;</span><br><span class="line">    _bottomView.frame &#x3D; bottomViewFrame;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">✅</span><br><span class="line">&#x2F;&#x2F; 使用全局变量的方法</span><br><span class="line">[[NSNotificationCenter defaultCenter] addObserver:self selector:@selector(didHide:) name:UIKeyboardDidHideNotification object:nil]; &#x2F;&#x2F; 订阅键盘消失的通知</span><br><span class="line"></span><br><span class="line">static BOOL keyboarShow &#x3D; NO;</span><br><span class="line"></span><br><span class="line">- (void)willShow:(NSNotification *)noti &#123;</span><br><span class="line">    NSLog(@&quot;willShow&quot;);</span><br><span class="line">    if (keyboarShow &#x3D;&#x3D; YES) &#123;</span><br><span class="line">        return;</span><br><span class="line">    &#125;</span><br><span class="line">    keyboarShow &#x3D; YES;</span><br><span class="line">    CGRect keyboarFrame &#x3D; [noti.userInfo[UIKeyboardFrameEndUserInfoKey] CGRectValue];</span><br><span class="line">    CGRect bottomViewFrame &#x3D; _bottomView.frame;</span><br><span class="line">    bottomViewFrame.origin.y &#x3D; self.view.bounds.size.height - keyboarFrame.size.height - _bottomView.bounds.size.height;</span><br><span class="line">    _bottomView.frame &#x3D; bottomViewFrame;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (void)didHide:(NSNotification *)noti &#123;</span><br><span class="line">    NSLog(@&quot;didHide&quot;);</span><br><span class="line">    keyboarShow &#x3D; NO;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h1 id="点击UIScrollView触发UIKeyboardWillShowNotification通知"><a href="#点击UIScrollView触发UIKeyboardWillShowNotification通知" class="headerlink" title="点击UIScrollView触发UIKeyboardWillShowNotification通知"></a>点击UIScrollView触发<code>UIKeyboardWillShowNotification</code>通知</h1><p>点击TextFiled或者TextView后，再点击UIScrollView，<code>UIKeyboardWillShowNotification</code>的回调会被触发，我不能确定造成这个现象的原因是什么，不过猜测是因为iOS的事件管理系统的内部bug导致的。解决这个问题的终极方法和我们上面⬆️用的方法是一样的。</p><div class="note info"><p>到公众号【iOS开发栈】学习更多SwiftUI、iOS开发相关内容。回复“博客”免费获取各大互联网公司面试题。</p></div><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>通过这篇文章我们讨论了在使用<code>UIScrollView</code>的时候会出现的一些关于键盘的问题，并且给出了具体的解决方案，以及用到了UIKeybaord的一些通知，希望对你有所帮助。</p><p>如果你有任何的问题、建议都可以通过<a href="https://weibo.com/7414691003/profile">微博</a>或<a href="mailto:shizhiang@126.com">邮件</a>联系到我本人。</p>]]></content>
    
    
    <summary type="html">&lt;p&gt;我们在iOS的开发过程中，经常要在包含UIScrollView的view中监听键盘的通知，有时候会出现一些bug，比方说&lt;code&gt;UIKeyboardWillShowNotification&lt;/code&gt;可能会调用多次。&lt;/p&gt;
&lt;p&gt;通过这篇文章我们来讨论几个经常出现的问题，并且了解一下对应的解决方案。&lt;/p&gt;</summary>
    
    
    
    
    <category term="iOS" scheme="http://www.iosprogrammer.tech/tags/iOS/"/>
    
  </entry>
  
  <entry>
    <title>在SwiftUI中使用ForEach和List模仿UITableView、UICollectionView</title>
    <link href="http://www.iosprogrammer.tech/swiftui/what-is-the-different-between-foreach-and-list/"/>
    <id>http://www.iosprogrammer.tech/swiftui/what-is-the-different-between-foreach-and-list/</id>
    <published>2021-01-26T05:54:47.000Z</published>
    <updated>2021-02-25T06:53:41.438Z</updated>
    
    <content type="html"><![CDATA[<p>ForEach和List都可以创建列表，它们都是SwiftUI重要的组件，它们用来替代UIKit中的UITableView。通过这篇文章我们将学习到ForEach和List的相关用法。</p><p>这篇文章非常适合SwiftUI入门的同学。</p><a id="more"></a><div class="note info"><p>到公众号【iOS开发栈】学习更多SwiftUI、iOS开发相关内容。回复“博客”免费获取各大互联网公司面试题。</p></div><p><img src="../../images/swiftui-list/blog-main-picture.png"></p><h2 id="List的用法"><a href="#List的用法" class="headerlink" title="List的用法"></a>List的用法</h2><p>首先来看一下<code>List</code>。List最简单的用法</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">List</span>(<span class="number">0</span><span class="operator">..&gt;</span><span class="number">10</span>) &#123;</span><br><span class="line">    <span class="type">Text</span>(<span class="string">&quot;Hellow, SwiftUI&quot;</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这样只是简单的把一个文字迭代了10遍组成一个列表。下面假设有一个学生数组，数组是由20个字典组成，每个字典包含学生的id和姓名两个元素。</p><p><img src="../../images/swiftui-list/2.png" alt="SwiftUI List用法"></p><p>让我们来看一下<code>List</code>的创建方法：</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">List</span>(students, id: \.id) &#123; student <span class="keyword">in</span></span><br><span class="line">    <span class="type">Text</span>(<span class="string">&quot;student id:<span class="subst">\(student.id)</span> name:<span class="subst">\(student.name)</span>&quot;</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>List的初始化用到了3个参数：</p><ol><li>一个未命名的<code>data</code>，被迭代的数组。这里我们用的是<code>students</code>。</li><li>keypath类型的<code>id</code>参数，用来唯一区分当前迭代到的元素是数组中的哪一个。</li><li>最后一个参数是一个闭包，每一次迭代都会把闭包中的view组成一个新的view。因为这是最后一个参数，所以可以使用尾随闭包。</li></ol><h2 id="ForEach的用法"><a href="#ForEach的用法" class="headerlink" title="ForEach的用法"></a>ForEach的用法</h2><p><code>ForEach</code>和<code>List</code>一样都可以进行数组迭代来创建列表，把上面的例子用ForEach实现。</p><p><img src="../../images/swiftui-list/3.png" alt="SwiftUI ForEach用法"></p><p><code>ForEach</code>的参数和<code>List</code>几乎一样，这里不再赘述。</p><h2 id="List和ForEach的不同"><a href="#List和ForEach的不同" class="headerlink" title="List和ForEach的不同"></a>List和ForEach的不同</h2><p>从上图可以看出ForEach和List的语法非常的相似，不过ForEach在<em>Preview</em>中展示的效果却分成了好多个屏幕。</p><p>这个效果其实和下面的代码是一样的。</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">ContentView</span>: <span class="title">View</span> </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> students: [<span class="type">Student</span>]</span><br><span class="line">    <span class="keyword">var</span> body: <span class="keyword">some</span> <span class="type">View</span> &#123;</span><br><span class="line">        <span class="type">Text</span>(<span class="string">&quot;Student id:0 name:aaa&quot;</span>)</span><br><span class="line">        <span class="type">Text</span>(<span class="string">&quot;Student id:0 name:aaa&quot;</span>)</span><br><span class="line">        <span class="type">Text</span>(<span class="string">&quot;Student id:0 name:aaa&quot;</span>)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>之所以会是这样，是因为ForEach并不会生成一个容器来包装闭包里面的View，而List却正好相反，并且<strong>ForEach的列表是不能滚动的</strong>，也就是说当里面的view超出了ForEach的父视图的大小是不能滚动的。这也是咱们在使用List和ForEach的时候需要注意的点。</p><h2 id="List和ForEach的适用场景"><a href="#List和ForEach的适用场景" class="headerlink" title="List和ForEach的适用场景"></a>List和ForEach的适用场景</h2><p>因为List会默认生成一个容器来包装它里面的子view，所以它更适合单独使用来创建一个可以支持纵向滚动的列表，就像咱们上面的用法。</p><p>而ForEach不会生成一个容器，而且不能支持滚动，所以一般把它嵌套在其他容器里面使用。</p><h3 id="List嵌套ForEach"><a href="#List嵌套ForEach" class="headerlink" title="List嵌套ForEach"></a>List嵌套ForEach</h3><p>嵌套在<code>List</code>里面可以实现类似带header的UITableView的效果，这里同时展示了固定不动的Header和跟随滚动的Header。</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">ContentView</span>: <span class="title">View</span> </span>&#123;</span><br><span class="line">    <span class="meta">@State</span> <span class="keyword">var</span> students: [<span class="type">Student</span>]</span><br><span class="line">    <span class="keyword">var</span> body: <span class="keyword">some</span> <span class="type">View</span> &#123;</span><br><span class="line">        <span class="type">VStack</span> &#123;</span><br><span class="line">            <span class="type">Text</span>(<span class="string">&quot;这是固定不动的Header&quot;</span>)</span><br><span class="line">            <span class="type">List</span> &#123;</span><br><span class="line">                <span class="type">Text</span>(<span class="string">&quot;这是跟随滚动的Header&quot;</span>)</span><br><span class="line">                <span class="type">ForEach</span>(students, id: \.id) &#123; stu <span class="keyword">in</span></span><br><span class="line">                    <span class="type">Text</span>(<span class="string">&quot;student id:<span class="subst">\(stu.id)</span> name: <span class="subst">\(stu.name)</span>&quot;</span>).frame(width: <span class="number">200</span>, height: <span class="number">60</span>)</span><br><span class="line">                &#125;</span><br><span class="line">                .onDelete&#123; indexSet <span class="keyword">in</span></span><br><span class="line">                    <span class="keyword">for</span> index <span class="keyword">in</span> indexSet &#123;</span><br><span class="line">                        students.remove(at: index)</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="type">Text</span>(<span class="string">&quot;这是跟随滚动Footer&quot;</span>)</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="type">Text</span>(<span class="string">&quot;这是固定不动的Footer&quot;</span>)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="../../images/swiftui-list/4.png" alt="SwiftUI ForEach用法"></p><p>这里面有两点需要注意：</p><ol><li><code>@State</code> 通过添加<a href="./swiftui-concept-essential">数据绑定</a>使view的改变和数据联系起来，如果不添加这个会报错 <mark class="label danger">Cannot use mutating member on immutable value: self is immutable</mark></li><li><code>.onDelete</code> 添加了这个<a href="./swiftui-concept-essential">modifire</a>后出现左滑删除的效果</li></ol><h3 id="ScrollView嵌套ForEach"><a href="#ScrollView嵌套ForEach" class="headerlink" title="ScrollView嵌套ForEach"></a>ScrollView嵌套ForEach</h3><p>用横向滚动的<code>ScrollView</code>嵌套<code>ForEach</code>可以实现类似UIKit中横向滚动的<code>UICollectionView</code>。</p><p><img src="../../images/swiftui-list/5.png" alt="SwiftUI ForEach用法"></p><h3 id="Section嵌套ForEach"><a href="#Section嵌套ForEach" class="headerlink" title="Section嵌套ForEach"></a>Section嵌套ForEach</h3><p>使用List、Section、ForEach嵌套来实现类似于UITableView的分组效果。</p><p>还是使用上面的学生例子，现在我们来给学生分班。先来创建两个班级：</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">enum</span> <span class="title">StuCls</span>: <span class="title">String</span>, <span class="title">CaseIterable</span> </span>&#123;</span><br><span class="line">    <span class="keyword">case</span> <span class="type">ClsOne</span> <span class="operator">=</span> <span class="string">&quot;一班&quot;</span></span><br><span class="line">    <span class="keyword">case</span> <span class="type">ClsTwo</span> <span class="operator">=</span> <span class="string">&quot;二班&quot;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>把学生划分到班级里面</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Student</span>: <span class="title">Identifiable</span> </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> id: <span class="type">Int</span></span><br><span class="line">    <span class="keyword">var</span> name: <span class="type">String</span></span><br><span class="line">    <span class="keyword">var</span> classId: <span class="type">StuCls</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>接下来创建几个分好班的学生：</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> std1 <span class="operator">=</span> <span class="type">Student</span>(id: <span class="number">0</span>, name: <span class="string">&quot;学生1&quot;</span>, classId: <span class="type">StuCls</span>.<span class="type">ClsOne</span>)</span><br><span class="line"><span class="keyword">let</span> std2 <span class="operator">=</span> <span class="type">Student</span>(id: <span class="number">1</span>, name: <span class="string">&quot;学生2&quot;</span>, classId: <span class="type">StuCls</span>.<span class="type">ClsOne</span>)</span><br><span class="line"><span class="keyword">let</span> std3 <span class="operator">=</span> <span class="type">Student</span>(id: <span class="number">2</span>, name: <span class="string">&quot;学生3&quot;</span>, classId: <span class="type">StuCls</span>.<span class="type">ClsOne</span>)</span><br><span class="line"><span class="keyword">let</span> std4 <span class="operator">=</span> <span class="type">Student</span>(id: <span class="number">2</span>, name: <span class="string">&quot;学生4&quot;</span>, classId: <span class="type">StuCls</span>.<span class="type">ClsTwo</span>)</span><br><span class="line"><span class="keyword">let</span> std5 <span class="operator">=</span> <span class="type">Student</span>(id: <span class="number">2</span>, name: <span class="string">&quot;学生5&quot;</span>, classId: <span class="type">StuCls</span>.<span class="type">ClsTwo</span>)</span><br><span class="line"><span class="keyword">let</span> std6 <span class="operator">=</span> <span class="type">Student</span>(id: <span class="number">2</span>, name: <span class="string">&quot;学生6&quot;</span>, classId: <span class="type">StuCls</span>.<span class="type">ClsTwo</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> students <span class="operator">=</span> [std1, std2, std3, std4, std5, std6]</span><br></pre></td></tr></table></figure><p>最后，结合List、ForEach和Section创建可以分组的列表</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">List</span> &#123;</span><br><span class="line">    <span class="type">ForEach</span>(<span class="type">StuCls</span>.allCases, id: \.rawValue) &#123; cls <span class="keyword">in</span></span><br><span class="line">        <span class="type">Section</span>(header: <span class="type">Text</span>(cls.rawValue)) &#123;</span><br><span class="line">            <span class="type">ForEach</span>(students.filter &#123; <span class="variable">$0</span>.classId <span class="operator">==</span> cls &#125;, id: \.id) &#123; stu <span class="keyword">in</span></span><br><span class="line">                <span class="type">Text</span>(<span class="string">&quot;student id:<span class="subst">\(stu.id)</span> name: <span class="subst">\(stu.name)</span>&quot;</span>)</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="../../images/swiftui-list/6.png" alt="SwiftUI ForEach用法"></p><div class="note info"><p>到公众号【iOS开发栈】学习更多SwiftUI、iOS开发相关内容。回复“博客”免费获取各大互联网公司面试题。</p></div><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>在这篇文章中我们学习了SwiftUI中<code>List</code>/<code>ForEach</code>/<code>ScrollView</code>/<code>Section</code>的用法，并利用一个例子详细说明了前两个的不同和使用场景。你应该学到了：</p><ul><li><code>List</code>和<code>ForEach</code>的用法，它们之间的区别和使用场景</li><li>怎么创建一个像UICollectionView一样横向滚动的列表</li><li>类似UITableView的分组列表要怎样实现</li><li>头部固定不动和跟随滚动的列表的实现方案</li></ul>]]></content>
    
    
    <summary type="html">&lt;p&gt;ForEach和List都可以创建列表，它们都是SwiftUI重要的组件，它们用来替代UIKit中的UITableView。通过这篇文章我们将学习到ForEach和List的相关用法。&lt;/p&gt;
&lt;p&gt;这篇文章非常适合SwiftUI入门的同学。&lt;/p&gt;</summary>
    
    
    
    
    <category term="SwiftUI" scheme="http://www.iosprogrammer.tech/tags/SwiftUI/"/>
    
  </entry>
  
  <entry>
    <title>学习SwiftUI，必须掌握的3个知识点</title>
    <link href="http://www.iosprogrammer.tech/swiftui/swiftui-concept-essential/"/>
    <id>http://www.iosprogrammer.tech/swiftui/swiftui-concept-essential/</id>
    <published>2021-01-23T14:36:39.000Z</published>
    <updated>2021-04-14T00:53:03.545Z</updated>
    
    <content type="html"><![CDATA[<p>在WWDC2019中，iOS引入了一个全新的UI框架——SwiftUI。它的目的是通过全新的设计思想来解决iPhone、iPad、Mac的界面统一，以便开发者可以通过一次学习多处使用（Learn Once, Use anywhere）。从iOS13开始我们就可以使用这个全新的框架了，iOS开发者应该尽快掌握它。</p><a id="more"></a><div class="note info"><p>到公众号【iOS开发栈】学习更多SwiftUI、iOS开发相关内容。</p></div><h2 id="View"><a href="#View" class="headerlink" title="View"></a>View</h2><p>SwiftUI中一切皆View，不论是我们熟悉的<code>Button</code>还是<code>backgroundColor</code>，甚至<code>Color.red</code>，它们都是<code>View</code>。</p><p>与UIKit中的<code>UIView</code>不同的是，在SwiftUI中<code>View</code>不再是一个类而是一个协议。`</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">protocol</span> <span class="title">View</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/// The type of view representing the body of this view.</span></span><br><span class="line">    <span class="comment">///</span></span><br><span class="line">    <span class="comment">/// When you create a custom view, Swift infers this type from your</span></span><br><span class="line">    <span class="comment">/// implementation of the required `body` property.</span></span><br><span class="line">    <span class="keyword">associatedtype</span> <span class="type">Body</span> : <span class="type">View</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">/// The content and behavior of the view.</span></span><br><span class="line">    <span class="meta">@ViewBuilder</span> <span class="keyword">var</span> body: <span class="keyword">Self</span>.<span class="type">Body</span> &#123; <span class="keyword">get</span> &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>SwiftUI中的View是不能直接使用的，否则会报错 <mark class="label danger">'View' cannot be constructed because it has no accessible initializers</mark>，当你遇到这个问题的时候请仔细思考一下你是不是真的要这么用，或许可以用一个其他的代替。</p><p>常用到的<code>View</code>有：<code>Text</code>/<code>Button</code>/<code>Toggle</code>/<code>Picker</code>/<code>V(Z)(H)Stack</code>/<code>Color</code>/<code>Spacer</code>/<code>Image</code>/<code>Shape</code>/<code>Divider</code>以及它们的<code>modifier</code>等。</p><p><code>@ViewBuilder</code>标记的<code>body</code>变量表示它是一个容器，里面可以包含任意多个其他的<code>View</code>。</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">Button</span>(action: btnClick) &#123;</span><br><span class="line">    <span class="type">VStack</span> &#123;</span><br><span class="line">        <span class="type">Image</span>(systemName: <span class="string">&quot;star&quot;</span>)</span><br><span class="line">        <span class="type">Text</span>(<span class="string">&quot;Placeholder&quot;</span>)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="Modifer"><a href="#Modifer" class="headerlink" title="Modifer"></a>Modifer</h2><p>我们分别看一下在UIKit和SwiftUI中修改一个Label的文字颜色</p><div class="tabs" id="modify-label-text-color"><ul class="nav-tabs"><li class="tab active"><a href="#modify-label-text-color-1">UIKit</a></li><li class="tab"><a href="#modify-label-text-color-2">SwiftUI</a></li></ul><div class="tab-content"><div class="tab-pane active" id="modify-label-text-color-1"><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> label <span class="operator">=</span> <span class="type">UILabel</span>()</span><br><span class="line">label.text <span class="operator">=</span> <span class="string">&quot;UIKit&quot;</span></span><br><span class="line">label.textColor <span class="operator">=</span> <span class="type">UIColor</span>.red</span><br></pre></td></tr></table></figure></div><div class="tab-pane" id="modify-label-text-color-2"><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">Text</span>(<span class="string">&quot;SwiftUI&quot;</span>).foregroundColor(.red)</span><br></pre></td></tr></table></figure></div></div></div><p>SwiftUI中的<code>.foregroundColor</code>和<code>textColor</code>有本质的不同，它是一种<strong>modifier</strong>，它返回的是令一个View。</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">@inlinable</span> <span class="keyword">public</span> <span class="function"><span class="keyword">func</span> <span class="title">foregroundColor</span><span class="params">(<span class="keyword">_</span> color: Color?)</span></span> -&gt; <span class="keyword">some</span> <span class="type">View</span></span><br></pre></td></tr></table></figure><p>当我们调用了<code>.foregroundColor</code>其实是创造了一个新的View，这也正是SwiftUI中万物皆View的例子。</p><h2 id="State和-——-Binding-Value"><a href="#State和-——-Binding-Value" class="headerlink" title="@State和$ —— Binding Value"></a>@State和$ —— Binding Value</h2><div class="tabs" id="toggle"><ul class="nav-tabs"><li class="tab active"><a href="#toggle-1">代码</a></li><li class="tab"><a href="#toggle-2">效果图</a></li></ul><div class="tab-content"><div class="tab-pane active" id="toggle-1"><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">ContentView</span>: <span class="title">View</span> </span>&#123;</span><br><span class="line">    <span class="meta">@State</span> <span class="keyword">var</span> isOn: <span class="type">Bool</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">var</span> body: <span class="keyword">some</span> <span class="type">View</span> &#123;</span><br><span class="line">        <span class="type">Toggle</span>(isOn: <span class="variable">$isOn</span>) &#123;</span><br><span class="line">            <span class="type">Text</span>(<span class="string">&quot;Toggle&quot;</span>)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div><div class="tab-pane" id="toggle-2"><p><img src="../images/swiftui-concept/1.png" alt="SwiftUI Toggle Binding"></p></div></div></div><blockquote><p>这是一个双向绑定</p></blockquote><p>绑定建立以后，不论是<code>isOn</code>的修改触发了Toggle状态的改变，还是用户点击了Toggle引起<code>isOn</code>变量值的改变我们都不需要关心，SwiftUI会帮我们完成。</p><div class="note info"><p>到公众号【iOS开发栈】学习更多SwiftUI、iOS开发相关内容。</p></div><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>这篇文章聊了SwiftUI中最基础最重要的3个概念，如果你有任何的问题、建议都可以通过<a href="https://weibo.com/7414691003/profile">微博</a>或<a href="mailto:shizhiang@126.com">邮件</a>联系到我本人。</p>]]></content>
    
    
    <summary type="html">&lt;p&gt;在WWDC2019中，iOS引入了一个全新的UI框架——SwiftUI。它的目的是通过全新的设计思想来解决iPhone、iPad、Mac的界面统一，以便开发者可以通过一次学习多处使用（Learn Once, Use anywhere）。从iOS13开始我们就可以使用这个全新的框架了，iOS开发者应该尽快掌握它。&lt;/p&gt;</summary>
    
    
    
    
    <category term="SwiftUI" scheme="http://www.iosprogrammer.tech/tags/SwiftUI/"/>
    
  </entry>
  
  <entry>
    <title>最佳实践：iOS开发在xib/storyboard中自定义view</title>
    <link href="http://www.iosprogrammer.tech/how-to-make-view-get-intrinsic-content-size/"/>
    <id>http://www.iosprogrammer.tech/how-to-make-view-get-intrinsic-content-size/</id>
    <published>2021-01-14T06:21:41.000Z</published>
    <updated>2021-03-23T03:06:18.160Z</updated>
    
    <content type="html"><![CDATA[<p>在xib或者storyboard嵌套另一个用xib布局的view是一个经常用到的技术点，要完全掌握好这个知识点不是那么容易，用常规的xib创建view的方法通常并不能满足我们的需求。</p><p>当我们使用Autolayout自动布局时，在xib中嵌套一个自定义的view可能就更麻烦了。通过这篇文章你将学习到嵌套xib布局的方法和怎么在xib中使用autolayout的一些高级用法来使view向label一样具有contrisic content size。</p><a id="more"></a><h3 id="从xib加载自定义view视图"><a href="#从xib加载自定义view视图" class="headerlink" title="从xib加载自定义view视图"></a>从xib加载自定义view视图</h3><p>新建项目:<br><img src="../images/xib-view/xib-1.png"></p><p>添加view和xib到项目中：</p><p><img src="../images/xib-view/xib-4.png"><br><img src="../images/xib-view/xib-2.png"><br><img src="../images/xib-view/xib-3.png"></p><p>设置xib的大小为freedom，并设置xib的大小为 200x100</p><p><img src="../images/xib-view/xib-6.png"><br><img src="../images/xib-view/xib-7.png"></p><p><strong>设置xib的 Fils’s Owner 为CustomView，不要设置view的class</strong></p><p><img src="../images/xib-view/xib-5.png"></p><h3 id="xib文件中添加view并设置约束"><a href="#xib文件中添加view并设置约束" class="headerlink" title="xib文件中添加view并设置约束"></a>xib文件中添加view并设置约束</h3><p><img src="../images/xib-view/xib-8.png"></p><p>设置约束后的xib是这样：</p><p><img src="../images/xib-view/xib-15.png"></p><h3 id="xib和-m建立链接"><a href="#xib和-m建立链接" class="headerlink" title=".xib和.m建立链接"></a>.xib和.m建立链接</h3><p><img src="../images/xib-view/xib-13.png"></p><h3 id="重写initWithCoder-方法把xib中的view添加进来"><a href="#重写initWithCoder-方法把xib中的view添加进来" class="headerlink" title="重写initWithCoder:方法把xib中的view添加进来"></a>重写<code>initWithCoder:</code>方法把xib中的view添加进来</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">- (instancetype)initWithCoder:(NSCoder *)coder</span><br><span class="line">&#123;</span><br><span class="line">    self &#x3D; [super initWithCoder:coder];</span><br><span class="line">    if (self) &#123;</span><br><span class="line">        &#x2F;&#x2F; 加载xib，注意owner: self</span><br><span class="line">        [[NSBundle mainBundle] loadNibNamed:NSStringFromClass([self class]) owner:self options:nil];</span><br><span class="line">        self.contentView.frame &#x3D; self.bounds;</span><br><span class="line">        [self addSubview:self.contentView];</span><br><span class="line">    &#125;</span><br><span class="line">    return self;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="在Main-storyboard中添加CustomView，并设置约束"><a href="#在Main-storyboard中添加CustomView，并设置约束" class="headerlink" title="在Main.storyboard中添加CustomView，并设置约束"></a>在Main.storyboard中添加CustomView，并设置约束</h3><img src="../images/xib-view/xib-9.png"/><img src="../images/xib-view/xib-10.png"  style="height:300px"/><p>这时候会报错，因为view的约束不足。</p><p><img src="../images/xib-view/xib-11.png"></p><h3 id="让UIView像UILabel一样拥有IntrinsicContentSize"><a href="#让UIView像UILabel一样拥有IntrinsicContentSize" class="headerlink" title="让UIView像UILabel一样拥有IntrinsicContentSize"></a>让UIView像UILabel一样拥有IntrinsicContentSize</h3><p>在UIKit中有一些视图具有intrinsicContentSize，比如UILabel、UIButotn、UIImageView等。这类视图可以根据自身的内容确定大小，在设置约束时只需要确定位置（x/y）就可以了。</p><p>但是UIView本身是不具备这个特性的，不过我们可以通过在xib或者storyboard中<strong>设置intrinsicSize来告诉编译器当前的视图是可以确定自身大小的</strong>。</p><p><img src="../images/xib-view/xib-12.png"></p><p>这样设置以后约束不足的警告就没有了。</p><p><img src="../images/xib-view/xib-16.png"></p><p>最终，view controller中customView的展示就是.xib中的样子了。</p><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>通过这篇文章我们可以学到：</p><ul><li>xib自定义view的方法</li><li>让UIView像UILabel一样拥有IntrinsicContentSize的方法</li><li>xib嵌套使用的方法</li></ul><p><strong>想了解更多内容关注公众号【iOS开发栈】。</strong></p>]]></content>
    
    
    <summary type="html">&lt;p&gt;在xib或者storyboard嵌套另一个用xib布局的view是一个经常用到的技术点，要完全掌握好这个知识点不是那么容易，用常规的xib创建view的方法通常并不能满足我们的需求。&lt;/p&gt;
&lt;p&gt;当我们使用Autolayout自动布局时，在xib中嵌套一个自定义的view可能就更麻烦了。通过这篇文章你将学习到嵌套xib布局的方法和怎么在xib中使用autolayout的一些高级用法来使view向label一样具有contrisic content size。&lt;/p&gt;</summary>
    
    
    
    
    <category term="iOS" scheme="http://www.iosprogrammer.tech/tags/iOS/"/>
    
  </entry>
  
</feed>
